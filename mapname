game/client/baseanimatedtextureproxy.cpp:	float deltaTime = gpGlobals->curtime - startTime;
game/client/baseanimatedtextureproxy.cpp:	float prevTime = deltaTime - gpGlobals->frametime;
game/client/c_soundscape.cpp:		m_nRestoreFrame = gpGlobals->framecount;
game/client/c_soundscape.cpp:		return gpGlobals->framecount == m_nRestoreFrame ? true : false;
game/client/c_soundscape.cpp:	UpdateRandomSounds( gpGlobals->curtime );
game/client/c_soundscape.cpp:	m_nextRandomTime = gpGlobals->curtime;
game/client/c_soundscape.cpp:	m_randomSounds[index].nextPlayTime = gpGlobals->curtime + 0.5 * RandomInterval( sound.time );
game/client/particlemgr.cpp:	g_pParticleSystemMgr->SetLastSimulationTime( gpGlobals->curtime );
game/client/particlemgr.cpp:		if ( pDef->HasRetirementBeenChecked( gpGlobals->framecount ) )
game/client/particlemgr.cpp:		pDef->MarkRetirementCheck( gpGlobals->framecount );
game/client/particlemgr.cpp:	g_pParticleSystemMgr->SetLastSimulationTime( gpGlobals->curtime );
game/client/particlemgr.cpp:	return gpGlobals->curtime;
game/client/particlemgr.cpp:	return gpGlobals->frametime;
game/client/c_particle_system.cpp:			SetNextClientThink( gpGlobals->curtime );
game/client/c_particle_system.cpp:				SetNextClientThink( gpGlobals->curtime );
game/client/c_particle_system.cpp:				float flTimeDelta = gpGlobals->curtime - m_flStartTime;
game/client/hud_controlpointicons.cpp:	if ( m_flStartCapAnimStart && gpGlobals->curtime > m_flStartCapAnimStart )
game/client/hud_controlpointicons.cpp:		float flElapsedTime = (gpGlobals->curtime - m_flStartCapAnimStart);
game/client/hud_controlpointicons.cpp:	m_flStartCapAnimStart = gpGlobals->curtime + flDelay;
game/client/hud_controlpointicons.cpp:				m_pCapPulseImage->StartPulse( gpGlobals->curtime, GetWide() );
game/client/hud_controlpointicons.cpp:			int nTimeToUnlock = m_pCountdown->GetUnlockTime() - gpGlobals->curtime;
game/client/hud_controlpointicons.cpp:		m_pBaseImage->StartPulsing( flTime + FINISHCAPANIM_SWOOP_LENGTH - gpGlobals->curtime, 0.8, false );
game/client/hud_controlpointicons.cpp:	if ( m_flCPTimerTime - gpGlobals->curtime > 0 )
game/client/hud_controlpointicons.cpp:		nTime = ceil( m_flCPTimerTime - gpGlobals->curtime );
game/client/hud_controlpointicons.cpp:				m_Icons[i]->FakePulse( gpGlobals->curtime + (i * PULSE_TIME_PER_ICON) );
game/client/hud_controlpointicons.cpp:			m_flFakeCaptureTime = gpGlobals->curtime + FAKE_CAPTURE_TIME + FAKE_CAPTURE_POST_PAUSE;
game/client/hud_controlpointicons.cpp:			m_flFakeCaptureTime = gpGlobals->curtime + FAKE_CAPTURE_TIME + FAKE_CAPTURE_POST_PAUSE;
game/client/hud_controlpointicons.cpp:	float flTimeDiff = m_flUnlockTime - gpGlobals->curtime;
game/client/hud_controlpointicons.cpp:	int iTimeLeft = m_flUnlockTime - gpGlobals->curtime;
game/client/c_playerresource.cpp:		SetNextClientThink( gpGlobals->curtime + PLAYER_RESOURCE_THINK_INTERVAL );
game/client/c_playerresource.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/client/c_playerresource.cpp:	SetNextClientThink( gpGlobals->curtime + PLAYER_RESOURCE_THINK_INTERVAL );
game/client/c_te_legacytempents.cpp:	float life = die - gpGlobals->curtime;
game/client/c_te_legacytempents.cpp:	float fastFreq = gpGlobals->curtime * 5.5;
game/client/c_te_legacytempents.cpp:			x + sin( m_vecTempEntVelocity[2] + gpGlobals->curtime /* * anim.prevframe */ ) * (10*m_flSpriteScale),
game/client/c_te_legacytempents.cpp:			m_vecTempEntVelocity[0] * frametime + 8 * sin( gpGlobals->curtime * 20 ),
game/client/c_te_legacytempents.cpp:			m_vecTempEntVelocity[1] * frametime + 4 * sin( gpGlobals->curtime * 30 ),
game/client/c_te_legacytempents.cpp:				if ( m_iLastCollisionFrame + cl_fasttempentcollision.GetInt() > gpGlobals->framecount )
game/client/c_te_legacytempents.cpp:					m_iLastCollisionFrame = gpGlobals->framecount;
game/client/c_te_legacytempents.cpp:				die = gpGlobals->curtime;			
game/client/c_te_legacytempents.cpp:					die = gpGlobals->curtime;
game/client/c_te_legacytempents.cpp:		dl->die = gpGlobals->curtime + 0.01;
game/client/c_te_legacytempents.cpp:		GetWindspeedAtTime( gpGlobals->curtime, vecWind );
game/client/c_te_legacytempents.cpp:		pTemp->die = gpGlobals->curtime + (maxHeight / zspeed) - 0.1;
game/client/c_te_legacytempents.cpp:		pTemp->die = gpGlobals->curtime + ((height - (origin[2] - mins[2])) / zspeed) - 0.1;
game/client/c_te_legacytempents.cpp:		pTemp->die = gpGlobals->curtime + ((flWaterZ - origin[2]) / zspeed) - 0.1;
game/client/c_te_legacytempents.cpp:		pTemp->die = gpGlobals->curtime + life + random->RandomFloat(0,1);	// Add an extra 0-1 secs of life
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + lifetime;
game/client/c_te_legacytempents.cpp:		pTemp->die = gpGlobals->curtime + life;
game/client/c_te_legacytempents.cpp:		pTemp->die = gpGlobals->curtime + (frameCount * 0.1) + 1;
game/client/c_te_legacytempents.cpp:		pTemp->die = gpGlobals->curtime + 0.35;
game/client/c_te_legacytempents.cpp:		pTemp->die			= gpGlobals->curtime + flLife + random->RandomFloat( 0, 4 );
game/client/c_te_legacytempents.cpp:	if ( client <= 0 || client > gpGlobals->maxClients )
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + life;
game/client/c_te_legacytempents.cpp:	if ( client <= 0 || client > gpGlobals->maxClients )
game/client/c_te_legacytempents.cpp:				pTemp->die = gpGlobals->curtime;// good enough, it will die on next tent update. 
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime;
game/client/c_te_legacytempents.cpp:			pTemp->die				= gpGlobals->curtime + (frameCount / pTemp->m_flFrameRate); // Play the whole thing Once
game/client/c_te_legacytempents.cpp:	if ( gpGlobals->frametime == 0.0 )
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + (float)frameCount / framerate;
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + 60.0f + random->RandomFloat( 0.0f, 1.0f );	// Add an extra 0-1 secs of life	
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + flLifeTime;
game/client/c_te_legacytempents.cpp:	pTemp->Prepare( model, gpGlobals->curtime );
game/client/c_te_legacytempents.cpp:	pTemp->Prepare( model, gpGlobals->curtime );
game/client/c_te_legacytempents.cpp:	frametime = gpGlobals->frametime;
game/client/c_te_legacytempents.cpp:						current->die = gpGlobals->curtime;
game/client/c_te_legacytempents.cpp:			el->die		= gpGlobals->curtime + 0.05f;
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + 0.01;
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + 2.5;
game/client/c_te_legacytempents.cpp:	pTemp->die = gpGlobals->curtime + 10;
game/client/hltvcamera.cpp:  	m_flLastDistance += gpGlobals->frametime * 32.0f; 
game/client/hltvcamera.cpp:	accelspeed = accel * gpGlobals->frametime * wishspeed;
game/client/hltvcamera.cpp:				float drop = control * friction * gpGlobals->frametime;
game/client/hltvcamera.cpp:		VectorMA( m_vCamOrigin, gpGlobals->frametime, m_vecVelocity, m_vCamOrigin );
game/client/hltvcamera.cpp:	if ( m_iTraget1 > 0 && m_iTraget1 <= gpGlobals->maxClients )
game/client/hltvcamera.cpp:			index = gpGlobals->maxClients;
game/client/hltvcamera.cpp:		else if ( index > gpGlobals->maxClients )
game/client/hltvcamera.cpp:	for ( int index = 1; index <= gpGlobals->maxClients; ++index )
game/client/hltvcamera.cpp:	m_flLastAngleUpdateTime = gpGlobals->realtime;
game/client/hltvcamera.cpp:		float deltaTime = gpGlobals->realtime - m_flLastAngleUpdateTime;
game/client/hltvcamera.cpp:	m_flLastAngleUpdateTime = gpGlobals->realtime;
game/client/c_entitydissolve.cpp:	if ( m_flNextSparkTime > gpGlobals->curtime )
game/client/c_entitydissolve.cpp:	float dt = m_flStartTime + m_flFadeOutStart - gpGlobals->curtime;
game/client/c_entitydissolve.cpp:	m_flNextSparkTime = gpGlobals->curtime + flNextTime;
game/client/c_entitydissolve.cpp:	float dt = gpGlobals->curtime - m_flStartTime;
game/client/c_entitydissolve.cpp:	float dt = gpGlobals->curtime - m_flStartTime;
game/client/c_entitydissolve.cpp:	float dt = gpGlobals->curtime - m_flStartTime;
game/client/c_entitydissolve.cpp:	if ( gpGlobals->frametime == 0 || m_bReadyToDraw == false )
game/client/c_entitydissolve.cpp:	float spriteScale = ( ( gpGlobals->curtime - m_flStartTime ) / m_flFadeOutLength );
game/client/c_props.cpp:			if ( gpGlobals->framecount != m_iCachedFrameCount )
game/client/c_props.cpp:				m_iCachedFrameCount = gpGlobals->framecount;
game/client/hud_lcd.cpp:	unsigned int dwCurTime = (unsigned int)( 1000.0 * gpGlobals->realtime );
game/client/hud_lcd.cpp:							for ( int pl = 1; pl <= gpGlobals->maxClients; ++pl )
game/client/hud_lcd.cpp:								for ( int pl = 1; pl <= gpGlobals->maxClients; ++pl )
game/client/c_point_commentary_node.cpp:	float flPercentage = clamp( ( gpGlobals->curtime - m_flStartTime ) / flDuration, 0.f, 1.f );
game/client/c_point_commentary_node.cpp:	if ( fabs(flStartTime - gpGlobals->curtime) < 1.0 )
game/client/ragdoll.cpp:	m_flLastOriginChangeTime = gpGlobals->curtime;
game/client/ragdoll.cpp:	if ( m_lastUpdate == gpGlobals->curtime )
game/client/ragdoll.cpp:	m_lastUpdate = gpGlobals->curtime;
game/client/ragdoll.cpp:			m_flLastOriginChangeTime = gpGlobals->curtime;
game/client/ragdoll.cpp:			// Msg( "%d [%p] Still moving\n", gpGlobals->tickcount, this );
game/client/ragdoll.cpp:	// Msg( "%d [%p] Settling\n", gpGlobals->tickcount, this );
game/client/ragdoll.cpp:	float dt = gpGlobals->curtime - m_flLastOriginChangeTime;
game/client/ragdoll.cpp:	// Msg( "%d [%p] FORCE SLEEP\n",gpGlobals->tickcount, this );
game/client/ragdoll.cpp:	m_flLastOriginChangeTime = gpGlobals->curtime;
game/client/ragdoll.cpp:	m_iv_ragPos.NoteChanged( gpGlobals->curtime, true );
game/client/ragdoll.cpp:	m_iv_ragAngles.NoteChanged( gpGlobals->curtime, true );
game/client/ragdoll.cpp:	m_flLastBoneChangeTime = gpGlobals->curtime + GetInterpolationAmount(m_iv_ragPos.GetType());
game/client/ragdoll.cpp:	m_flBlendWeightCurrent = Approach( m_flBlendWeight, m_flBlendWeightCurrent, gpGlobals->frametime * 5.0f );
game/client/ragdoll.cpp:		float frac = RemapVal( gpGlobals->curtime, m_parentTime, m_parentTime+ATTACH_INTERP_TIME, 0, 1 );
game/client/ragdoll.cpp:			parent->SetupBones( NULL, -1, BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/client/ragdoll.cpp:			m_parentTime = gpGlobals->curtime;
game/client/ragdoll.cpp:		if ( tickCount > gpGlobals->tickcount )
game/client/ragdoll.cpp:			if ( list[i].tickCount != gpGlobals->tickcount )
game/client/ragdoll.cpp:		list[index].tickCount = gpGlobals->tickcount;
game/client/proxypupil.cpp:		float flMaxChange = m_flPupilCloseRate.GetFloat() * gpGlobals->frametime;
game/client/proxypupil.cpp:		float flMaxChange = m_flPupilOpenRate.GetFloat() * gpGlobals->frametime;
game/client/timematerialproxy.cpp:	SetFloatResult( gpGlobals->curtime );
game/client/c_te_explosion.cpp:	m_flLifetime += gpGlobals->frametime;
game/client/c_te_explosion.cpp:			m_Sprites[i].m_flHorzSize += 16.0f * gpGlobals->frametime;
game/client/c_te_explosion.cpp:			m_Sprites[i].m_flVertSize += 16.0f * gpGlobals->frametime;
game/client/c_te_explosion.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/view.cpp:	input->ExtraMouseSample( gpGlobals->absoluteframetime, true );
game/client/view.cpp:	float speed = gpGlobals->absoluteframetime * cl_demoviewoverride.GetFloat() * 320;
game/client/view.cpp:	if ( m_PitchDrift.laststop == gpGlobals->curtime )
game/client/view.cpp:	m_PitchDrift.laststop	= gpGlobals->curtime;
game/client/view.cpp:			m_PitchDrift.driftmove += gpGlobals->frametime;
game/client/view.cpp:	move = gpGlobals->frametime * m_PitchDrift.pitchvel;
game/client/view.cpp:	m_PitchDrift.pitchvel += gpGlobals->frametime * v_centerspeed.GetFloat();
game/client/view.cpp:	    if ( ( sv_restrict_aspect_ratio_fov.GetInt() > 0 && engine->IsWindowedMode() && gpGlobals->maxClients > 1 ) ||
game/client/particles_simple.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/particles_simple.cpp:		GetWindspeedAtTime( gpGlobals->curtime, vecWind );
game/client/c_gib.cpp:	SetNextClientThink( gpGlobals->curtime + flLifetime );
game/client/c_gib.cpp:	SetNextClientThink( gpGlobals->curtime + 1.0f );
game/client/c_gib.cpp:	if ( m_flTouchDelta < gpGlobals->curtime )
game/client/c_gib.cpp:		m_flTouchDelta = gpGlobals->curtime + 0.1f;
game/client/c_func_dust.cpp:	GetWindspeedAtTime( gpGlobals->curtime, vecWind );
game/client/c_func_dust.cpp:						pParticle->m_vVelocity[i] += ( gpGlobals->frametime * DUST_ACCEL );
game/client/c_func_dust.cpp:						pParticle->m_vVelocity[i] -= ( gpGlobals->frametime * DUST_ACCEL );
game/client/c_func_dust.cpp:		float flDelta = MIN( gpGlobals->frametime, 0.1f );
game/client/physpropclientside.cpp:	if ( m_flTouchDelta < gpGlobals->curtime )
game/client/physpropclientside.cpp:		m_flTouchDelta = gpGlobals->curtime + 0.1f;
game/client/physpropclientside.cpp:	if ( m_fDeathTime <= gpGlobals->curtime )
game/client/physpropclientside.cpp:	float alpha = (m_fDeathTime - gpGlobals->curtime)/FADEOUT_TIME;
game/client/physpropclientside.cpp:	m_fDeathTime = gpGlobals->curtime + fDelay + FADEOUT_TIME;
game/client/physpropclientside.cpp:	SetNextClientThink( gpGlobals->curtime + fDelay );
game/client/physpropclientside.cpp:	SetNextClientThink( gpGlobals->curtime + (cl_phys_props_respawnrate.GetFloat() * RandomFloat(1.0,1.1)) );
game/client/physpropclientside.cpp:	SetNextClientThink( gpGlobals->curtime + (cl_phys_props_respawnrate.GetFloat() * RandomFloat(1.0,1.1)) );
game/client/c_effects.cpp:	Simulate( gpGlobals->frametime );
game/client/c_effects.cpp:			SinCos( gpGlobals->curtime * M_PI * (1+pParticle->m_Mass * 0.1f) + 
game/client/c_effects.cpp:	float timeSinceSpawn = gpGlobals->curtime - pParticle->m_SpawnTime;
game/client/c_effects.cpp:	pParticle->m_SpawnTime = gpGlobals->curtime;
game/client/c_effects.cpp:		float fastFreq = gpGlobals->curtime * 1.5;
game/client/c_effects.cpp:		float curTime = gpGlobals->frametime;
game/client/c_effects.cpp:	float flNextThink = m_EnvWindShared.WindThink( gpGlobals->curtime );
game/client/c_effects.cpp:	float tempDelta = gpGlobals->frametime;
game/client/c_effects.cpp:	DrawBeamQuadratic( GetRenderOrigin(), m_controlPosition, m_targetPosition, m_flWidth, color, gpGlobals->curtime*m_scrollRate );
game/client/c_effects.cpp:		GetWindspeedAtTime( gpGlobals->curtime, vecWindVelocity );
game/client/c_effects.cpp:	float flCurrentTime = gpGlobals->frametime;
game/client/c_smoke_trail.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_smoke_trail.cpp:	if ( ( m_StopEmitTime != 0 ) && ( m_StopEmitTime <= gpGlobals->curtime ) )
game/client/c_smoke_trail.cpp:	bool bEmitterActive = m_bEmit && ( ( m_StopEmitTime == 0 ) || ( m_StopEmitTime > gpGlobals->curtime ) );
game/client/c_smoke_trail.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_smoke_trail.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_smoke_trail.cpp:	if ( gpGlobals->frametime == 0.0f )
game/client/c_smoke_trail.cpp:	if ( ( m_flLifetime != 0 ) && ( m_flLifetime <= gpGlobals->curtime ) )
game/client/c_smoke_trail.cpp:	m_StartEmitTime = gpGlobals->curtime;
game/client/c_smoke_trail.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_smoke_trail.cpp:	if ( ( m_StopEmitTime != 0 ) && ( m_StopEmitTime <= gpGlobals->curtime ) )
game/client/c_smoke_trail.cpp:			alpha *= sqrt( (m_StopEmitTime - gpGlobals->curtime) /(m_StopEmitTime - m_StartEmitTime) );
game/client/c_smoke_trail.cpp:	bool bEmitterActive = m_bEmit && ( ( m_StopEmitTime == 0 ) || ( m_StopEmitTime > gpGlobals->curtime ) );
game/client/c_smoke_trail.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_smoke_trail.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/vgui_avatarimage.cpp:	if ( m_bLoadPending && steamapicontext->SteamFriends() && steamapicontext->SteamUtils() && gpGlobals->curtime >= m_fNextLoadTime )
game/client/vgui_avatarimage.cpp:			m_fNextLoadTime = gpGlobals->curtime + 1.0f;
game/client/c_lightglow.cpp:		SetNextClientThink( gpGlobals->curtime + RandomFloat(0,3.0) );
game/client/c_lightglow.cpp:	SetNextClientThink( gpGlobals->curtime + RandomFloat(1.0,3.0) );
game/client/replay/replaycamera.h:	float		m_flOldTime;	// Time of last CalcView() (uses gpGlobals->realtime)
game/client/replay/replay_ragdoll.cpp:	float flInterpAmount = gpGlobals->interpolation_amount;
game/client/replay/replay_ragdoll.cpp:			float flInterpAmount = gpGlobals->interpolation_amount;		Assert( flInterpAmount >= 0.0f && flInterpAmount <= 1.0f );
game/client/replay/replaycamera.cpp:		m_flOldTime = gpGlobals->realtime;
game/client/replay/replaycamera.cpp:	const float flDelta = gpGlobals->realtime - m_flOldTime;
game/client/replay/replaycamera.cpp:	m_flOldTime = gpGlobals->realtime;
game/client/replay/replaycamera.cpp:	if ( m_iTarget1 > 0 && m_iTarget1 <= gpGlobals->maxClients )
game/client/replay/replaycamera.cpp:			index = gpGlobals->maxClients;
game/client/replay/replaycamera.cpp:		else if ( index > gpGlobals->maxClients )
game/client/replay/replaycamera.cpp:	for ( int index = 1; index <= gpGlobals->maxClients; ++index )
game/client/replay/replaycamera.cpp:	m_flLastAngleUpdateTime = gpGlobals->realtime;
game/client/replay/replaycamera.cpp:		float deltaTime = gpGlobals->realtime - m_flLastAngleUpdateTime;
game/client/replay/replaycamera.cpp:	m_flLastAngleUpdateTime = gpGlobals->realtime;
game/client/replay/vgui/replayreminderpanel.cpp:	m_flShowTime = gpGlobals->curtime;
game/client/replay/vgui/replayreminderpanel.cpp:		if ( gpGlobals->curtime >= m_flShowTime + flShowLength )
game/client/replay/vgui/replaymessagepanel.cpp:	m_flShowStartTime = gpGlobals->curtime;
game/client/replay/vgui/replaymessagepanel.cpp:	if ( gpGlobals->curtime >= flEndTime )
game/client/replay/vgui/replaymessagepanel.cpp:	if ( gpGlobals->curtime >= flEndTime - flFadeDuration )
game/client/replay/vgui/replaymessagepanel.cpp:		flAlpha = LerpScale( gpGlobals->curtime, flEndTime - flFadeDuration, flEndTime, 1.0f, 0.0f );
game/client/replay/vgui/replaymessagepanel.cpp:	else if ( gpGlobals->curtime <= m_flShowStartTime + flFadeDuration )
game/client/replay/vgui/replaymessagepanel.cpp:		flAlpha = LerpScale( gpGlobals->curtime, m_flShowStartTime, m_flShowStartTime + flFadeDuration, 0.0f, 1.0f );
game/client/replay/vgui/replaybrowserlistitempanel.cpp:		m_flHoverStartTime = gpGlobals->realtime;
game/client/replay/vgui/replaybrowserlistitempanel.cpp:	const float flCurTime = gpGlobals->realtime;
game/client/replay/vgui/replaybrowserlistitempanel.cpp:		int nNumPeriods = fmod( gpGlobals->realtime * 2.0f, 4.0f );	// Max of 3 dots
game/client/replay/vgui/replayrenderoverlay.cpp:					m_flStartTime = gpGlobals->realtime;
game/client/replay/vgui/replayrenderoverlay.cpp:					flTimePassed = gpGlobals->realtime - m_flStartTime;
game/client/replay/vgui/replaybrowsermovieplayerpanel.cpp:	m_flLastTime = gpGlobals->realtime;
game/client/replay/vgui/replaybrowsermovieplayerpanel.cpp:		float flElapsed = gpGlobals->realtime - m_flLastTime;
game/client/replay/vgui/replaybrowsermovieplayerpanel.cpp:		m_flLastTime = gpGlobals->realtime;
game/client/replay/vgui/replayperformanceeditor.h:	float				m_flLastTime;	// Can't use gpGlobals->frametime when playback is paused
game/client/replay/vgui/replaybrowsermainpanel.cpp:		m_flTimeOpened = gpGlobals->realtime;
game/client/replay/vgui/replaybrowserpreviewpanel.cpp:	m_flCreateTime = gpGlobals->realtime;
game/client/replay/vgui/replaybrowserpreviewpanel.cpp:	if ( gpGlobals->realtime >= m_flCreateTime + 0.5f )
game/client/replay/vgui/replayperformanceeditor.cpp:		m_flBornTime( gpGlobals->realtime ),
game/client/replay/vgui/replayperformanceeditor.cpp:		if ( gpGlobals->realtime >= flEndTime )
game/client/replay/vgui/replayperformanceeditor.cpp:		if ( gpGlobals->realtime >= flEndTime - flFadeDuration )
game/client/replay/vgui/replayperformanceeditor.cpp:			flAlpha = LerpScale( gpGlobals->realtime, flEndTime - flFadeDuration, flEndTime, 1.0f, 0.0f );
game/client/replay/vgui/replayperformanceeditor.cpp:		else if ( gpGlobals->realtime <= m_flBornTime + flFadeDuration )
game/client/replay/vgui/replayperformanceeditor.cpp:			flAlpha = LerpScale( gpGlobals->realtime, m_flBornTime, m_flBornTime + flFadeDuration, 0.0f, 1.0f );
game/client/replay/vgui/replayperformanceeditor.cpp:	return gpGlobals->curtime - TICKS_TO_TIME( pPlayingReplay->m_nSpawnTick );
game/client/replay/vgui/replayperformanceeditor.cpp:		m_flPressTime = gpGlobals->realtime;
game/client/replay/vgui/replayperformanceeditor.cpp:			const float flElapsed = clamp( gpGlobals->realtime - m_flPressTime, 0.0f, MAX_FF_RAMP_TIME );
game/client/replay/vgui/replayperformanceeditor.cpp:		const float flTime = gpGlobals->realtime;
game/client/replay/vgui/replayperformanceeditor.cpp:		m_flPlayPauseTime = gpGlobals->realtime;
game/client/replay/vgui/replayperformanceeditor.cpp:	float flElapsed = gpGlobals->realtime - m_flLastTime;
game/client/replay/vgui/replayperformanceeditor.cpp:	m_flLastTime = gpGlobals->realtime;
game/client/replay/vgui/replayperformanceeditor.cpp:	m_flLastTimeSpaceBarPressed = gpGlobals->realtime;
game/client/replay/vgui/replayperformanceeditor.cpp:	if ( gpGlobals->realtime - m_flLastTimeSpaceBarPressed > 60.0f )
game/client/prediction.cpp:	//	gpGlobals->framecount,
game/client/prediction.cpp:	//	gpGlobals->tickcount,
game/client/prediction.cpp:	gpGlobals->curtime		= player->m_nTickBase * TICK_INTERVAL;
game/client/prediction.cpp:	gpGlobals->frametime	= m_bEnginePaused ? 0 : TICK_INTERVAL;
game/client/prediction.cpp:	if ( gpGlobals->frametime > 0 )
game/client/prediction.cpp:		gpGlobals->curtime		= curtime;
game/client/prediction.cpp:		gpGlobals->frametime	= m_bEnginePaused ? 0 : TICK_INTERVAL;
game/client/prediction.cpp:		//	gpGlobals->framecount,
game/client/prediction.cpp:		//	gpGlobals->tickcount,
game/client/prediction.cpp:			//	gpGlobals->framecount,
game/client/prediction.cpp:			//	gpGlobals->tickcount,
game/client/prediction.cpp:				float flPrev = gpGlobals->curtime;
game/client/prediction.cpp:				gpGlobals->curtime = pLocalPlayer->GetTimeBase() - TICK_INTERVAL;
game/client/prediction.cpp:				gpGlobals->curtime = flPrev;
game/client/prediction.cpp:	//	gpGlobals->framecount,
game/client/prediction.cpp:	//	gpGlobals->tickcount,
game/client/prediction.cpp:	//		gpGlobals->framecount, gpGlobals->tickcount,
game/client/prediction.cpp:		gpGlobals->curtime		= curtime;
game/client/prediction.cpp:		gpGlobals->frametime	= m_bEnginePaused ? 0 : TICK_INTERVAL;
game/client/prediction.cpp:				gpGlobals->framecount, gpGlobals->tickcount,
game/client/prediction.cpp:			gpGlobals->framecount, gpGlobals->tickcount,
game/client/prediction.cpp://		gpGlobals->tickcount, 
game/client/hud_controlpointicons.h:		float flElapsedTime = (gpGlobals->curtime - m_flStartCapAnimStart);
game/client/hud_controlpointicons.h:		m_flStartCapAnimStart = gpGlobals->curtime;
game/client/hud_controlpointicons.h:		if ( m_flFinishCapAnimStart && gpGlobals->curtime > m_flFinishCapAnimStart )
game/client/hud_controlpointicons.h:			float flElapsedTime = MAX( 0, (gpGlobals->curtime - m_flFinishCapAnimStart) );
game/client/hud_controlpointicons.h:		if ( m_bFakingCapture && m_flFakeCaptureTime < gpGlobals->curtime )
game/client/perfvisualbenchmark.cpp:	m_flTimer = gpGlobals->realtime + FPS_STABILIZE_TIME;
game/client/perfvisualbenchmark.cpp:	if ( m_flTimer > gpGlobals->realtime )
game/client/perfvisualbenchmark.cpp:		m_flTimer = gpGlobals->realtime + FPS_MEASURE_TIME;
game/client/perfvisualbenchmark.cpp:		m_flStartMeasureTime = gpGlobals->realtime;
game/client/perfvisualbenchmark.cpp:		m_nStartFrameCount = gpGlobals->framecount;
game/client/perfvisualbenchmark.cpp:	float flDenom = gpGlobals->realtime - m_flStartMeasureTime;
game/client/perfvisualbenchmark.cpp:	float flAveFPS = (gpGlobals->framecount - m_nStartFrameCount) / flDenom;
game/client/perfvisualbenchmark.cpp:	m_flTimer = gpGlobals->realtime + FPS_STABILIZE_TIME;
game/client/hud_voicestatus.cpp:	for ( int iPlayerIndex=1; iPlayerIndex<=gpGlobals->maxClients; iPlayerIndex++ )
game/client/hud_voicestatus.cpp:	float fTime = gpGlobals->frametime;
game/client/c_func_conveyor.cpp:	float sOffset = gpGlobals->curtime * cos( flAngle * ( M_PI / 180.0f ) ) * flRate;
game/client/c_func_conveyor.cpp:	float tOffset = gpGlobals->curtime * sin( flAngle * ( M_PI / 180.0f ) ) * flRate;
game/client/vgui_fpspanel.cpp:	if ( ( !cl_showfps.GetInt() || ( gpGlobals->absoluteframetime <= 0 ) ) &&
game/client/vgui_fpspanel.cpp:	float realFrameTime = gpGlobals->realtime - m_lastRealTime;
game/client/vgui_fpspanel.cpp:	m_lastRealTime = gpGlobals->realtime;
game/client/vgui_fpspanel.cpp:			( m_lastBatteryPercent == -1.0f || (gpGlobals->realtime - m_lastBatteryPercent) > 10.0f ) )
game/client/vgui_fpspanel.cpp:			m_lastBatteryPercent = gpGlobals->realtime;
game/client/vgui_fpspanel.cpp:				recent.time = gpGlobals->realtime;
game/client/vgui_fpspanel.cpp:				m_History[ i ].m_flLatchTime = gpGlobals->realtime;
game/client/vgui_fpspanel.cpp:				if ( gpGlobals->realtime > m_History[ i ].m_flLatchTime + 1.0f )
game/client/vgui_fpspanel.cpp:		 ( gpGlobals->realtime < latchedtime + 10.0f ) )
game/client/c_te_physicsprop.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/episodic/c_weapon_hopwire.cpp:	float tempDelta = gpGlobals->frametime;
game/client/episodic/c_weapon_hopwire.cpp:	float refract = m_FXCoreAlpha.Interp( gpGlobals->curtime );
game/client/episodic/c_weapon_hopwire.cpp:	float scale = m_FXCoreScale.Interp( gpGlobals->curtime );
game/client/episodic/c_weapon_hopwire.cpp:	float sin1 = sinf( gpGlobals->curtime * 10 );
game/client/episodic/c_weapon_hopwire.cpp:	float sin2 = sinf( gpGlobals->curtime );
game/client/episodic/c_weapon_hopwire.cpp:	float scale = m_FXCoreScale.Interp( gpGlobals->curtime );
game/client/episodic/c_prop_coreball.cpp:			float deltaTime = (float)( gpGlobals->curtime - flGoalTime[i]) / flLerpTime[i];
game/client/episodic/c_prop_scalable.cpp:	if ( m_nCalcFrame == gpGlobals->framecount )
game/client/episodic/c_prop_scalable.cpp:	m_nCalcFrame = gpGlobals->framecount;
game/client/episodic/c_prop_scalable.cpp:			float deltaTime = (float)( gpGlobals->curtime - flGoalTime[i]) / flLerpTime[i];
game/client/episodic/episodic_screenspaceeffects.cpp:		m_flFinishTime = gpGlobals->curtime + m_flDuration;
game/client/episodic/episodic_screenspaceeffects.cpp:	if ( m_flFinishTime < gpGlobals->curtime )
game/client/episodic/episodic_screenspaceeffects.cpp:	float flEffectPerc = ( m_flFinishTime - gpGlobals->curtime ) / m_flDuration;
game/client/episodic/episodic_screenspaceeffects.cpp:	float viewOffs = ( flEffectPerc * 32.0f ) * ( cos( gpGlobals->curtime * 40.0f ) * sin( gpGlobals->curtime * 17.0f ) );
game/client/episodic/episodic_screenspaceeffects.cpp:		m_flFinishTime = gpGlobals->curtime + m_flDuration;
game/client/episodic/episodic_screenspaceeffects.cpp:	float flEffectPerc = ( m_flDuration == 0.0f ) ? 0.0f : ( m_flFinishTime - gpGlobals->curtime ) / m_flDuration;
game/client/episodic/episodic_screenspaceeffects.cpp:	float vX = 2.0f * -fabs( cosf( gpGlobals->curtime ) * cosf( gpGlobals->curtime * 6.0 ) );
game/client/episodic/episodic_screenspaceeffects.cpp:	float vY = 2.0f * cosf( gpGlobals->curtime ) * cosf( gpGlobals->curtime * 5.0 );
game/client/episodic/episodic_screenspaceeffects.cpp:	float flScalePerc = 0.02f + ( 0.01f * cosf( gpGlobals->curtime * 2.0f ) * cosf( gpGlobals->curtime * 0.5f ) );
game/client/episodic/episodic_screenspaceeffects.cpp:		m_flFinishTime = gpGlobals->curtime + m_flDuration;
game/client/episodic/episodic_screenspaceeffects.cpp:	float flEffectPerc = ( m_flDuration == 0.0f ) ? 0.0f : ( m_flFinishTime - gpGlobals->curtime ) / m_flDuration;
game/client/episodic/episodic_screenspaceeffects.cpp:	float vX = 4.0f * cosf( gpGlobals->curtime ) * cosf( gpGlobals->curtime * 6.0 );
game/client/episodic/episodic_screenspaceeffects.cpp:	float vY = 2.0f * cosf( gpGlobals->curtime ) * cosf( gpGlobals->curtime * 5.0 );
game/client/episodic/episodic_screenspaceeffects.cpp:	float flBaseScale = 0.2f + 0.005f * sinf( gpGlobals->curtime * 4.0f );
game/client/episodic/episodic_screenspaceeffects.cpp:	float flScalePerc = flBaseScale + ( 0.01f * cosf( gpGlobals->curtime * 2.0f ) * cosf( gpGlobals->curtime * 0.5f ) );
game/client/episodic/c_npc_advisor.cpp:			el->die = gpGlobals->curtime + 2000.0f; // 1000 just means " a long time "
game/client/episodic/c_npc_advisor.cpp:		el->die = gpGlobals->curtime;
game/client/episodic/c_vort_charge_token.cpp:	if ( gpGlobals->frametime <= 0.0f )
game/client/episodic/c_vort_charge_token.cpp:			float lerpQuant = gpGlobals->frametime / VORT_BLACK_FADE_TIME;
game/client/episodic/c_vort_charge_token.cpp:			float lerpQuant = gpGlobals->frametime / VORT_BLACK_FADE_TIME;
game/client/episodic/c_vort_charge_token.cpp:	pVortToken->m_flFadeOutStart = gpGlobals->curtime;
game/client/episodic/c_vort_charge_token.cpp:	pVortToken->m_flFadeOutTime = ( pData->m_Value.m_Float - gpGlobals->curtime );
game/client/episodic/c_vort_charge_token.cpp:		m_pDLight->die = gpGlobals->curtime;
game/client/episodic/c_vort_charge_token.cpp:	pVortToken->m_flFadeOutStart = gpGlobals->curtime;
game/client/episodic/c_vort_charge_token.cpp:	pVortToken->m_flFadeOutTime = ( pData->m_Value.m_Float - gpGlobals->curtime );
game/client/episodic/c_vort_charge_token.cpp:		m_pDLight->die = gpGlobals->curtime;
game/client/episodic/c_vort_charge_token.cpp:		if (gpGlobals->curtime < pVort->m_flBlueEndFadeTime)
game/client/episodic/c_vort_charge_token.cpp:			float fadeRatio = (pVort->m_flBlueEndFadeTime - gpGlobals->curtime) / VORTIGAUNT_BLUE_FADE_TIME;
game/client/episodic/c_vort_charge_token.cpp:	float flBlendValue = sinf( gpGlobals->curtime * 4.0f ) * 0.75f + 0.25f;
game/client/episodic/flesh_internal_material_proxy.cpp:		float dt = ( gpGlobals->curtime - m_flScaleStartTime );
game/client/episodic/flesh_internal_material_proxy.cpp:		pTarget->m_flScaleStartTime = gpGlobals->curtime;
game/client/episodic/flesh_internal_material_proxy.cpp:		// vSubsurfaceTintColor[0] = vSubsurfaceTintColor[1] = vSubsurfaceTintColor[2] = sinf( gpGlobals->curtime * 3.0f ) + 1.0f;  // * 0.5f + 0.5f;
game/client/cdll_client_int.cpp:	float frametime = gpGlobals->frametime;
game/client/cdll_client_int.cpp:	hudlcd->SetGlobalStat( "(time_int)", VarArgs( "%d", (int)gpGlobals->curtime ) );
game/client/cdll_client_int.cpp:	hudlcd->SetGlobalStat( "(time_float)", VarArgs( "%.2f", gpGlobals->curtime ) );
game/client/cdll_client_int.cpp:	if ( gpGlobals->maxClients > 1 )
game/client/cdll_client_int.cpp:		ParticleMgr()->Simulate( gpGlobals->frametime );
game/client/fx_sparks.cpp:	m_startTime = gpGlobals->curtime;
game/client/fx_sparks.cpp:	if ( gpGlobals->curtime > m_flDeathTime )
game/client/fx_sparks.cpp:			if ( (gpGlobals->curtime - m_startTime) <= 0.1f )
game/client/fx_sparks.cpp:	CSmartPtr<CSimpleGlowEmitter> pSimple = CSimpleGlowEmitter::Create( "FX_ElectricSpark 3", pos, gpGlobals->curtime + 0.2 );
game/client/fx_sparks.cpp:	dl->die		= gpGlobals->curtime + 0.001;
game/client/fx_sparks.cpp:	dl->die		= gpGlobals->curtime + 0.1;
game/client/particles_new.cpp:		state.m_flTime = gpGlobals->curtime;
game/client/particles_new.cpp:		state.m_nParticleSystemId = gpGlobals->curtime;
game/client/particles_new.cpp:		state.m_flTime = gpGlobals->curtime;
game/client/particles_new.cpp:		state.m_flTime = gpGlobals->curtime;
game/client/particles_new.cpp:		state.m_flTime = gpGlobals->curtime;
game/client/particles_new.cpp:		state.m_flTime = gpGlobals->curtime;
game/client/particles_new.cpp:		state.m_flTime = gpGlobals->curtime;
game/client/c_ai_basehumanoid.cpp:	auto_ik.Init( hdr, GetRenderAngles(), GetRenderOrigin(), gpGlobals->curtime );
game/client/hud_base_account.cpp:	if ( m_flLastAnimationEnd > gpGlobals->curtime && m_pszLastAnimationName )
game/client/hud_base_account.cpp:		m_flLastAnimationEnd = gpGlobals->curtime + GetAnimationController()->GetAnimationSequenceLength( m_pszLastAnimationName );
game/client/c_te_dynamiclight.cpp:	dl->die		= gpGlobals->curtime + time;
game/client/c_te_dynamiclight.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/interpolatedvar.h:		Msg( "%s LatchChanged at %f changetime %f:  %s\n", GetDebugName(), gpGlobals->curtime, changetime, pDiffString );
game/client/interpolatedvar.h:	RemoveOldEntries( gpGlobals->curtime - interpolation_amount - 2.0f );
game/client/interpolatedvar.h:	// any data we're going to need.  Unless gpGlobals->curtime is different when samples are added vs. when
game/client/interpolatedvar.h:	RemoveEntriesPreviousTo( gpGlobals->curtime - interpolation_amount - EXTRA_INTERPOLATION_HISTORY_STORED );
game/client/interpolatedvar.h:		AddToHead( gpGlobals->curtime, m_pValue, false );
game/client/interpolatedvar.h:		AddToHead( gpGlobals->curtime, m_pValue, false );
game/client/interpolatedvar.h:		AddToHead( gpGlobals->curtime, m_pValue, false );
game/client/message.cpp:		float localTime = gpGlobals->curtime - m_gameTitleTime;
game/client/message.cpp:		if ( m_gameTitleTime > gpGlobals->curtime )
game/client/message.cpp:			m_gameTitleTime = gpGlobals->curtime;
game/client/message.cpp:			if ( m_startTime[i] > gpGlobals->curtime )
game/client/message.cpp:				m_startTime[i] = gpGlobals->curtime + m_parms.time - m_startTime[i] + 0.2;	// Server takes 0.2 seconds to spawn, adjust for this
game/client/message.cpp:			if ( gpGlobals->curtime <= endTime )
game/client/message.cpp:				float messageTime = gpGlobals->curtime - m_startTime[i];
game/client/message.cpp:	m_parms.time = gpGlobals->curtime;
game/client/message.cpp:	float time = gpGlobals->curtime;
game/client/message.cpp:		m_gameTitleTime = gpGlobals->curtime;
game/client/message.cpp:		Msg( "%i gametitle fade\n", gpGlobals->framecount );
game/client/hud_controlpointpanel.cpp:	if ( m_bFakingCapture && gpGlobals->curtime > m_flFakeCaptureTime )
game/client/hud_controlpointpanel.cpp:					float flProgress = RemapVal( m_flFakeCaptureTime - gpGlobals->curtime, 0, 5.0, 0, 1 );
game/client/hud_controlpointpanel.cpp:			m_flFakeCaptureTime = gpGlobals->curtime + 5.0;
game/client/hud_controlpointpanel.cpp:			m_flFakeCaptureTime = gpGlobals->curtime + 5.0;
game/client/c_baseviewmodel.cpp:		float curtime = pPlayer ? pPlayer->GetFinalPredictedTime() : gpGlobals->curtime;
game/client/c_baseviewmodel.cpp:			elapsed_time += ( gpGlobals->interpolation_amount * TICK_INTERVAL );
game/client/c_baseviewmodel.cpp:		float curtime = (pPlayer && IsIntermediateDataAllocated()) ? pPlayer->GetFinalPredictedTime() : gpGlobals->curtime;
game/client/c_spotlight_end.cpp:	m_pDynamicLight->die		= gpGlobals->curtime + 0.05f;
game/client/c_spotlight_end.cpp:	m_pModelLight->die = gpGlobals->curtime + 0.05;
game/client/fx.cpp:		m_flLifetime += gpGlobals->frametime;
game/client/fx.cpp:				m_Sprites[i].m_flHorzSize += 1.0f * gpGlobals->frametime;
game/client/fx.cpp:				m_Sprites[i].m_flVertSize += 1.0f * gpGlobals->frametime;
game/client/fx.cpp:	msg->SetFloat( "time", gpGlobals->curtime );
game/client/fx.cpp:		m_flDeathTime = gpGlobals->curtime + flTime;
game/client/fx.cpp:		m_flLastParticleSpawnTime = gpGlobals->curtime + m_flSpawnRate;
game/client/fx.cpp:			if ( m_flDeathTime > gpGlobals->curtime )
game/client/fx.cpp:				if ( m_flLastParticleSpawnTime <= gpGlobals->curtime )
game/client/fx.cpp:		el->die		= gpGlobals->curtime + 0.1f;
game/client/fx_explosion.cpp:	dl->die		= gpGlobals->curtime + 0.1f;
game/client/c_team_objectiveresource.cpp:	m_flCapLastThinkTime[index] = gpGlobals->curtime;
game/client/c_team_objectiveresource.cpp:	SetNextClientThink( gpGlobals->curtime + RESOURCE_THINK_TIME );
game/client/c_team_objectiveresource.cpp:					float flReduction = gpGlobals->curtime - m_flCapLastThinkTime[i];
game/client/c_team_objectiveresource.cpp:							flReduction += ((gpGlobals->curtime - m_flCapLastThinkTime[i]) / (float)(iPlayer+1));
game/client/c_team_objectiveresource.cpp:									if ( gpGlobals->curtime > ( m_flLastCapWarningTime[i] + 5 ) )
game/client/c_team_objectiveresource.cpp:										m_flLastCapWarningTime[i] = gpGlobals->curtime;
game/client/c_team_objectiveresource.cpp:						float flDecrease = (flCapLength / flDecreaseScale) * (gpGlobals->curtime - m_flCapLastThinkTime[i]);
game/client/c_team_objectiveresource.cpp:			m_flCapLastThinkTime[i] = gpGlobals->curtime;
game/client/c_team_objectiveresource.cpp:	SetNextClientThink( gpGlobals->curtime + RESOURCE_THINK_TIME );
game/client/c_hairball.cpp:	m_flCurSpinTime += gpGlobals->frametime;
game/client/c_hairball.cpp:		m_flSitStillTime -= gpGlobals->frametime;
game/client/c_hairball.cpp:		Vector vEnd = GetAbsOrigin() + m_vMoveDir * gpGlobals->frametime;
game/client/c_hairball.cpp:			SetLocalOrigin( GetLocalOrigin() + m_vMoveDir * gpGlobals->frametime );
game/client/c_hairball.cpp:	m_Physics.Simulate( m_Nodes.Base(), m_Nodes.Count(), &m_Delegate, gpGlobals->frametime, 0.98 );
game/client/hud_baseachievement_tracker.cpp:	m_flNextThink = gpGlobals->curtime + 0.05f;
game/client/hud_baseachievement_tracker.cpp:	if ( m_flNextThink < gpGlobals->curtime )
game/client/hud_baseachievement_tracker.cpp:		m_flNextThink = gpGlobals->curtime + 0.5f;
game/client/hud_baseachievement_tracker.cpp:	if ( m_iAccumulatedIncrement > 0 && gpGlobals->curtime > m_flShowIncrementsTime )
game/client/hud_baseachievement_tracker.cpp:	if ( gpGlobals->curtime < m_flGlowTime )
game/client/hud_baseachievement_tracker.cpp:		m_flGlow = MIN( 1.0f, m_flGlow + gpGlobals->frametime * 5.0f );
game/client/hud_baseachievement_tracker.cpp:		m_flGlow = MAX( 0.0f, m_flGlow - gpGlobals->frametime * 5.0f );
game/client/hud_baseachievement_tracker.cpp:		if ( m_flShowIncrementsTime < gpGlobals->curtime )
game/client/hud_baseachievement_tracker.cpp:			m_flShowIncrementsTime = gpGlobals->curtime + 2.0f;
game/client/hud_baseachievement_tracker.cpp:		m_flGlowTime = gpGlobals->curtime + hud_achievement_glowtime.GetFloat();
game/client/hud_baseachievement_tracker.cpp:	m_flGlowTime = gpGlobals->curtime + hud_achievement_glowtime.GetFloat();
game/client/hud_baseachievement_tracker.cpp:	m_fStartTime = gpGlobals->curtime;
game/client/hud_baseachievement_tracker.cpp:	if ( gpGlobals->curtime > m_fStartTime + 1.0f )
game/client/c_env_screenoverlay.cpp:		 m_flCurrentOverlayTime = gpGlobals->curtime + m_flOverlayTimes[m_iCurrentOverlay];
game/client/c_env_screenoverlay.cpp:	if ( m_flCurrentOverlayTime != -1 && m_flCurrentOverlayTime < gpGlobals->curtime )
game/client/detailobjectsystem.cpp:			vecSway += dx * sin(gpGlobals->curtime+m_Origin.x) * flSwayAmplitude;
game/client/detailobjectsystem.cpp:		vecSway += UTIL_YawToVector( m_pAdvInfo->m_flSwayYaw ) * sin(gpGlobals->curtime+m_Origin.x) * flSwayAmplitude;
game/client/detailobjectsystem.cpp:			vecSwayYaw * sin(gpGlobals->curtime+m_Origin.x+iBranch) * flSwayAmplitude;
game/client/in_main.cpp:	cmd->tick_count = gpGlobals->tickcount;
game/client/c_smokestack.cpp:	SetNextClientThink( gpGlobals->curtime + 5 );
game/client/hud_redraw.cpp:	if ( ( m_flScreenShotTime > 0 ) && ( m_flScreenShotTime < gpGlobals->curtime ) )
game/client/view_beams.cpp:			pbeam->die = gpGlobals->curtime - 0.1;  
game/client/view_beams.cpp:				pHead->die = gpGlobals->curtime - 0.1;
game/client/view_beams.cpp:	pBeam->freq				= gpGlobals->curtime * beamInfo.m_flSpeed;
game/client/view_beams.cpp:	pBeam->die				= gpGlobals->curtime + beamInfo.m_flLife;
game/client/view_beams.cpp:	pBeam->die = gpGlobals->curtime;
game/client/view_beams.cpp:		if (kill && kill->die < gpGlobals->curtime)
game/client/view_beams.cpp:			if (kill && kill->die < gpGlobals->curtime)
game/client/view_beams.cpp:		pbeam->die = gpGlobals->curtime;
game/client/view_beams.cpp:		beamRandom.SetSeed( (int)gpGlobals->curtime );
game/client/view_beams.cpp:				float remaining = pbeam->die - gpGlobals->curtime;
game/client/view_beams.cpp:	pbeam->t = pbeam->freq + (pbeam->die - gpGlobals->curtime);
game/client/view_beams.cpp:	float frametime = gpGlobals->frametime;
game/client/view_beams.cpp:			pBeam->die <= gpGlobals->curtime )
game/client/view_beams.cpp:		pnew->die = gpGlobals->curtime + pbeam->amplitude;
game/client/view_beams.cpp:		pbeam->die = gpGlobals->curtime + pbeam->amplitude;
game/client/view_beams.cpp:		pbeam->die = gpGlobals->curtime;
game/client/view_beams.cpp:	int frame = ( ( int )( pbeam->frame + gpGlobals->curtime * pbeam->frameRate) % pbeam->frameCount );
game/client/view_beams.cpp:		DrawBeamFollow( sprite, pbeam, frame, rendermode, gpGlobals->frametime, color, pbeam->m_flHDRColorScale );
game/client/view_beams.cpp:			pbeam->die = gpGlobals->curtime;
game/client/view_beams.cpp:	UpdateBeam( &beam, gpGlobals->frametime );
game/client/c_ai_basenpc.cpp:							pPlayer->m_flSpeedModTime = gpGlobals->curtime + cl_npc_speedmod_intime.GetFloat();
game/client/c_ai_basenpc.cpp:					pPlayer->m_flSpeedModTime = gpGlobals->curtime + cl_npc_speedmod_intime.GetFloat();
game/client/c_ai_basenpc.cpp:	if ( pPlayer && m_flTimePingEffect > gpGlobals->curtime )
game/client/c_ai_basenpc.cpp:		float fPingEffectTime = m_flTimePingEffect - gpGlobals->curtime;
game/client/c_ai_basenpc.cpp:	if ( ( ShouldModifyPlayerSpeed() == true ) || ( m_flTimePingEffect > gpGlobals->curtime ) )
game/client/c_ai_basenpc.cpp:	ForceSetupBonesAtTime( pDeltaBones0, gpGlobals->curtime - boneDt );
game/client/c_ai_basenpc.cpp:	GetRagdollCurSequenceWithDeathPose( this, pDeltaBones1, gpGlobals->curtime, m_iDeathPose, m_iDeathFrame );
game/client/c_ai_basenpc.cpp:	if ( ragdollCreateTime != gpGlobals->curtime )
game/client/c_ai_basenpc.cpp:		SetupBones( pCurrentBones, MAXSTUDIOBONES, BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/client/history_resource.cpp:		freeslot->DisplayTime = gpGlobals->curtime + (hud_drawhistory_time.GetFloat() / 2.0f);
game/client/history_resource.cpp:		freeslot->DisplayTime = gpGlobals->curtime + hud_drawhistory_time.GetFloat();
game/client/history_resource.cpp:			m_PickupHistory[i].DisplayTime = gpGlobals->curtime + (hud_drawhistory_time.GetFloat() / 2.0f);
game/client/history_resource.cpp:			m_PickupHistory[i].DisplayTime = MIN( m_PickupHistory[i].DisplayTime, gpGlobals->curtime + hud_drawhistory_time.GetFloat() );
game/client/history_resource.cpp:			if ( m_PickupHistory[i].DisplayTime <= gpGlobals->curtime )
game/client/history_resource.cpp:			float elapsed = m_PickupHistory[i].DisplayTime - gpGlobals->curtime;
game/client/c_te_sprite.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_te_glassshatter.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_func_areaportalwindow.cpp:	m_nFXComputeFrame = gpGlobals->framecount;
game/client/c_te_breakmodel.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/particlesphererenderer.cpp:	m_iLastTickStartRenderCalled = gpGlobals->tickcount;
game/client/vgui_messagechars.cpp:		msg->fTTL = gpGlobals->curtime + flTime;
game/client/vgui_messagechars.cpp:		if ( pCurrent->fTTL <= gpGlobals->curtime )
game/client/vgui_messagechars.cpp:			pCurrent->fTTL = gpGlobals->curtime - 1000;
game/client/c_stickybolt.cpp:	if ( gpGlobals->maxClients > 1 )
game/client/c_plasma.cpp:			pPlasmaSmoke->m_flScaleTimeStart	= gpGlobals->curtime-1.0f;
game/client/c_plasma.cpp:			pPlasmaSmoke->m_flScaleTimeStart	= gpGlobals->curtime;
game/client/c_plasma.cpp:			pPlasmaSmoke->m_flScaleTimeEnd	= gpGlobals->curtime + time;
game/client/c_plasma.cpp:	result = sin( gpGlobals->curtime * 10000.0f );
game/client/c_plasma.cpp:	result += 0.5f * sin( gpGlobals->curtime * 2000.0f );
game/client/c_plasma.cpp:	result -= 0.5f * cos( gpGlobals->curtime * 8000.0f );
game/client/c_plasma.cpp:	float	frametime	= gpGlobals->frametime;
game/client/c_plasma.cpp:	float	time = gpGlobals->curtime;
game/client/c_plasma.cpp:		float tempDelta = gpGlobals->frametime;
game/client/view_scene.h:	if ( IsPC() || bForceUpdate || g_bAllowMultipleRefractUpdatesPerScenePerFrame || (gpGlobals->framecount != g_viewscene_refractUpdateFrame) )
game/client/view_scene.h:		g_viewscene_refractUpdateFrame = gpGlobals->framecount;
game/client/touch.cpp:	if ( FStrEq( gpGlobals->mapname.ToCStr(), "sde_a06_industrial_a" ) && pPlayer->IsInAVehicle() )
game/client/touch.cpp:	if( m_flHideTouch < gpGlobals->curtime )
game/client/touch.cpp:		m_flHideTouch = gpGlobals->curtime + 0.002f;
game/client/clientmode_shared.cpp:			gHUD.SetScreenShotTime( gpGlobals->curtime + 1.0 ); // take a screenshot in 1 second
game/client/clientmode_shared.cpp:	if ( gpGlobals->maxClients == 1 )
game/client/clientmode_shared.cpp:					pPlayer->SetNextAchievementAnnounceTime( gpGlobals->curtime + ACHIEVEMENT_ANNOUNCEMENT_MIN_TIME );
game/client/clientmode_shared.cpp:		m_flReplayStartRecordTime = gpGlobals->curtime;
game/client/clientmode_shared.cpp:		m_flReplayStopRecordTime = gpGlobals->curtime;
game/client/c_baseplayer.cpp:			m_flFreezeFrameStartTime = gpGlobals->curtime;
game/client/c_baseplayer.cpp:	float curTime = gpGlobals->frametime;
game/client/c_baseplayer.cpp:	m_flObserverChaseDistance += gpGlobals->frametime*48.0f;
game/client/c_baseplayer.cpp:	float flCurTime = (gpGlobals->curtime - m_flFreezeFrameStartTime);
game/client/c_baseplayer.cpp:	float interpolation = ( gpGlobals->curtime - m_flDeathTime ) / GetDeathCamInterpolationTime();
game/client/c_baseplayer.cpp:	m_flObserverChaseDistance += gpGlobals->frametime*48.0f;
game/client/c_baseplayer.cpp:	if (m_nSimulationTick == gpGlobals->tickcount)
game/client/c_baseplayer.cpp:	m_nSimulationTick = gpGlobals->tickcount;
game/client/c_baseplayer.cpp:			float deltaTime = (float)( gpGlobals->curtime - m_flFOVTime ) / m_Local.m_flFOVRate;
game/client/c_baseplayer.cpp:				deltaTime += ( gpGlobals->interpolation_amount * TICK_INTERVAL );
game/client/c_baseplayer.cpp:	if ( gpGlobals->maxClients == 1 )
game/client/c_baseplayer.cpp:	m_flPredictionErrorTime = gpGlobals->curtime;
game/client/c_baseplayer.cpp:	Interpolate( gpGlobals->curtime + curtimeOffset );
game/client/c_baseplayer.cpp:	SetupBones( pBonesOut, MAXSTUDIOBONES, BONE_USED_BY_ANYTHING, gpGlobals->curtime + curtimeOffset );
game/client/c_baseplayer.cpp:	if ( ragdollCreateTime != gpGlobals->curtime )
game/client/c_baseplayer.cpp:		ForceSetupBonesAtTimeFakeInterpolation( pCurrentBones, ragdollCreateTime - gpGlobals->curtime );
game/client/c_baseplayer.cpp:		SetupBones( pCurrentBones, MAXSTUDIOBONES, BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/client/c_baseplayer.cpp:	float errorAmount = ( gpGlobals->curtime - m_flPredictionErrorTime ) / cl_smoothtime.GetFloat();
game/client/c_baseplayer.cpp:		m_Local.m_PlayerFog.m_flTransitionTime = bSnap ? -1 : gpGlobals->curtime;
game/client/c_baseplayer.cpp:		float flTimeDelta = gpGlobals->curtime - m_Local.m_PlayerFog.m_flTransitionTime;
game/client/vgui_centerstringpanel.cpp:	m_flCentertimeOff = scr_centertime.GetFloat() + gpGlobals->curtime;
game/client/vgui_centerstringpanel.cpp:	m_flCentertimeOff = scr_centertime.GetFloat() + gpGlobals->curtime;
game/client/vgui_centerstringpanel.cpp:	if ( m_flCentertimeOff <= gpGlobals->curtime )
game/client/c_rope.cpp:		GetWindspeedAtTime(gpGlobals->curtime, vecWindVel);
game/client/c_rope.cpp:		RunRopeSimulation( gpGlobals->frametime );
game/client/c_rope.cpp:		m_flCurrentGustTimer += gpGlobals->frametime;
game/client/c_rope.cpp:		m_flTimeToNextGust -= gpGlobals->frametime;
game/client/c_baseanimating.cpp:	SetupBones( NULL, -1, BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/client/c_baseanimating.cpp:				m_flFrictionTime = gpGlobals->curtime + m_flFrictionModTime;
game/client/c_baseanimating.cpp:			float flDeltaTime = (m_flFrictionTime - gpGlobals->curtime);
game/client/c_baseanimating.cpp:				m_flFrictionTime = gpGlobals->curtime + m_flFrictionModTime;
game/client/c_baseanimating.cpp:			if ( m_flFrictionTime < gpGlobals->curtime )
game/client/c_baseanimating.cpp:				m_flFrictionTime = gpGlobals->curtime + m_flFrictionModTime;
game/client/c_baseanimating.cpp:			float flDeltaTime = (m_flFrictionTime - gpGlobals->curtime);
game/client/c_baseanimating.cpp:	iAlpha = MAX( iAlpha - ( iFadeSpeed * gpGlobals->frametime ), 0 );
game/client/c_baseanimating.cpp:		DevMsgRT( "%6.2f : ", gpGlobals->curtime );
game/client/c_baseanimating.cpp:				m_pJiggleBones->BuildJiggleTransformations( i, gpGlobals->realtime, jiggleInfo, goalMX, GetBoneForWrite( i ) );
game/client/c_baseanimating.cpp:			scale = 1.0 + (gpGlobals->curtime - m_flAnimTime) * 10.0;
game/client/c_baseanimating.cpp:	pRagdoll->SetupBones( NULL, -1, BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/client/c_baseanimating.cpp:	m_pRagdollInfo->m_flSaveTime = gpGlobals->curtime;
game/client/c_baseanimating.cpp:	m_pRagdollInfo->m_flSaveTime = gpGlobals->curtime;
game/client/c_baseanimating.cpp:		gpGlobals->curtime
game/client/c_baseanimating.cpp:		float dt = (gpGlobals->curtime - blend->m_flLayerAnimtime);
game/client/c_baseanimating.cpp:			DevMsgRT( "%8.4f : %30s : %5.3f : %4.2f  +\n", gpGlobals->curtime, boneSetup.GetStudioHdr()->pSeqdesc( blend->m_nSequence ).pszLabel(), flCycle, (float)blend->m_flWeight );
game/client/c_baseanimating.cpp:		boneSetup.AccumulatePose( pos, q, blend->m_nSequence, flCycle, blend->m_flWeight, gpGlobals->curtime, m_pIk );
game/client/c_baseanimating.cpp:	auto_ik.Init( hdr, GetRenderAngles(), GetRenderOrigin(), currentTime, gpGlobals->framecount, boneMask );
game/client/c_baseanimating.cpp:	if ( gpGlobals->frametime > 0 && pAtt->m_nLastFramecount > 0 && pAtt->m_nLastFramecount == gpGlobals->framecount - 1 )
game/client/c_baseanimating.cpp:		pAtt->m_vOriginVelocity = (vecOrigin - vecPreviousOrigin) / gpGlobals->frametime;
game/client/c_baseanimating.cpp:	pAtt->m_nLastFramecount = gpGlobals->framecount;
game/client/c_baseanimating.cpp:	return SetupBones( NULL, -1, BONE_USED_BY_ATTACHMENT, gpGlobals->curtime );
game/client/c_baseanimating.cpp:		if ( pcache->IsValid( gpGlobals->curtime, 0.0 ) )
game/client/c_baseanimating.cpp:	SetupBones( NULL, -1, boneMask, gpGlobals->curtime );
game/client/c_baseanimating.cpp:		pcache->UpdateBones( m_CachedBoneData.Base(), pStudioHdr->numbones(), gpGlobals->curtime );
game/client/c_baseanimating.cpp:		params.curtime = gpGlobals->curtime;
game/client/c_baseanimating.cpp:		pBaseAnimating->SetupBones( NULL, -1, -1, gpGlobals->curtime );
game/client/c_baseanimating.cpp:		if ( gpGlobals->realtime >= lastWarning + 1.0f )
game/client/c_baseanimating.cpp:			lastWarning = gpGlobals->realtime;
game/client/c_baseanimating.cpp:			Msg( "Contested bone setup in frame %d!\n", gpGlobals->framecount );
game/client/c_baseanimating.cpp:				m_pIk->Init( hdr, GetRenderAngles(), GetRenderOrigin(), currentTime, gpGlobals->framecount, bonesMaskNeedRecalc );
game/client/c_baseanimating.cpp:			//el->die = gpGlobals->curtime + 0.05f;
game/client/c_baseanimating.cpp:			dl->die = gpGlobals->curtime + 0.03f;
game/client/c_baseanimating.cpp:		Msg( "%i cycle %f\n", gpGlobals->tickcount, GetCycle() );
game/client/c_baseanimating.cpp:				gpGlobals->curtime);
game/client/c_baseanimating.cpp:			 gpGlobals->tickcount, 
game/client/c_baseanimating.cpp:			 gpGlobals->curtime );
game/client/c_baseanimating.cpp:					gpGlobals->tickcount,
game/client/c_baseanimating.cpp:					gpGlobals->curtime );
game/client/c_baseanimating.cpp:					gpGlobals->tickcount,
game/client/c_baseanimating.cpp:					gpGlobals->curtime );
game/client/c_baseanimating.cpp:	ForceSetupBonesAtTime( pDeltaBones0, gpGlobals->curtime - boneDt );
game/client/c_baseanimating.cpp:	ForceSetupBonesAtTime( pDeltaBones1, gpGlobals->curtime );
game/client/c_baseanimating.cpp:	if ( ragdollCreateTime != gpGlobals->curtime )
game/client/c_baseanimating.cpp:	if ( gpGlobals->frametime != 0.0f  )
game/client/c_baseanimating.cpp:	float flInterval = MIN( gpGlobals->curtime - m_flAnimTime, MAX_ANIMTIME_INTERVAL );
game/client/c_baseanimating.cpp:		//anim.prevanimtime = m_flAnimTime = gpGlobals->curtime;
game/client/c_baseanimating.cpp:	m_flAnimTime = gpGlobals->curtime;
game/client/c_baseanimating.cpp:		Msg("%s %6.3f : %6.3f (%.3f)\n", GetClassname(), gpGlobals->curtime, m_flAnimTime, flInterval );
game/client/c_baseanimating.cpp:		float flWeight = blend->GetFadeout( gpGlobals->curtime );
game/client/c_baseanimating.cpp:	float curtime = gpGlobals->curtime;
game/client/c_baseanimating.cpp:			gpGlobals->tickcount, gpGlobals->curtime, flInterval, flNewCycle, cyclerate, addcycle );
game/client/c_baseanimating.cpp:	// m_flAnimTime = gpGlobals->time;
game/client/c_baseanimating.cpp:		mvs->m_flModelScaleStartTime = gpGlobals->curtime;
game/client/c_baseanimating.cpp:	float frac = ( gpGlobals->curtime - mvs->m_flModelScaleStartTime ) / dt;
game/client/c_baseanimating.cpp:	if ( gpGlobals->curtime >= mvs->m_flModelScaleFinishTime )
game/client/c_baseanimating.cpp:	if (gpGlobals->frametime != 0.0f)
game/client/c_baseanimating.cpp:		SetupBones( pBones, hdr->numbones(), BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/client/c_baseanimating.cpp:		SetupBones( NULL, -1, BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/client/client_thinklist.cpp:								( pEntry->m_flNextClientThink <= gpGlobals->curtime );
game/client/client_thinklist.cpp:		PerformThinkFunction( ppThinkEntryList[i], gpGlobals->curtime );		
game/client/c_particle_smokegrenade.cpp:	float flLifetime = gpGlobals->curtime - m_flSpawnTime;
game/client/c_particle_smokegrenade.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/death.cpp:		if ( rgDeathNoticeList[i].flDisplayTime < gpGlobals->curtime )
game/client/death.cpp:		rgDeathNoticeList[i].flDisplayTime = MIN( rgDeathNoticeList[i].flDisplayTime, gpGlobals->curtime + DEATHNOTICE_DISPLAY_TIME );
game/client/death.cpp:	rgDeathNoticeList[i].flDisplayTime = gpGlobals->curtime + DEATHNOTICE_DISPLAY_TIME;
game/client/thermalmaterialproxy.cpp:	value = ( sin( 2.0f * M_PI * gpGlobals->curtime / period ) * 0.5f ) + 0.5f;
game/client/cdll_util.cpp:	return ( index >= 1 && index <= gpGlobals->maxClients ) ? true : false;
game/client/sixense/in_sixense.cpp:			m_fTeleportWaitToBlendTime = gpGlobals->curtime + sixense_teleport_wait_to_blend_time.GetFloat();
game/client/sixense/in_sixense.cpp:	if ( m_fTeleportWaitToBlendTime - gpGlobals->curtime <= 0.0f )
game/client/sixense/in_sixense.cpp:					fEndOneToOneRatchetDelayTime = gpGlobals->curtime;
game/client/sixense/in_sixense.cpp:					( ( gpGlobals->curtime - fEndOneToOneRatchetDelayTime ) > sixense_dist_one_to_one_end_ratchet_delay.GetFloat() ) )
game/client/c_te_projecteddecal.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_te_bloodstream.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_pixel_visibility.cpp:	frameIssued = gpGlobals->framecount;
game/client/c_pixel_visibility.cpp:	return (gpGlobals->framecount - frameIssued) > 1 ? false : true;
game/client/c_pixel_visibility.cpp:	return (gpGlobals->framecount - m_frameIssued) > 1 ? false : true;
game/client/c_pixel_visibility.cpp:				DevMsg( 1, "Pixels visible: %d (qh:%d) Pixels possible: %d (qh:%d) (frame:%d)\n", pixels, (int)(intp)m_queryHandle, pixelsPossible, (int)(intp)m_queryHandleCount, gpGlobals->framecount );
game/client/c_pixel_visibility.cpp:				float rate = gpGlobals->frametime * fadeTimeInv;
game/client/c_pixel_visibility.cpp:				DevMsg( 1, "Pixels visible: %d (qh:%d) (frame:%d)\n", pixels, (int)(intp)m_queryHandle, gpGlobals->framecount );
game/client/c_pixel_visibility.cpp:			if ( m_frameIssued == gpGlobals->framecount-1 )
game/client/c_pixel_visibility.cpp:				float rate = gpGlobals->frametime * fadeTimeInv;
game/client/c_pixel_visibility.cpp:			DevMsg( 1, "Draw Proxy: qh:%d org:<%d,%d,%d> (frame:%d)\n", (int)(intp)m_queryHandle, (int)m_origin[0], (int)m_origin[1], (int)m_origin[2], gpGlobals->framecount );
game/client/c_pixel_visibility.cpp:	Assert ( ( m_frameIssued != gpGlobals->framecount ) || UseVR() );
game/client/c_pixel_visibility.cpp:	m_frameIssued = gpGlobals->framecount;
game/client/flashlighteffect.cpp:				float flFlicker = cosf( gpGlobals->curtime * 6.0f ) * sinf( gpGlobals->curtime * 15.0f );
game/client/flashlighteffect.cpp:				float flNoise = cosf( gpGlobals->curtime * 7.0f ) * sinf( gpGlobals->curtime * 25.0f );
game/client/flashlighteffect.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/flashlighteffect.cpp:	m_pPointLight->die = gpGlobals->curtime + 0.2f;
game/client/flashlighteffect.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/flashlighteffect.cpp:		m_pPointLight->die = gpGlobals->curtime;
game/client/fx_blood.cpp:	if ( gpGlobals->maxClients > 1 )
game/client/particlesphererenderer.h:		Assert( m_iLastTickStartRenderCalled == gpGlobals->tickcount );
game/client/particlesphererenderer.h:		Assert( m_iLastTickStartRenderCalled == gpGlobals->tickcount );
game/client/game_controls/SpectatorGUI.cpp:	for ( iPlayerIndex = 1 ; iPlayerIndex <= gpGlobals->maxClients; iPlayerIndex++ )
game/client/game_controls/SpectatorGUI.cpp:	if ( playernum > 0 && playernum <= gpGlobals->maxClients && gr )
game/client/game_controls/basemodelpanel.cpp:			pEnt->m_flAnimTime = gpGlobals->curtime;
game/client/game_controls/basemodelpanel.cpp:			pTemp->m_flAnimTime = gpGlobals->curtime;
game/client/game_controls/basemodelpanel.cpp:		m_hModel->FrameAdvance( gpGlobals->frametime );
game/client/game_controls/baseviewport.cpp:	m_pAnimController->UpdateAnimations( gpGlobals->curtime );
game/client/game_controls/slideshowpanel.h:	float			m_flStartBlendTime;	// the gpGlobals->realtime when we started blending
game/client/game_controls/slideshowpanel.h:	float						m_flNextTransitionTime;	// gpGlobals->realtime of time when we should transition next
game/client/game_controls/MapOverview.cpp:	for ( int i = 1; i<= gpGlobals->maxClients; i++)
game/client/game_controls/MapOverview.cpp:		m_fNextUpdateTime = gpGlobals->curtime + 0.2f; // update 5 times a second
game/client/game_controls/MapOverview.cpp:	return m_fNextUpdateTime < gpGlobals->curtime;
game/client/game_controls/MapOverview.cpp:	m_fWorldTime = gpGlobals->curtime;
game/client/game_controls/MapOverview.cpp:		obj.endtime = gpGlobals->curtime + timeToLive;
game/client/game_controls/MapOverview.cpp:		if ( obj->endtime > 0 && obj->endtime < gpGlobals->curtime )
game/client/game_controls/slideshowpanel.cpp:	m_flStartBlendTime = gpGlobals->realtime;
game/client/game_controls/slideshowpanel.cpp:			float t = clamp( ( gpGlobals->realtime - m_flStartBlendTime ) / m_flBlendTime, 0.0f, 1.0f );
game/client/game_controls/slideshowpanel.cpp:	m_flNextTransitionTime = gpGlobals->realtime + m_flInterval;
game/client/game_controls/slideshowpanel.cpp:	if ( GetImageCount() > 1 && gpGlobals->realtime >= m_flNextTransitionTime )
game/client/game_controls/slideshowpanel.cpp:		m_flNextTransitionTime = gpGlobals->realtime + m_flInterval;
game/client/game_controls/ClientScoreBoardDialog.cpp:	return (m_fNextUpdateTime < gpGlobals->curtime);	
game/client/game_controls/ClientScoreBoardDialog.cpp:	m_fNextUpdateTime = gpGlobals->curtime + 1.0f; 
game/client/game_controls/ClientScoreBoardDialog.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/client/game_controls/basemodel_panel.cpp:	g_pParticleSystemMgr->SetLastSimulationTime( gpGlobals->curtime );
game/client/game_controls/basemodel_panel.cpp:			m_particleList[i]->m_pParticleSystem->Simulate( gpGlobals->frametime, false );
game/client/hud_basechat.cpp:	float curtime = gpGlobals->curtime;
game/client/hud_basechat.cpp:	m_flStartTime = gpGlobals->curtime;
game/client/hud_basechat.cpp:	if ( gpGlobals->curtime >= m_flExpireTime )
game/client/hud_basechat.cpp:	m_flHistoryFadeTime = gpGlobals->curtime + CHAT_HISTORY_FADE_TIME;
game/client/hud_basechat.cpp:	m_flHistoryFadeTime = gpGlobals->curtime + CHAT_HISTORY_FADE_TIME;
game/client/hud_basechat.cpp:	float frac = ( m_flHistoryFadeTime -  gpGlobals->curtime ) / CHAT_HISTORY_FADE_TIME;
game/client/achievement_notification_panel.cpp:	if ( ( m_flHideTime > 0 ) && ( m_flHideTime < gpGlobals->curtime ) )
game/client/achievement_notification_panel.cpp:	return ( ( m_flHideTime > 0 ) && ( m_flHideTime > gpGlobals->curtime ) && CHudElement::ShouldDraw() );
game/client/achievement_notification_panel.cpp:	m_flHideTime = gpGlobals->curtime + ACHIEVEMENT_NOTIFICATION_DURATION;
game/client/hl2/c_basehelicopter.cpp:		float dt = gpGlobals->curtime  - pHeli->StartupTime();
game/client/hl2/c_rotorwash.cpp:		SetNextClientThink( gpGlobals->curtime + ROTORWASH_THINK_INTERVAL );
game/client/hl2/c_rotorwash.cpp:	SetNextClientThink( gpGlobals->curtime + ROTORWASH_THINK_INTERVAL );
game/client/hl2/c_func_tankmortar.cpp:		m_flStarttime = gpGlobals->curtime;
game/client/hl2/c_func_tankmortar.cpp:	float val = RemapValClamped( gpGlobals->curtime, m_flStarttime, m_flStarttime + m_flLifespan, 0.0f, 1.0f );
game/client/hl2/c_func_tankmortar.cpp:	float flCur = gpGlobals->frametime;
game/client/hl2/c_func_tankmortar.cpp:	float flCur = gpGlobals->frametime;
game/client/hl2/c_func_tankmortar.cpp:	float val = RemapValClamped( gpGlobals->curtime, m_flStarttime, m_flStarttime + m_flLifespan, 0.0f, 1.0f );
game/client/hl2/c_func_tankmortar.cpp:	float val = RemapValClamped( gpGlobals->curtime, m_flStarttime + m_flLifespan, m_flStarttime + m_flLifespan + 1.0f, 1.0f, 0.0f );
game/client/hl2/c_func_tankmortar.cpp:	if ( gpGlobals->frametime <= 0.0f )
game/client/hl2/c_func_tankmortar.cpp:	if ( gpGlobals->curtime < ( m_flStarttime + m_flLifespan ) )
game/client/hl2/c_prop_combine_ball.cpp:	if ( gpGlobals->frametime == 0.0f )
game/client/hl2/c_prop_combine_ball.cpp:		float sinOffs = 1.0f * sin( gpGlobals->curtime * 25 );
game/client/hl2/c_te_concussiveexplosion.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/hl2/hud_autoaim.cpp:	m_alphaFixed = Approach( flFixedAlphaGoal, m_alphaFixed, (hud_alpha_speed.GetFloat() * gpGlobals->frametime) );
game/client/hl2/hud_autoaim.cpp:			m_vecPos += vecDir * min(flDistRemaining, (speed * gpGlobals->frametime) );
game/client/hl2/hud_autoaim.cpp:			float scaleMove = MIN( AUTOAIM_SCALE_SPEED * gpGlobals->frametime, scaleDelta );
game/client/hl2/hud_autoaim.cpp:				m_alpha += AUTOAIM_ALPHA_UP_SPEED * gpGlobals->frametime;
game/client/hl2/hud_autoaim.cpp:				m_alpha -= AUTOAIM_ALPHA_DOWN_SPEED * gpGlobals->frametime;
game/client/hl2/c_script_intro.cpp:	if ( m_flNextBlendTime > gpGlobals->curtime )
game/client/hl2/c_script_intro.cpp:		m_flFadeTimeStartedAt = gpGlobals->curtime;
game/client/hl2/c_script_intro.cpp:		flPerc = clamp( (gpGlobals->curtime - m_flBlendStartTime) / (m_flNextBlendTime - m_flBlendStartTime), 0, 1 );
game/client/hl2/c_script_intro.cpp:	if ( m_flNextBlendTime >= gpGlobals->curtime )
game/client/hl2/c_script_intro.cpp:		Msg("				 curtime %.2f    StartedAt %.2f    FinishAt: %.2f\n", gpGlobals->curtime, m_flBlendStartTime, m_flNextBlendTime );
game/client/hl2/c_script_intro.cpp:	if ( m_flNextFOVBlendTime >= gpGlobals->curtime )
game/client/hl2/c_script_intro.cpp:	float flNewAlpha = RemapValClamped( gpGlobals->curtime, m_flFadeTimeStartedAt, m_flFadeTimeStartedAt + m_flFadeDuration, m_flFadeAlphaStartedAt, m_flFadeAlpha );
game/client/hl2/c_script_intro.cpp:		Msg("INTRO FADING: curtime %.2f    StartedAt %.2f    Duration: %.2f\n", gpGlobals->curtime, m_flFadeTimeStartedAt, m_flFadeDuration );
game/client/hl2/c_script_intro.cpp:		Msg("           TimePassed %.2f    Alpha:    %.2f\n", RemapValClamped( gpGlobals->curtime, m_flFadeTimeStartedAt, m_flFadeTimeStartedAt + m_flFadeDuration, 0.0, 1.0 ), m_IntroData.m_flCurrentFadeColor[3] );
game/client/hl2/hud_zoom.cpp:		m_flZoomStartTime = gpGlobals->curtime;
game/client/hl2/hud_zoom.cpp:		m_flZoomStartTime = gpGlobals->curtime;
game/client/hl2/hud_zoom.cpp:	float deltaTime = ( gpGlobals->curtime - m_flZoomStartTime );
game/client/hl2/c_npc_combinegunship.cpp:	m_t += gpGlobals->frametime;
game/client/hl2/c_npc_combinegunship.cpp:		dl->die = gpGlobals->curtime + 0.001;
game/client/hl2/fx_antlion.cpp:		 m_LRU[ i ].Get()->SetNextClientThink( gpGlobals->curtime );
game/client/hl2/c_env_headcrabcanister.cpp:	m_Shared.GetPositionAtTime( gpGlobals->curtime, vecEndPosition, vecEndAngles );
game/client/hl2/c_vehicle_airboat.cpp:			m_flViewAngleDeltaTime += gpGlobals->frametime;
game/client/hl2/c_vehicle_airboat.cpp:	float flFrameTime = gpGlobals->frametime;
game/client/hl2/c_vehicle_airboat.cpp:	if ( gpGlobals->frametime <= 0.0f )
game/client/hl2/c_vehicle_airboat.cpp:	if ( m_flUpdateTime > gpGlobals->curtime )
game/client/hl2/c_vehicle_airboat.cpp:		pNewPoint->m_flDieTime	= gpGlobals->curtime + WAKE_LIFETIME;
game/client/hl2/c_vehicle_airboat.cpp:	m_flUpdateTime = gpGlobals->curtime + ( 0.5f / (float) MAX_WAKE_POINTS );
game/client/hl2/c_vehicle_airboat.cpp:	float tempDelta = gpGlobals->frametime;
game/client/hl2/c_vehicle_airboat.cpp:		scale = scaleRange + ( 8.0f * sin( gpGlobals->curtime * 5 * i ) );
game/client/hl2/c_vehicle_airboat.cpp:	currentPoint.m_flDieTime = gpGlobals->curtime + 0.5f;
game/client/hl2/c_vehicle_airboat.cpp:		float flLifePerc = RemapValClamped( ( pPoint->m_flDieTime - gpGlobals->curtime ), 0, WAKE_LIFETIME, 0.0f, 1.0f );
game/client/hl2/c_npc_manhack.cpp:			float dt = ( m_flEnginePitch1Time >= gpGlobals->curtime ) ? m_flEnginePitch1Time - gpGlobals->curtime : 0.0f;
game/client/hl2/c_npc_manhack.cpp:			dt = ( m_flEnginePitch2Time >= gpGlobals->curtime ) ? m_flEnginePitch2Time - gpGlobals->curtime : 0.0f;
game/client/hl2/c_corpse.cpp:		 m_nReferencePlayer > gpGlobals->maxClients )
game/client/hl2/c_weapon_crossbow.cpp:		if ( gpGlobals->frametime > 0.0f && !m_bUpdated)
game/client/hl2/c_weapon_physcannon.cpp:	if ( gpGlobals->frametime == 0 )
game/client/hl2/c_weapon_physcannon.cpp:	if( m_flTimeIgnoreForceView > gpGlobals->curtime )
game/client/hl2/c_weapon_physcannon.cpp:	float flTime = (m_flTimeForceView - gpGlobals->curtime);
game/client/hl2/c_te_flare.cpp:	if ( ( m_flTimeBurnOut != -1.0f ) && ( ( m_flTimeBurnOut - gpGlobals->curtime ) <= 10.0f ) )
game/client/hl2/c_te_flare.cpp:		baseScale *= ( ( m_flTimeBurnOut - gpGlobals->curtime ) / 10.0f );
game/client/hl2/c_te_flare.cpp:			m_pParticle[0]->m_flDieTime		= gpGlobals->curtime;
game/client/hl2/c_te_flare.cpp:			m_pParticle[1]->m_flDieTime		= gpGlobals->curtime;
game/client/hl2/c_te_flare.cpp:			dl->die		= gpGlobals->curtime + 0.1f;
game/client/hl2/c_te_flare.cpp:				dl->die		= gpGlobals->curtime + 0.1f;
game/client/hl2/c_te_flare.cpp:				el->die		= gpGlobals->curtime + 0.1f;
game/client/hl2/c_barnacle.cpp:	m_TonguePhysics.Simulate( gpGlobals->frametime );
game/client/hl2/c_barnacle.cpp:	float flTipMove = TIP_SNAP_FACTOR * gpGlobals->frametime;
game/client/hl2/c_plasma_beam_node.cpp:	float		flFrametime = gpGlobals->frametime;
game/client/hl2/c_plasma_beam_node.cpp:		SetNextClientThink(gpGlobals->curtime + 0.01);
game/client/hl2/c_plasma_beam_node.cpp:	SetNextClientThink(gpGlobals->curtime + 0.05);
game/client/hl2/c_extinguisher.cpp:		beamPoints[i] += vRight * sin( gpGlobals->curtime * 4.0f ) * (2.0f*i);
game/client/hl2/c_extinguisher.cpp:		beamPoints[i] += vUp * sin( gpGlobals->curtime * 8.0f ) * (1.0f*i);
game/client/hl2/c_extinguisher.cpp:		beamPoints[i] += shotDir * sin( gpGlobals->curtime * (16.0f*i) ) * (1.0f*i);
game/client/hl2/c_extinguisher.cpp:		seg.m_flTexCoord	= (float)i/(float)(numPoints-1) - ((gpGlobals->curtime - (int)gpGlobals->curtime) * 4.0f );
game/client/hl2/c_extinguisher.cpp:		seg.m_flWidth		= 4.0f + ( (64.0f*t) * (fabs( sin( gpGlobals->curtime * 16.0f ) )) );
game/client/hl2/hud_weaponselection.cpp:	if ( ( gpGlobals->curtime - m_flSelectionTime ) > flSelectionTimeout )
game/client/hl2/hud_weaponselection.cpp:		else if ( gpGlobals->curtime - m_flSelectionTime > flSelectionTimeout + flSelectionFadeoutTime )
game/client/hl2/hud_weaponselection.cpp:	if ( hud_fastswitch.GetBool() && ( gpGlobals->curtime - m_flSelectionTime ) < (FASTSWITCH_DISPLAY_TIMEOUT + FASTSWITCH_FADEOUT_TIME) )
game/client/hl2/hud_weaponselection.cpp:	float percentageDone = 1.0f; //min(1.0f, (gpGlobals->curtime - m_flPickupStartTime) / m_flWeaponPickupGrowTime);
game/client/hl2/c_npc_rollermine.cpp:	if ( m_bIsOpen && m_flActiveTime <= gpGlobals->curtime )
game/client/hl2/c_npc_rollermine.cpp:		if ( gpGlobals->frametime != 0 )
game/client/hl2/c_weapon_stunstick.cpp:			gpGlobals->frametime != 0.0f &&
game/client/hl2/c_info_teleporter_countdown.cpp:	m_pMalfunctionLabel->SetVisible( bMalfunction && (((int)(gpGlobals->curtime) & 0x1) == 0x1) );
game/client/hl2/c_info_teleporter_countdown.cpp:			float dt = gpGlobals->curtime - pActiveCountdown->m_flStartTime;
game/client/hl2/shieldproxy.cpp:	sOffset = gpGlobals->curtime * sin( m_ScrollAngle * ( M_PI / 180.0f ) ) * m_ScrollRate;
game/client/hl2/shieldproxy.cpp:	tOffset = gpGlobals->curtime * cos( m_ScrollAngle * ( M_PI / 180.0f ) ) * m_ScrollRate;
game/client/hl2/hud_credits.cpp:				pCredit->flYPos -= gpGlobals->frametime * ( (float)g_iCreditsPixelHeight / m_flScrollTime );
game/client/hl2/hud_credits.cpp:					m_flFadeTime = gpGlobals->curtime + ( IsConsole() ? 2.0f : 10.0f );
game/client/hl2/hud_credits.cpp:				if ( m_flFadeTime <= gpGlobals->curtime )
game/client/hl2/hud_credits.cpp:						m_Alpha -= gpGlobals->frametime * ( m_flScrollTime * 2 );
game/client/hl2/hud_credits.cpp:			pCredit->flYPos -= gpGlobals->frametime * ( (float)g_iCreditsPixelHeight / m_flScrollTime );
game/client/hl2/hud_credits.cpp:			float flDeltaTime = ( m_flFadeTime - gpGlobals->curtime );
game/client/hl2/hud_credits.cpp:				m_flFadeTime = gpGlobals->curtime + m_flLogoDesiredLength;
game/client/hl2/hud_credits.cpp:			if ( m_flFadeTime <= gpGlobals->curtime )
game/client/hl2/hud_credits.cpp:				m_flFadeTime = gpGlobals->curtime + 2.0f;
game/client/hl2/hud_credits.cpp:			float flDeltaTime = ( m_flFadeTime - gpGlobals->curtime );
game/client/hl2/hud_credits.cpp:		float localTime = gpGlobals->curtime - pCredit->flTimeStart;
game/client/hl2/hud_credits.cpp:		if ( m_flLogoTime > gpGlobals->curtime )
game/client/hl2/hud_credits.cpp:		if ( pCredit->flTime - m_flNextStartTime <= gpGlobals->curtime )
game/client/hl2/hud_credits.cpp:						pNextCredits->flTime = gpGlobals->curtime + m_flFadeInTime + m_flFadeOutTime + m_flFadeHoldTime + pNextCredits->flTimeAdd;
game/client/hl2/hud_credits.cpp:						pNextCredits->flTime = gpGlobals->curtime + m_flFadeInTime + m_flFadeOutTime + m_flFadeHoldTime + pNextCredits->flTimeAdd;
game/client/hl2/hud_credits.cpp:					pNextCredits->flTimeStart = gpGlobals->curtime;
game/client/hl2/hud_credits.cpp:		if ( pCredit->flTime <= gpGlobals->curtime )
game/client/hl2/hud_credits.cpp:	m_flFadeTime = gpGlobals->curtime + 5.0f;
game/client/hl2/hud_credits.cpp:			pCredit->flTime = gpGlobals->curtime + m_flFadeInTime + m_flFadeOutTime + m_flFadeHoldTime;
game/client/hl2/hud_credits.cpp:			pCredit->flTimeStart = gpGlobals->curtime;
game/client/hl2/hud_ammo.cpp:			ZeroSecondaryAmmo_Previous_Start_Time = gpGlobals->curtime;
game/client/hl2/hud_ammo.cpp:		if (gpGlobals->curtime >= ZeroSecondaryAmmo_Previous_Start_Time + g_pClientMode->GetViewportAnimationController()->GetAnimationSequenceLength("AmmoSecondaryEmpty"))
game/client/hl2/c_energy_wave.cpp:	float dt = gpGlobals->frametime;
game/client/hl2/c_basehlplayer.cpp.orig:	int min_fov = ( gpGlobals->maxClients == 1 ) ? 5 : default_fov.GetInt();
game/client/hl2/c_basehlplayer.cpp.orig:		float deltaTime = (float)( gpGlobals->curtime - m_flZoomStartTime ) / m_flZoomRate;
game/client/hl2/c_basehlplayer.cpp.orig:	m_flZoomStartTime	= gpGlobals->curtime;
game/client/hl2/c_basehlplayer.cpp.orig:			float flDeltaTime = (m_flSpeedModTime - gpGlobals->curtime);
game/client/hl2/c_basehlplayer.cpp.orig:				m_flSpeedModTime = gpGlobals->curtime + cl_npc_speedmod_outtime.GetFloat();
game/client/hl2/c_basehlplayer.cpp.orig:					float flDeltaTime = (m_flSpeedModTime - gpGlobals->curtime);
game/client/hl2/fx_hl2_tracers.cpp:			el->die		= gpGlobals->curtime + 0.1f;
game/client/hl2/fx_hl2_tracers.cpp:	el->die = gpGlobals->curtime + 0.05f;
game/client/hl2/c_citadel_effects.cpp:	return RemapValClamped( ( gpGlobals->curtime - m_flStartTime ), 0, m_flDuration, 0, 1.0f );;
game/client/hl2/c_citadel_effects.cpp:	if ( gpGlobals->frametime <= 0.0f )
game/client/hl2/c_basehlplayer.cpp:	int min_fov = ( gpGlobals->maxClients == 1 ) ? 5 : default_fov.GetInt();
game/client/hl2/c_basehlplayer.cpp:		float deltaTime = (float)( gpGlobals->curtime - m_flZoomStartTime ) / m_flZoomRate;
game/client/hl2/c_basehlplayer.cpp:	m_flZoomStartTime	= gpGlobals->curtime;
game/client/hl2/c_basehlplayer.cpp:			float flDeltaTime = (m_flSpeedModTime - gpGlobals->curtime);
game/client/hl2/c_basehlplayer.cpp:				m_flSpeedModTime = gpGlobals->curtime + cl_npc_speedmod_outtime.GetFloat();
game/client/hl2/c_basehlplayer.cpp:					float flDeltaTime = (m_flSpeedModTime - gpGlobals->curtime);
game/client/hl2/c_strider.cpp:		m_limitHitTime = gpGlobals->curtime + dt;
game/client/hl2/c_strider.cpp:		float dt = m_limitHitTime - gpGlobals->curtime;
game/client/hl2/c_strider.cpp:		m_t += gpGlobals->frametime;
game/client/hl2/c_strider.cpp:		dl->die = gpGlobals->curtime + 0.001;
game/client/hl2/c_strider.cpp:	if ( gpGlobals->curtime >= m_flNextRopeCutTime )
game/client/hl2/c_strider.cpp:		m_flNextRopeCutTime = gpGlobals->curtime + 0.5;
game/client/hl2/c_strider.cpp:		el->die		= gpGlobals->curtime + 0.1f;
game/client/hl2/c_env_alyxtemp.cpp:	float dTime = gpGlobals->frametime;
game/client/hl2/c_env_alyxtemp.cpp:	float dTime = gpGlobals->frametime;
game/client/hl2/c_env_alyxtemp.cpp:	float dTime = gpGlobals->frametime;
game/client/hl2/c_env_alyxtemp.cpp:	return RemapValClamped( ( gpGlobals->curtime - m_flStartTime ), 0, m_flDuration, 0, 1.0f );;
game/client/hl2/c_env_alyxtemp.cpp:	if ( gpGlobals->frametime <= 0.0f )
game/client/hl2/c_weapon_gravitygun.cpp:	//points[1].z += 4*sin( gpGlobals->curtime*11 ) + 5*cos( gpGlobals->curtime*13 );
game/client/hl2/c_weapon_gravitygun.cpp:	float scrollOffset = gpGlobals->curtime - (int)gpGlobals->curtime;
game/client/hl2/hud_radar.cpp:	m_flTimeStartGhosting = gpGlobals->curtime + 1.0f;
game/client/hl2/hud_radar.cpp:		m_radarContacts[iExistingContact].m_flTimeToRemove = gpGlobals->curtime + flTimeToLive;
game/client/hl2/hud_radar.cpp:	m_radarContacts[m_iNumRadarContacts].m_flTimeToRemove = gpGlobals->curtime + flTimeToLive;
game/client/hl2/hud_radar.cpp:			if( gpGlobals->curtime >= pContact->m_flTimeToRemove )
game/client/hl2/hud_radar.cpp:	if( gpGlobals->curtime > m_flTimeStartGhosting )
game/client/hl2/hud_radar.cpp:			m_flTimeStopGhosting = gpGlobals->curtime + RandomFloat( 1.0f, 2.0f );// How long to ghost for
game/client/hl2/hud_radar.cpp:	else if( gpGlobals->curtime > m_flTimeStopGhosting )
game/client/hl2/hud_radar.cpp:			m_flTimeStartGhosting = gpGlobals->curtime + RandomFloat( 2.0f, 3.0f );// how long between ghosts
game/client/hl2/hud_radar.cpp:		float deltaT = pContact->m_flTimeToRemove - gpGlobals->curtime;
game/client/hl2/hud_quickinfo.cpp:	float scale	= (int)( fabs(sin(gpGlobals->curtime*8.0f)) * 128.0);
game/client/hl2/hud_quickinfo.cpp:	if ( time <= (gpGlobals->frametime * 200.0f) )
game/client/hl2/hud_quickinfo.cpp:			time += (gpGlobals->frametime * 200.0f);
game/client/hl2/hud_quickinfo.cpp:	time -= (gpGlobals->frametime * 200.0f);
game/client/hl2/hud_quickinfo.cpp:	int	sinScale = (int)( fabs(sin(gpGlobals->curtime*8.0f)) * 128.0f );
game/client/hl2/hud_quickinfo.cpp:	m_flLastEventTime = gpGlobals->curtime;
game/client/hl2/hud_quickinfo.cpp:	if (( gpGlobals->curtime - m_flLastEventTime ) > QUICKINFO_EVENT_DURATION )
game/client/hl2/c_npc_antlionguard.cpp:	// dl->die = gpGlobals->curtime + 0.1f;
game/client/clientleafsystem.cpp:	int globalFrameCount = gpGlobals->framecount;
game/client/beamdraw.cpp:	fraction = ( die - gpGlobals->curtime ) * div;
game/client/beamdraw.cpp:			fraction = (pHead->die - gpGlobals->curtime) * div;
game/client/sdk/sdk_hud_message.cpp:	m_flStartTime = gpGlobals->curtime;
game/client/sdk/sdk_hud_message.cpp:	float dt = ( m_flStartTime - gpGlobals->curtime );
game/client/sdk/sdk_hud_weaponselection.cpp:	if ( ( gpGlobals->curtime - m_flSelectionTime ) > SELECTION_TIMEOUT_THRESHOLD )
game/client/sdk/sdk_hud_weaponselection.cpp:		else if (gpGlobals->curtime - m_flSelectionTime > SELECTION_TIMEOUT_THRESHOLD + SELECTION_FADEOUT_TIME)
game/client/sdk/sdk_hud_weaponselection.cpp:	float percentageDone = 1.0f; //min(1.0f, (gpGlobals->curtime - m_flPickupStartTime) / m_flWeaponPickupGrowTime);
game/client/sdk/c_sdk_env_sparkler.cpp:	float curTime = gpGlobals->frametime;
game/client/sdk/sdk_hud_chat.cpp:	float curtime = gpGlobals->curtime;
game/client/c_te_worlddecal.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/mathproxy.cpp:	flValue = ( sin( 2.0f * M_PI * (gpGlobals->curtime - flSineTimeOffset) / flSinePeriod ) * 0.5f ) + 0.5f;
game/client/mathproxy.cpp:	flValue = m_Rate.GetFloat() * gpGlobals->curtime + m_InitialValue.GetFloat();	
game/client/menu.cpp:	if ( m_bMenuDisplayed && ( gpGlobals->curtime - m_flSelectionTime > flSelectionTimeout ) )
game/client/menu.cpp:	if ( m_flShutoffTime > 0 && m_flShutoffTime <= gpGlobals->realtime )
game/client/menu.cpp:		m_flShutoffTime = gpGlobals->realtime + m_flOpenCloseTime;
game/client/menu.cpp:	m_flShutoffTime = gpGlobals->realtime + m_flOpenCloseTime;
game/client/menu.cpp:	m_flSelectionTime = gpGlobals->curtime;
game/client/menu.cpp:	m_flSelectionTime = gpGlobals->curtime;
game/client/menu.cpp:		m_flShutoffTime = m_flOpenCloseTime + DisplayTime + gpGlobals->realtime;
game/client/menu.cpp:		m_flSelectionTime = gpGlobals->curtime;
game/client/C_MaterialModifyControl.cpp:		m_flStartTime = gpGlobals->curtime;
game/client/C_MaterialModifyControl.cpp:	float deltaTime = gpGlobals->curtime - startTime;
game/client/C_MaterialModifyControl.cpp:	float prevTime = deltaTime - gpGlobals->frametime;
game/client/C_MaterialModifyControl.cpp:		pControl->SetAnimationStartTime( gpGlobals->curtime );
game/client/C_MaterialModifyControl.cpp:			currentValue = m_flStartValue + ( m_flEndValue - m_flStartValue ) * clamp( ( ( gpGlobals->curtime - m_flStartTime ) / m_flTransitionTime ), 0.0f, 1.0f );
game/client/C_MaterialModifyControl.cpp:				m_flStartTime = gpGlobals->curtime;
game/client/C_MaterialModifyControl.cpp:	float deltaTime = gpGlobals->curtime - startTime;
game/client/C_MaterialModifyControl.cpp:	float prevTime = deltaTime - gpGlobals->frametime;
game/client/hud_posture.cpp:	return ( m_duckTimeout >= gpGlobals->curtime &&
game/client/hud_posture.cpp:		m_duckTimeout = gpGlobals->curtime + HUD_POSTURE_FADE_TIME; // kick the timer forward
game/client/c_te_armorricochet.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_te_armorricochet.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_vote_controller.cpp:	pMe->SetNextClientThink( gpGlobals->curtime + 0.001 );
game/client/c_vote_controller.cpp:	SetNextClientThink( gpGlobals->curtime );
game/client/c_vote_controller.cpp:	SetNextClientThink( gpGlobals->curtime + 0.5f );
game/client/view_effects.cpp:		if ( ( gpGlobals->curtime > pShake->endtime ) || 
game/client/view_effects.cpp:		if ( gpGlobals->curtime > pShake->nextShake )
game/client/view_effects.cpp:			pShake->nextShake = gpGlobals->curtime + (1.0f / pShake->frequency);
game/client/view_effects.cpp:		fraction = ( pShake->endtime - gpGlobals->curtime ) / pShake->duration;
game/client/view_effects.cpp:		float angle = gpGlobals->curtime * freq;
game/client/view_effects.cpp:		pShake->amplitude -= pShake->amplitude * ( gpGlobals->frametime / (pShake->duration * pShake->frequency) );
game/client/view_effects.cpp:		pNewShake->endtime = gpGlobals->curtime + data.duration;
game/client/view_effects.cpp:			pNewFade->End	+= gpGlobals->curtime;
game/client/view_effects.cpp:			pNewFade->Reset	+= gpGlobals->curtime;
game/client/view_effects.cpp:			pFade->Reset = gpGlobals->curtime + 0.1;
game/client/view_effects.cpp:		if ( ( gpGlobals->curtime > pFade->Reset ) && ( gpGlobals->curtime > pFade->End ) )
game/client/view_effects.cpp:			iFadeAlpha = pFade->Speed * ( pFade->End - gpGlobals->curtime );
game/client/c_te_decal.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_rumble.cpp:	float			starttime;			// When did this effect start playing? (gpGlobals->curtime)
game/client/c_rumble.cpp:				float age = gpGlobals->curtime - pChannel->starttime;
game/client/c_rumble.cpp:				oldestChannel = gpGlobals->curtime - pChannel->starttime;
game/client/c_rumble.cpp:		pChannel->starttime = gpGlobals->curtime;
game/client/c_rumble.cpp:			pChannel->starttime = gpGlobals->curtime;
game/client/c_rumble.cpp:	g_RumbleEffects.UpdateEffects( gpGlobals->curtime );
game/client/viewangleanim.cpp:	m_flAnimStartTime = gpGlobals->curtime;
game/client/viewangleanim.cpp:	float flCurrentTime = gpGlobals->curtime - m_flAnimStartTime;
game/client/physics.cpp:	float frametime = gpGlobals->frametime;
game/client/physics.cpp:		if ( (gpGlobals->maxClients > 1) && pFriction && pFriction->pObject) 
game/client/physics.cpp:			if ( (pFriction->flLastEffectTime + 0.5f) > gpGlobals->curtime)
game/client/physics.cpp:				pFriction->flLastUpdateTime = gpGlobals->curtime;
game/client/physics.cpp:			if ( m_current[i].flLastUpdateTime < (gpGlobals->curtime-0.1f) )
game/client/physics.cpp:		if ( (gpGlobals->curtime - m_fluidEvents[i].impactTime) > FLUID_TIME_MAX )
game/client/physics.cpp:			return gpGlobals->curtime - m_fluidEvents[i].impactTime;
game/client/physics.cpp:	m_fluidEvents[index].impactTime = gpGlobals->curtime;
game/client/physics.cpp:		pFriction->flLastUpdateTime = gpGlobals->curtime;
game/client/physics.cpp:		pFriction->flLastEffectTime = gpGlobals->curtime;
game/client/physics.cpp:	return physenv->GetSimulationTime() + gpGlobals->frametime * cl_phys_timescale.GetFloat();
game/client/physics.cpp:		return gpGlobals->curtime + nextTime - simTime;
game/client/physics.cpp:	return gpGlobals->curtime;
game/client/c_te_bloodsprite.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/hud_basedeathnotice.cpp:		if ( gpGlobals->curtime > m_DeathNotices[i].GetExpiryTime() )
game/client/hud_basedeathnotice.cpp:			Assert( iPlayerIndex > 0 && iPlayerIndex <= gpGlobals->maxClients );
game/client/hud_basedeathnotice.cpp:	msg.flCreationTime = gpGlobals->curtime;
game/client/c_te_glowsprite.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_te_muzzleflash.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/viewpostprocess.cpp:		if ( int( gpGlobals->curtime ) - int( s_flLastTimeUpdate ) >= 2 )
game/client/viewpostprocess.cpp:			s_flLastTimeUpdate = gpGlobals->curtime;
game/client/viewpostprocess.cpp:					if ( int( gpGlobals->curtime ) - int( s_flLastTimeUpdate ) >= 2 )
game/client/viewpostprocess.cpp:						s_flLastTimeUpdate = gpGlobals->curtime;
game/client/viewpostprocess.cpp:					pSide->m_flIntensity += pSide->m_flRate * gpGlobals->frametime;
game/client/viewpostprocess.cpp:					pSide->m_flIntensity -= pSide->m_flRate * gpGlobals->frametime;
game/client/viewpostprocess.cpp:		float flTimeElapsed = gpGlobals->realtime - s_flLastTimeUpdate;
game/client/viewpostprocess.cpp:			//engine->Con_NPrintf( 8, " Pos change && time > 0.5 seconds %f ", gpGlobals->realtime );
game/client/viewpostprocess.cpp:			//engine->Con_NPrintf( 8, " Position changed %f units @ %.2f time ", VectorLength( vPositionChange ), gpGlobals->realtime );
game/client/viewpostprocess.cpp:			s_flNoRotationalMotionBlurUntil = gpGlobals->realtime + 1.0f; // Wait a second until the portal craziness calms down
game/client/viewpostprocess.cpp:				//engine->Con_NPrintf( 4, "gpGlobals->realtime %.2f  gpGlobals->curtime %.2f", gpGlobals->realtime, gpGlobals->curtime );
game/client/viewpostprocess.cpp:		if ( gpGlobals->realtime < s_flNoRotationalMotionBlurUntil )
game/client/viewpostprocess.cpp:			//engine->Con_NPrintf( 9, " No Rotation @ %f ", gpGlobals->realtime );
game/client/viewpostprocess.cpp:		s_flLastTimeUpdate = gpGlobals->realtime;
game/client/EffectsClient.cpp:	return gpGlobals->curtime;
game/client/clientshadowmgr.cpp:	if ( shadow.m_nRenderFrame == gpGlobals->framecount )
game/client/clientshadowmgr.cpp:	shadow.m_nRenderFrame = gpGlobals->framecount;
game/client/clientshadowmgr.cpp:	pBaseAnimating->SetupBones( NULL, -1, -1, gpGlobals->curtime );
game/client/mp3player.cpp:		skipTime == 0.0f ? 0.0f : ( gpGlobals->curtime + skipTime  ) ); 
game/client/mp3player.cpp:	m_SongStart = gpGlobals->realtime;
game/client/mp3player.cpp:			float elapsed = gpGlobals->realtime - m_SongStart;
game/client/c_fire_smoke.cpp:	if ( gpGlobals->frametime <= 0.0f )
game/client/c_fire_smoke.cpp:		dl->die = gpGlobals->curtime + 0.001;
game/client/glow_overlay.cpp:			m_flGlowObstructionScale -= gpGlobals->frametime / cl_sun_decay_rate.GetFloat();
game/client/glow_overlay.cpp:			m_flGlowObstructionScale += gpGlobals->frametime / cl_sun_decay_rate.GetFloat();
game/client/vgui_netgraphpanel.cpp:	m_Framerate = FRAMERATE_AVG_FRAC * m_Framerate + ( 1.0 - FRAMERATE_AVG_FRAC ) * gpGlobals->absoluteframetime;
game/client/c_baseplayer.h:	bool					ShouldAnnounceAchievement( void ){ return m_flNextAchievementAnnounceTime < gpGlobals->curtime; }
game/client/c_te_sparks.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/hl2mp/hud_deathnotice.cpp:		if ( m_DeathNotices[i].flDisplayTime < gpGlobals->curtime )
game/client/hl2mp/hud_deathnotice.cpp:	deathMsg.flDisplayTime = gpGlobals->curtime + hud_deathnotice_time.GetFloat();
game/client/hl2mp/ui/hl2mpclientscoreboard.cpp:	for ( int j = 1; j <= gpGlobals->maxClients; j++ )
game/client/hl2mp/ui/hl2mpclientscoreboard.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/client/hl2mp/c_hl2mp_player.cpp:	m_flCurrentHeadYaw = ApproachAngle( desired, m_flCurrentHeadYaw, 130 * gpGlobals->frametime );
game/client/hl2mp/c_hl2mp_player.cpp:	m_flCurrentHeadPitch = ApproachAngle( desired, m_flCurrentHeadPitch, 130 * gpGlobals->frametime );
game/client/hl2mp/c_hl2mp_player.cpp:	for( int iClient = 1; iClient <= gpGlobals->maxClients; ++iClient )
game/client/hl2mp/c_hl2mp_player.cpp:				el->die = gpGlobals->curtime + 0.1;
game/client/hl2mp/c_hl2mp_player.cpp:		m_pFlashlightBeam->die = gpGlobals->curtime - 1;
game/client/hl2mp/hl2mp_hud_target_id.cpp:		if ( m_flLastChangeTime && (gpGlobals->curtime > (m_flLastChangeTime + 0.5)) )
game/client/hl2mp/hl2mp_hud_target_id.cpp:		m_flLastChangeTime = gpGlobals->curtime;
game/client/hud_vote.cpp:	m_flHideTime = gpGlobals->curtime + 4.0;
game/client/hud_vote.cpp:	m_flVoteResultCycleTime = gpGlobals->curtime + 2;
game/client/hud_vote.cpp:	m_flHideTime = gpGlobals->curtime + 5;
game/client/hud_vote.cpp:	m_flVoteResultCycleTime = gpGlobals->curtime + 2;
game/client/hud_vote.cpp:	m_flHideTime = gpGlobals->curtime + 5;
game/client/hud_vote.cpp:			m_flPostVotedHideTime = gpGlobals->curtime + 1.5f;
game/client/hud_vote.cpp:	if ( m_bPlayerVoted && m_flPostVotedHideTime > 0 && m_flPostVotedHideTime < gpGlobals->curtime )
game/client/hud_vote.cpp:	if ( m_flVoteResultCycleTime > 0 && m_flVoteResultCycleTime < gpGlobals->curtime )
game/client/hud_vote.cpp:	return ( m_bVoteActive || m_flHideTime > gpGlobals->curtime );
game/client/weapon_selection.cpp:	m_flSelectionTime = gpGlobals->curtime;
game/client/weapon_selection.cpp:	m_flSelectionTime = gpGlobals->curtime;
game/client/weapon_selection.cpp:	m_flSelectionTime = gpGlobals->curtime;
game/client/c_dynamiclight.cpp:		SetNextClientThink(gpGlobals->curtime + 0.05);
game/client/c_dynamiclight.cpp:		m_pDynamicLight->die = gpGlobals->curtime;
game/client/c_dynamiclight.cpp:		m_pSpotlightEnd->die = gpGlobals->curtime;
game/client/c_dynamiclight.cpp:		m_pDynamicLight->die = gpGlobals->curtime + 1e6;
game/client/c_dynamiclight.cpp:			m_pDynamicLight->die = gpGlobals->curtime;
game/client/c_dynamiclight.cpp:			m_pSpotlightEnd->die = gpGlobals->curtime;
game/client/c_dynamiclight.cpp:			m_pSpotlightEnd->die		= gpGlobals->curtime + 1e6;
game/client/c_dynamiclight.cpp:			m_pSpotlightEnd->die = gpGlobals->curtime;
game/client/c_dynamiclight.cpp:	SetNextClientThink(gpGlobals->curtime + 0.001);
game/client/c_baseanimatingoverlay.cpp:	CheckForLayerChanges( pStudioHdr, gpGlobals->curtime ); // !!!
game/client/c_baseanimatingoverlay.cpp:						gpGlobals->tickcount,
game/client/c_baseanimatingoverlay.cpp:						gpGlobals->curtime );
game/client/c_baseanimatingoverlay.cpp:						gpGlobals->tickcount,
game/client/c_baseanimatingoverlay.cpp:						gpGlobals->curtime );
game/client/c_baseflex.cpp:		//auto_ik.Init( hdr, GetRenderAngles(), GetRenderOrigin(), currentTime, gpGlobals->framecount, boneMask );
game/client/c_baseflex.cpp:		m_blinktime = gpGlobals->curtime + g_CV_BlinkDuration.GetFloat();
game/client/c_baseflex.cpp:	float t = (m_blinktime - gpGlobals->curtime) * M_PI * 0.5 * (1.0/g_CV_BlinkDuration.GetFloat());
game/client/c_baseflex.cpp:		m_blinktime = gpGlobals->curtime + g_CV_BlinkDuration.GetFloat();
game/client/c_baseflex.cpp:	float t = ( m_blinktime - gpGlobals->curtime ) * M_PI * 0.5 * flOOBlinkDuration;
game/client/c_baseflex.cpp:	if ( flFlexDelayTime > 0.0f && flFlexDelayTime < gpGlobals->curtime )
game/client/c_baseflex.cpp:		float d = clamp( gpGlobals->curtime - flFlexDelayTime, 0.0, gpGlobals->frametime );
game/client/c_baseflex.cpp:	flFlexDelayTime = gpGlobals->curtime;
game/client/texturescrollmaterialproxy.cpp:	sOffset = gpGlobals->curtime * cos( angle * ( M_PI / 180.0f ) ) * rate;
game/client/texturescrollmaterialproxy.cpp:	tOffset = gpGlobals->curtime * sin( angle * ( M_PI / 180.0f ) ) * rate;
game/client/c_te_spritespray.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/bone_merge_cache.cpp:	bool bWorked = m_pFollow->SetupBones( NULL, -1, m_nFollowBoneSetupMask, gpGlobals->curtime );
game/client/bone_merge_cache.cpp:	m_pFollow->SetupBones( NULL, -1, m_nFollowBoneSetupMask, gpGlobals->curtime );
game/client/bone_merge_cache.cpp:	m_pFollow->SetupBones( NULL, -1, m_nFollowBoneSetupMask, gpGlobals->curtime );
game/client/fx_interpvalue.cpp:	m_flStartTime = m_flEndTime = gpGlobals->curtime;
game/client/fx_interpvalue.cpp:	SetTime( gpGlobals->curtime, gpGlobals->curtime + dt );
game/client/fx_interpvalue.cpp:	Init( Interp( gpGlobals->curtime ), endValue, dt, type );
game/client/viewrender.cpp:	if ( render->GetViewEntity() > gpGlobals->maxClients )
game/client/viewrender.cpp:	g_viewscene_refractUpdateFrame = gpGlobals->framecount - 1;
game/client/viewrender.cpp:	clienteffects->DrawEffects( gpGlobals->frametime );	
game/client/viewrender.cpp:	if ( pFogParams->lerptime >= gpGlobals->curtime )
game/client/viewrender.cpp:		float flPercent = 1.0f - (( pFogParams->lerptime - gpGlobals->curtime ) / pFogParams->duration );
game/client/viewrender.cpp:		if ( pFogParams->lerptime > gpGlobals->curtime )
game/client/viewrender.cpp:				if ( pFogParams->lerptime > gpGlobals->curtime )
game/client/viewrender.cpp:					float flPercent = 1.0f - (( pFogParams->lerptime - gpGlobals->curtime ) / pFogParams->duration );
game/client/viewrender.cpp:		if ( pFogParams->lerptime > gpGlobals->curtime )
game/client/viewrender.cpp:				if ( pFogParams->lerptime > gpGlobals->curtime )
game/client/viewrender.cpp:					float flPercent = 1.0f - (( pFogParams->lerptime - gpGlobals->curtime ) / pFogParams->duration );
game/client/viewrender.cpp:		if ( m_flFreezeFrameUntil > gpGlobals->curtime )
game/client/viewrender.cpp:			m_flFreezeFrameUntil = gpGlobals->curtime + flFreezeTime;
game/client/viewrender.cpp:	if ( !m_rbTakeFreezeFrame[ view.m_eStereoEye ] && m_flFreezeFrameUntil > gpGlobals->curtime )
game/client/viewrender.cpp:	g_viewscene_refractUpdateFrame = gpGlobals->framecount - 1;
game/client/viewrender.cpp:	pBaseAnimating->SetupBones( NULL, -1, -1, gpGlobals->curtime );
game/client/viewrender.cpp:	if ( g_flFreezeFlash >= gpGlobals->curtime && engine->IsTakingScreenshot() == false )
game/client/viewrender.cpp:		int iFadeAlpha = FREEZECAM_SNAPSHOT_FADE_SPEED * ( g_flFreezeFlash - gpGlobals->curtime );
game/client/proxyplayer.cpp:	if ( playerindex > gpGlobals->maxClients )
game/client/hud_closecaption.cpp:		m_flGoalHeightStartTime = gpGlobals->curtime;
game/client/hud_closecaption.cpp:		m_flGoalHeightFinishTime = gpGlobals->curtime + m_flGrowTime;
game/client/hud_closecaption.cpp:		m_flGoalHeightStartTime = gpGlobals->curtime;
game/client/hud_closecaption.cpp:		m_flGoalHeightFinishTime = gpGlobals->curtime + m_flGrowTime;
game/client/hud_closecaption.cpp:		float frac = ( gpGlobals->curtime - m_flGoalHeightStartTime ) / dt;
game/client/hud_closecaption.cpp:						wu->SetFadeStart( gpGlobals->curtime );
game/client/hud_closecaption.cpp:					float flFadeTime = (gpGlobals->curtime - wu->GetFadeStart()) /  CAPTION_PAN_FADE_TIME;
game/client/hud_closecaption.cpp:	float dt = gpGlobals->frametime;
game/client/hud_closecaption.cpp:			entry.m_flLastEmitTime = gpGlobals->curtime;
game/client/hud_closecaption.cpp:			entry.m_nLastEmitTick = gpGlobals->tickcount;
game/client/hud_closecaption.cpp:			if ( gpGlobals->curtime < ( entry.m_flLastEmitTime + entry.m_flInterval ) )
game/client/hud_closecaption.cpp:			entry.m_flLastEmitTime = gpGlobals->curtime;
game/client/hud_closecaption.cpp:			entry.m_nLastEmitTick = gpGlobals->tickcount;
game/client/hud_closecaption.cpp:		entry.m_flLastEmitTime = gpGlobals->curtime;
game/client/hud_closecaption.cpp:		entry.m_nLastEmitTick = gpGlobals->tickcount;
game/client/hud_closecaption.cpp:			if ( gpGlobals->tickcount <= entry.m_nLastEmitTick )
game/client/hud_closecaption.cpp:			if ( gpGlobals->curtime < ( entry.m_flLastEmitTime + entry.m_flInterval ) )
game/client/hud_closecaption.cpp:		entry.m_flLastEmitTime = gpGlobals->curtime;
game/client/hud_closecaption.cpp:		entry.m_nLastEmitTick = gpGlobals->tickcount;
game/client/c_te_smoke.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/c_slideshow_display.cpp:	if ( m_NextSlideTime > gpGlobals->curtime )
game/client/c_slideshow_display.cpp:	m_NextSlideTime = gpGlobals->curtime + RandomFloat( m_fMinSlideTime, m_fMaxSlideTime );
game/client/c_te_effect_dispatch.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/client/geiger.cpp:	if ( gpGlobals->curtime - m_flLastSoundTestTime < 0.06 )
game/client/geiger.cpp:	m_flLastSoundTestTime = gpGlobals->curtime;
game/client/c_sceneentity.cpp:		float soundtime = gpGlobals->curtime - time_in_past;
game/client/c_sceneentity.cpp:	// Msg( "CL:  %d, %f for %s\n", gpGlobals->tickcount, m_flCurrentTime, m_pScene->GetFilename() );
game/client/c_sceneentity.cpp:	m_flCurrentTime += gpGlobals->frametime;
game/client/c_sceneentity.cpp:	DoThink( gpGlobals->frametime );
game/client/c_vehicle_jeep.cpp:			m_flViewAngleDeltaTime += gpGlobals->frametime;
game/client/c_vehicle_jeep.cpp:	float flFrameTime = gpGlobals->frametime;
game/client/clientsideeffects_test.cpp:	float dt = g_BulletWhiz.m_nextWhizTime - gpGlobals->curtime;
game/client/clientsideeffects_test.cpp:	g_BulletWhiz.m_nextWhizTime = gpGlobals->curtime + random->RandomFloat( flMinWhizTime, flMaxWhizTime );
game/client/c_baseentity.cpp:	tickbase = gpGlobals->GetNetworkBase( gpGlobals->tickcount, pEntity->entindex() );
game/client/c_baseentity.cpp:	while (t < gpGlobals->tickcount - 127)
game/client/c_baseentity.cpp:	while (t > gpGlobals->tickcount + 127)
game/client/c_baseentity.cpp:	tickbase = gpGlobals->GetNetworkBase( gpGlobals->tickcount, pEntity->entindex() );
game/client/c_baseentity.cpp:	while (t < gpGlobals->tickcount - 127)
game/client/c_baseentity.cpp:	while (t > gpGlobals->tickcount + 127)
game/client/c_baseentity.cpp:	m_nLastThinkTick = gpGlobals->tickcount;
game/client/c_baseentity.cpp:	m_nCreationTick = gpGlobals->tickcount;
game/client/c_baseentity.cpp:		m_nCreationTick = gpGlobals->tickcount;
game/client/c_baseentity.cpp:		if ( localplayer && currentTime == gpGlobals->curtime )
game/client/c_baseentity.cpp:			currentTime += ( gpGlobals->interpolation_amount * TICK_INTERVAL );
game/client/c_baseentity.cpp:		SpewInterpolatedVar( &m_iv_vecOrigin, gpGlobals->curtime, GetInterpolationAmount( LATCH_SIMULATION_VAR ), true );
game/client/c_baseentity.cpp:		dl->die = gpGlobals->curtime + 0.001;
game/client/c_baseentity.cpp:		dl->die = gpGlobals->curtime + 0.001;
game/client/c_baseentity.cpp:		pEnt->Interpolate( gpGlobals->curtime );
game/client/c_baseentity.cpp:		pCur->m_bReadyToDraw = pCur->Interpolate( gpGlobals->curtime );
game/client/c_baseentity.cpp:	if ( m_nFXComputeFrame == gpGlobals->framecount )
game/client/c_baseentity.cpp:		blend = m_clrRender->a + 0x40 * sin( gpGlobals->curtime * 2 + offset );	
game/client/c_baseentity.cpp:		blend = m_clrRender->a + 0x40 * sin( gpGlobals->curtime * 8 + offset );
game/client/c_baseentity.cpp:		blend = ( 0xff * fabs(sin( gpGlobals->curtime * 12 + offset ) ) );
game/client/c_baseentity.cpp:		blend = m_clrRender->a + 0x10 * sin( gpGlobals->curtime * 2 + offset );
game/client/c_baseentity.cpp:		blend = m_clrRender->a + 0x10 * sin( gpGlobals->curtime * 8 + offset );
game/client/c_baseentity.cpp:		blend = 20 * sin( gpGlobals->curtime * 4 + offset );
game/client/c_baseentity.cpp:		blend = 20 * sin( gpGlobals->curtime * 16 + offset );
game/client/c_baseentity.cpp:		blend = 20 * sin( gpGlobals->curtime * 36 + offset );
game/client/c_baseentity.cpp:		blend = 20 * (sin( gpGlobals->curtime * 2 ) + sin( gpGlobals->curtime * 17 + offset ));
game/client/c_baseentity.cpp:		blend = 20 * (sin( gpGlobals->curtime * 16 ) + sin( gpGlobals->curtime * 23 + offset ));
game/client/c_baseentity.cpp:	m_nFXComputeFrame = gpGlobals->framecount;
game/client/c_baseentity.cpp:	Assert( m_nFXComputeFrame == gpGlobals->framecount );
game/client/c_baseentity.cpp:		//	Msg( "%i errors %i on entity %i %s\n", gpGlobals->tickcount, ecount, index, IsClientCreated() ? "true" : "false" );
game/client/c_baseentity.cpp:	el->die = gpGlobals->curtime + 5.0f;
game/client/c_baseentity.cpp:	m_nFXComputeFrame = gpGlobals->framecount;
game/client/c_baseentity.cpp:	m_iv_vecOrigin.GetDerivative_SmoothVelocity( &vel, gpGlobals->curtime );
game/client/c_baseentity.cpp:	const bool bPlayingMultiplayer = !bPlayingDemo && ( gpGlobals->maxClients > 1 );
game/client/c_baseentity.cpp:		return gpGlobals->curtime;
game/client/c_baseentity.cpp:			return gpGlobals->curtime;
game/client/c_baseentity.cpp:	return gpGlobals->curtime;
game/client/c_baseentity.cpp:	Assert( m_nLastRecordedFrame <= gpGlobals->framecount );
game/client/c_baseentity.cpp:	return m_nLastRecordedFrame == gpGlobals->framecount;
game/client/c_baseentity.cpp:	state.m_flTime = gpGlobals->curtime;
game/client/c_baseentity.cpp:	m_nLastRecordedFrame = gpGlobals->framecount;
game/client/c_fish.cpp:	float deltaT = gpGlobals->frametime;
game/client/c_fish.cpp:			m_angles.z += rollAmp * sin( rollFreq * (gpGlobals->curtime + 10.0f * entindex()) ) * deltaT;
game/client/c_fish.cpp:			m_angles.x += rollAmp2 * sin( rollFreq2 * (gpGlobals->curtime + 10.0f * entindex()) ) * deltaT;
game/client/c_fish.cpp:			m_vel.z += bobAmp * sin( bobFreq * (gpGlobals->curtime + 10.0f * entindex()) ) * deltaT;
game/client/c_fish.cpp:			m_vel.z += bobAmp2 * sin( bobFreq2 * (gpGlobals->curtime + 10.0f * entindex()) ) * deltaT;
game/server/sendproxy.cpp:	float clock_base = floor( gpGlobals->curtime );
game/server/item_world.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/item_world.cpp:	SetNextThink( gpGlobals->curtime + flTime );
game/server/item_world.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/item_world.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/item_world.cpp:	SetNextThink( gpGlobals->curtime + g_pGameRules->FlItemRespawnTime( this ) );
game/server/nav_mesh.cpp:	Q_snprintf( filename, sizeof( filename ), "%s\\maps\\%s_xyz.txt", gamePath, STRING( gpGlobals->mapname ) );
game/server/nav_mesh.cpp:	Q_snprintf( filename, sizeof( filename ), "%s\\maps\\%s_xyz.txt", gamePath, STRING( gpGlobals->mapname ) );
game/server/ai_navigator.cpp:		m_flTimeClipped = gpGlobals->curtime + 1000; // time passes between restore and onrestore
game/server/ai_navigator.cpp:	if ( m_flTimeLastAvoidanceTriangulate >= gpGlobals->curtime )
game/server/ai_navigator.cpp:	m_flTimeLastAvoidanceTriangulate = gpGlobals->curtime;
game/server/ai_navigator.cpp:		m_flLastNavFailTime = gpGlobals->curtime;
game/server/ai_navigator.cpp:						m_flTimeClipped = gpGlobals->curtime;
game/server/ai_navigator.cpp:		m_timeBeginFailedSteer = gpGlobals->curtime;
game/server/ai_navigator.cpp:			  gpGlobals->curtime - m_timeBeginFailedSteer > TIME_TOLERANCE && 
game/server/ai_navigator.cpp:	result = GetLocalNavigator()->MoveCalc( &move, ( m_flLastSuccessfulSimplifyTime == gpGlobals->curtime ) );
game/server/ai_navigator.cpp:				if ( gpGlobals->curtime - GetPath()->GetStartTime() > 5 )
game/server/ai_navigator.cpp:		bFullSimplify = ( m_flNextSimplifyTime <= gpGlobals->curtime );
game/server/ai_navigator.cpp:			if ( g_iFrameLastSimplified != gpGlobals->framecount )
game/server/ai_navigator.cpp:				g_iFrameLastSimplified = gpGlobals->framecount;
game/server/ai_navigator.cpp:			m_flNextSimplifyTime = gpGlobals->curtime + simplifyDelay;
game/server/ai_navigator.cpp:			if ( !AIStrongOpt() || gpGlobals->curtime - m_flLastSuccessfulSimplifyTime > QUICK_SIMPLIFY_TIME_DELAY[AIStrongOpt()] )
game/server/ai_navigator.cpp:		m_flLastSuccessfulSimplifyTime = gpGlobals->curtime;
game/server/ai_navigator.cpp:	if ( m_flNextSimplifyTime > gpGlobals->curtime)
game/server/ai_navigator.cpp:	m_flNextSimplifyTime = gpGlobals->curtime + FLY_ROUTE_SIMPLIFY_TIME_DELAY;
game/server/ai_navigator.cpp:		if (m_timePathRebuildFail < gpGlobals->curtime)
game/server/ai_navigator.cpp:		else if ( m_timePathRebuildNext > gpGlobals->curtime )
game/server/ai_navigator.cpp:			m_timePathRebuildFail = gpGlobals->curtime + m_timePathRebuildMax;
game/server/ai_navigator.cpp:		m_timePathRebuildNext = gpGlobals->curtime + m_timePathRebuildDelay;
game/server/ai_navigator.cpp:				pLink->m_timeStaleExpires = gpGlobals->curtime + 4.0;
game/server/ai_navigator.cpp:				pLink->m_timeStaleExpires = gpGlobals->curtime + 4.0;
game/server/ai_navigator.cpp:	if ( gpGlobals->curtime - m_flTimeClipped > 0.11  || m_bLastNavFailed )
game/server/ai_navigator.cpp:				m_flTimeClipped = gpGlobals->curtime;
game/server/lights.cpp:	SetNextThink( gpGlobals->curtime );
game/server/lights.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/nav_entities.cpp:	SetNextThink( gpGlobals->curtime + UPDATE_DIRTY_TIME );
game/server/nav_entities.cpp:	SetNextThink( gpGlobals->curtime + UPDATE_DIRTY_TIME );
game/server/cbase.cpp:						gpGlobals->curtime,
game/server/cbase.cpp:						gpGlobals->curtime,
game/server/cbase.cpp:		gpGlobals->curtime
game/server/cbase.cpp:	newEvent->m_flFireTime = gpGlobals->curtime + fireDelay;	// priority key in the priority queue
game/server/cbase.cpp:	newEvent->m_flFireTime = gpGlobals->curtime + fireDelay;	// primary priority key in the priority queue
game/server/cbase.cpp:	while ( pe != NULL && pe->m_flFireTime <= gpGlobals->curtime )
game/server/cbase.cpp:					  tmpEvent.m_flFireTime - gpGlobals->curtime,
game/server/cbase.cpp:					  tmpEvent.m_flFireTime - gpGlobals->curtime,
game/server/ai_senses.cpp:	if ( m_TimeLastLook != gpGlobals->curtime || m_LastLookDist != iDistance )
game/server/ai_senses.cpp:		m_TimeLastLook = gpGlobals->curtime;
game/server/ai_senses.cpp:	if ( gpGlobals->curtime - m_TimeLastLookHighPriority > AI_HIGH_PRIORITY_SEARCH_TIME )
game/server/ai_senses.cpp:		m_TimeLastLookHighPriority = gpGlobals->curtime;
game/server/ai_senses.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_senses.cpp:	if ( gpGlobals->curtime - m_TimeLastLookNPCs > timeNPCs )
game/server/ai_senses.cpp:		m_TimeLastLookNPCs = gpGlobals->curtime;
game/server/ai_senses.cpp:	if ( gpGlobals->curtime - m_TimeLastLookMisc > AI_MISC_SEARCH_TIME )
game/server/ai_senses.cpp:		m_TimeLastLookMisc = gpGlobals->curtime;
game/server/ai_blended_movement.cpp:		// DevMsg( "%6.2f : Speed %.1f : %.1f (%.1f) :  %d\n", gpGlobals->curtime, flNewSpeed, move.maxDist, move.transitionDist, GetOuter()->m_pHintNode != NULL );
game/server/ai_blended_movement.cpp:		// DevMsg( "%6.2f : Speed %.1f : %.1f\n", gpGlobals->curtime, flNewSpeed, GetIdealSpeed() );
game/server/ai_blended_movement.cpp:		DevMsg( "%6.2f : Speed %.1f : %.1f : %.2f\n", gpGlobals->curtime, flNewSpeed, GetIdealSpeed(), flNewSpeed / GetIdealSpeed() );
game/server/ai_blended_movement.cpp:	// DevMsg( "%6.2f : Speed %.1f : %.1f\n", gpGlobals->curtime, flNewSpeed, GetIdealSpeed() );
game/server/ai_blended_movement.cpp:	if (m_flNextTurnGesture > gpGlobals->curtime || m_flNextTurnAct > gpGlobals->curtime || GetOuter()->IsMoving() )
game/server/ai_blended_movement.cpp:			m_flNextTurnAct = gpGlobals->curtime + 0.3;
game/server/ai_blended_movement.cpp:				m_flNextTurnAct = gpGlobals->curtime + GetOuter()->GetLayerDuration( iLayer );
game/server/ai_blended_movement.cpp:				m_flNextTurnAct = gpGlobals->curtime + 0.3;
game/server/ai_blended_movement.cpp:	if (m_flNextTurnGesture > gpGlobals->curtime)
game/server/ai_blended_movement.cpp:			Msg( "%.1f : [ %.2f ]\n", flYD, m_flNextTurnAct - gpGlobals->curtime );
game/server/ai_blended_movement.cpp:			m_flNextTurnGesture = gpGlobals->curtime + MAX( turnCompletion * actualDuration, 0.3 );
game/server/effects.cpp:		SetNextThink( gpGlobals->curtime + 2.0 );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/effects.cpp:			SetNextThink( gpGlobals->curtime + 0.5f );
game/server/effects.cpp:			SetNextThink( gpGlobals->curtime + 2.5 - (0.1 * m_frequency) );
game/server/effects.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/effects.cpp:		SetNextThink( gpGlobals->curtime + 2.5 - (0.1 * m_frequency) );
game/server/effects.cpp:		SetNextThink( gpGlobals->curtime + m_flDelay );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime + m_flDelay );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:		float thinkTime = ( pGib->GetNextThink() - gpGlobals->curtime );
game/server/effects.cpp:			pGib->SetNextThink( gpGlobals->curtime + pGib->m_lifeTime );
game/server/effects.cpp:			pGib->SetNextThink( gpGlobals->curtime + pGib->m_lifeTime );
game/server/effects.cpp:						pGib->SetNextThink( gpGlobals->curtime + pGib->m_lifeTime );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime + m_flDelay );
game/server/effects.cpp:			SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:			SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	pGib->m_lifeTime = gpGlobals->curtime + m_flGibLife;
game/server/effects.cpp:		if ( m_flNextGibTime > gpGlobals->curtime )
game/server/effects.cpp:	m_flNextGibTime	= gpGlobals->curtime + m_flTimeUnderRotor + random->RandomFloat( -1, 1) * m_flTimeUnderRotorVariance;
game/server/effects.cpp:	if ( m_flNextGibTime <= gpGlobals->curtime )
game/server/effects.cpp:		m_flNextGibTime = gpGlobals->curtime + 0.01f;
game/server/effects.cpp:			SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	float t = (gpGlobals->curtime - m_flStartTime);
game/server/effects.cpp:		m_flBeamTime[m_iBeam] = gpGlobals->curtime;
game/server/effects.cpp:			t = (gpGlobals->curtime - m_flBeamTime[i]) / ( 3 + m_flStartTime - m_flBeamTime[i]);
game/server/effects.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/effects.cpp:		m_flStartTime = gpGlobals->curtime;
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/effects.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	//SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	m_EnvWindShared.Init( entindex(), 0, gpGlobals->frametime, GetLocalAngles().y, 0 );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	SetNextThink( m_EnvWindShared.WindThink( gpGlobals->curtime ) );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime );
game/server/effects.cpp:	SetNextThink( gpGlobals->curtime + m_flRateOfFire );
game/server/effects.cpp:		SetNextThink( gpGlobals->curtime + random->RandomFloat( m_flMinBurstDelay, m_flMaxBurstDelay ) );
game/server/effects.cpp:	if ( gpGlobals->maxClients > 1 )
game/server/ai_hint.cpp:			gpGlobals->tickcount,
game/server/ai_hint.cpp:	m_flNextUseTime = gpGlobals->curtime + delay;
game/server/ai_hint.cpp:	if (gpGlobals->curtime < m_flNextUseTime)
game/server/ai_hint.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_hint.cpp:		Q_snprintf(tempstr,sizeof(tempstr),"delay %f", MAX( 0.0f, m_flNextUseTime - gpGlobals->curtime ) ) ;
game/server/ai_speech.cpp:		m_flLastTimeAcceptedSpeak = gpGlobals->curtime;
game/server/ai_speech.cpp:	SpeechMsg( GetOuter(), "%s (%p) spoke %s (%f)\n", STRING(GetOuter()->GetEntityName()), GetOuter(), concept, gpGlobals->curtime );
game/server/ai_speech.cpp:	SpeechMsg( GetOuter(), "BlockSpeechUntil(%f) %f\n", time, time - gpGlobals->curtime );
game/server/ai_speech.cpp:		m_flStopTalkTime = gpGlobals->curtime + 3;
game/server/ai_speech.cpp:		m_flStopTalkTime = gpGlobals->curtime + duration;
game/server/ai_speech.cpp:		m_flStopTalkTime = gpGlobals->curtime;
game/server/ai_speech.cpp:		m_flStopTalkTimeWithoutDelay = gpGlobals->curtime;
game/server/ai_speech.cpp:	if ( m_flStopTalkTime > gpGlobals->curtime )
game/server/ai_speech.cpp:		SpeechMsg( GetOuter(), "IsSpeaking() %f\n", m_flStopTalkTime - gpGlobals->curtime );
game/server/ai_speech.cpp:	if ( m_flLastTimeAcceptedSpeak == gpGlobals->curtime ) // only one speak accepted per think
game/server/ai_speech.cpp:	return ( m_flStopTalkTime > gpGlobals->curtime );
game/server/ai_speech.cpp:	if ( m_flLastTimeAcceptedSpeak == gpGlobals->curtime ) // only one speak accepted per think
game/server/ai_speech.cpp:	return ( timeOk <= gpGlobals->curtime );
game/server/ai_speech.cpp:	if ( m_flLastTimeAcceptedSpeak == gpGlobals->curtime ) // only one speak accepted per think
game/server/ai_speech.cpp:	return ( timeOk <= gpGlobals->curtime );
game/server/ai_speech.cpp:		if ( history->timeSpoken != -1 && ( gpGlobals->curtime < history->timeSpoken + respeakDelay ) )
game/server/ai_speech.cpp:		h.timeSpoken = gpGlobals->curtime;
game/server/ai_speech.cpp:	slot->timeSpoken = gpGlobals->curtime;
game/server/ai_speech.cpp:			set.AppendCriteria( "timesincecombat", UTIL_VarArgs( "%f", gpGlobals->curtime - pSpeaker->GetLastEnemyTime() ) );
game/server/env_screenoverlay.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/env_screenoverlay.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/team_train_watcher.cpp:		SetContextThink( &CTeamTrainWatcherMaster::TWMThink, gpGlobals->curtime + 0.2, TWMASTER_THINK );
game/server/team_train_watcher.cpp:	SetContextThink( &CTeamTrainWatcherMaster::TWMThink, gpGlobals->curtime + 0.2, TWMASTER_THINK );
game/server/team_train_watcher.cpp:				SetContextThink( &CTeamTrainWatcherMaster::TWMThink, gpGlobals->curtime + 0.2, TWMASTER_THINK );
game/server/team_train_watcher.cpp:			m_flRecedeStartTime = gpGlobals->curtime;
game/server/team_train_watcher.cpp:		float flRecedeTimeRemaining = m_flRecedeTime - gpGlobals->curtime;
game/server/team_train_watcher.cpp:			m_flRecedeStartTime = gpGlobals->curtime;
game/server/team_train_watcher.cpp:	SetContextThink( &CTeamTrainWatcher::WatcherThink, gpGlobals->curtime + 0.1, TW_THINK );
game/server/team_train_watcher.cpp:		m_flAlarmEndTime = gpGlobals->curtime + MAX_ALARM_TIME_NO_RECEDE;
game/server/team_train_watcher.cpp:		if ( m_flRecedeTime < gpGlobals->curtime )
game/server/team_train_watcher.cpp:		if ( m_iTrainSpeedLevel > 0 && m_flNextSpeakForwardConceptTime < gpGlobals->curtime )
game/server/team_train_watcher.cpp:				for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/team_train_watcher.cpp:			m_flNextSpeakForwardConceptTime = gpGlobals->curtime + 3.0;
game/server/team_train_watcher.cpp:							if ( m_flAlarmEndTime > 0 && m_flAlarmEndTime < gpGlobals->curtime )
game/server/team_train_watcher.cpp:								SetContextThink( &CTeamTrainWatcher::WatcherAlarmThink, gpGlobals->curtime + TW_ALARM_THINK_INTERVAL, TW_ALARM_THINK );
game/server/team_train_watcher.cpp:	SetContextThink( &CTeamTrainWatcher::WatcherThink, gpGlobals->curtime + 0.1, TW_THINK );
game/server/team_train_watcher.cpp:	SetContextThink( &CTeamTrainWatcher::WatcherAlarmThink, gpGlobals->curtime + TW_ALARM_THINK_INTERVAL, TW_ALARM_THINK );
game/server/env_effectsscript.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/env_effectsscript.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/ai_planesolver.cpp:		m_TimeLastProgress = gpGlobals->curtime;
game/server/ai_planesolver.cpp:			m_TimeLastProgress = gpGlobals->curtime;
game/server/ai_planesolver.cpp:			if ( gpGlobals->curtime - m_TimeLastProgress > 0.75 )
game/server/point_spotlight.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/point_spotlight.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/point_spotlight.cpp:		SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/point_spotlight.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/weight_button.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/weight_button.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/logicentities.cpp:	SetNextThink( gpGlobals->curtime + m_flRefireTime );
game/server/logicentities.cpp:	if ( ( flNextThink - gpGlobals->curtime ) <= inputdata.value.Float() )
game/server/logicentities.cpp:		SetNextThink( gpGlobals->curtime );
game/server/logicentities.cpp:			Q_snprintf( tempstr, sizeof( tempstr ), "      firing in: %.2f sec", flNextThink - gpGlobals->curtime );
game/server/logicentities.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/logicentities.cpp:		SetNextThink( gpGlobals->curtime + 10 );
game/server/logicentities.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/logicentities.cpp:		GlobalEntity_Add( szGlobal, STRING( gpGlobals->mapname ), ( GLOBALESTATE )nState );
game/server/logicentities.cpp:			GlobalEntity_Add( m_globalstate, gpGlobals->mapname, (GLOBALESTATE)m_initialstate );
game/server/logicentities.cpp:		GlobalEntity_Add( m_globalstate, gpGlobals->mapname, GLOBAL_ON );
game/server/logicentities.cpp:		GlobalEntity_Add( m_globalstate, gpGlobals->mapname, GLOBAL_OFF );
game/server/logicentities.cpp:		GlobalEntity_Add( m_globalstate, gpGlobals->mapname, GLOBAL_DEAD );
game/server/logicentities.cpp:		GlobalEntity_Add( m_globalstate, gpGlobals->mapname, GLOBAL_ON );
game/server/logicentities.cpp:		GlobalEntity_Add( m_globalstate, gpGlobals->mapname, GLOBAL_ON );
game/server/logicentities.cpp:		GlobalEntity_Add( m_globalstate, gpGlobals->mapname, GLOBAL_ON );
game/server/logicentities.cpp:		GlobalEntity_Add( m_globalstate, gpGlobals->mapname, newState );
game/server/logicentities.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/logicentities.cpp:	if ( g_ServerGameDLL.m_fAutoSaveDangerousTime != 0.0f && g_ServerGameDLL.m_fAutoSaveDangerousTime >= gpGlobals->curtime )
game/server/logicentities.cpp:		if ( pPlayer->GetDeathTime() == 0.0f || pPlayer->GetDeathTime() > gpGlobals->curtime )
game/server/logicentities.cpp:		g_ServerGameDLL.m_fAutoSaveDangerousTime = gpGlobals->curtime + inputdata.value.Float();
game/server/logicentities.cpp:		SetNextThink( gpGlobals->curtime );
game/server/logicentities.cpp:					m_flStartTime = gpGlobals->curtime;
game/server/logicentities.cpp:				else if ( m_flTimeToTrigger > 0 && gpGlobals->curtime - m_flStartTime > m_flTimeToTrigger )
game/server/logicentities.cpp:		SetNextThink( gpGlobals->curtime + thinkInterval );
game/server/point_playermoveconstraint.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/point_playermoveconstraint.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/point_playermoveconstraint.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/ai_looktarget.h:	bool IsAvailable() { return (gpGlobals->curtime > m_flTimeNextAvailable); }
game/server/fogcontroller.cpp:	m_fog.lerptime = gpGlobals->curtime + m_fog.duration + 0.1;
game/server/fogcontroller.cpp:    SetNextThink( gpGlobals->curtime + m_fog.duration );
game/server/fogcontroller.cpp:	m_fog.lerptime = gpGlobals->curtime;
game/server/fogcontroller.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/ai_dynamiclink.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.0f, 1.0f) );
game/server/ai_dynamiclink.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/ai_behavior_standoff.cpp:			SetNextThink( gpGlobals->curtime + AIBL_THINK_INTERVAL );
game/server/ai_behavior_standoff.cpp:			SetNextThink( gpGlobals->curtime + AIBL_THINK_INTERVAL );
game/server/ai_behavior_standoff.cpp:		SetNextThink( gpGlobals->curtime + AIBL_THINK_INTERVAL );
game/server/ai_behavior_standoff.cpp:			     gpGlobals->curtime  - pEnemyInfo->timeLastSeen > m_params.flAbandonTimeLimit ) ||
game/server/ai_behavior_standoff.cpp:			     gpGlobals->curtime  - pEnemyInfo->timeFirstSeen > m_params.flAbandonTimeLimit * 2 ) ) )
game/server/ai_behavior_standoff.cpp:					GetOuter()->m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/BaseAnimatingOverlay.cpp:	m_flLastAccess = gpGlobals->curtime;
game/server/BaseAnimatingOverlay.cpp:	if (IsActive() && !IsAutokill() && !IsKillMe() && m_flLastAccess > 0.0 && (gpGlobals->curtime - m_flLastAccess > 0.2)) 
game/server/BaseAnimatingOverlay.cpp:	m_flLastAccess = gpGlobals->curtime;
game/server/BaseAnimatingOverlay.cpp:					Msg(" %d abandoned %.2f (%.2f)\n", i, gpGlobals->curtime, m_AnimOverlay[ i ].m_flLastAccess );
game/server/BaseAnimatingOverlay.cpp:	boneSetup.AccumulatePose( pos, q, GetSequence(), GetCycle(), 1.0, gpGlobals->curtime, m_pIk );
game/server/BaseAnimatingOverlay.cpp:			boneSetup.AccumulatePose( pos, q, pLayer.m_nSequence, pLayer.m_flCycle, pLayer.m_flWeight, gpGlobals->curtime, m_pIk );
game/server/BaseAnimatingOverlay.cpp:		auto_ik.Init( pStudioHdr, GetAbsAngles(), GetAbsOrigin(), gpGlobals->curtime, 0, boneMask );
game/server/BaseAnimatingOverlay.cpp:		boneSetup.CalcAutoplaySequences( pos, q, gpGlobals->curtime, &auto_ik );
game/server/BaseAnimatingOverlay.cpp:		boneSetup.CalcAutoplaySequences( pos, q, gpGlobals->curtime, NULL );
game/server/BaseAnimatingOverlay.cpp:			Msg("%5.3f : adding %d (%d): %s : %5.3f (%.3f)\n", gpGlobals->curtime, i, m_AnimOverlay[ i ].m_nOrder.Get(), GetSequenceName( m_AnimOverlay[ i ].m_nSequence ), m_AnimOverlay[ i ].m_flCycle.Get(), m_AnimOverlay[ i ].m_flWeight.Get() );
game/server/entitylist.cpp:			if ( m_simThinkList[i].nextThinkTick <= gpGlobals->tickcount )
game/server/portal/prop_telescopic_arm.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/portal/prop_telescopic_arm.cpp:	SetNextThink( gpGlobals->curtime + 1.0 );
game/server/portal/prop_telescopic_arm.cpp:		for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/prop_telescopic_arm.cpp:			for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/prop_telescopic_arm.cpp:				for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/prop_telescopic_arm.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/portal/prop_telescopic_arm.cpp:		SetNextThink( gpGlobals->curtime + TELESCOPE_DISABLE_TIME );
game/server/portal/prop_telescopic_arm.cpp:		SetNextThink( gpGlobals->curtime + TELESCOPE_ENABLE_TIME );
game/server/portal/prop_telescopic_arm.cpp:	for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/prop_telescopic_arm.cpp:		for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/prop_telescopic_arm.cpp:			for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/portal_gamestats.cpp:	if( fLastUseTime > gpGlobals->curtime ) //I'm not positive, but I think curtime resets between levels, cheap to do this
game/server/portal/portal_gamestats.cpp:	if( (gpGlobals->curtime - fLastUseTime) < 0.25f ) //use events cluster
game/server/portal/portal_gamestats.cpp:	fLastUseTime = gpGlobals->curtime;
game/server/portal/portal_gamestats.cpp:	if( fLastStuckTime > gpGlobals->curtime ) //I'm not positive, but I think curtime resets between levels, cheap to do this
game/server/portal/portal_gamestats.cpp:	if( (gpGlobals->curtime - fLastStuckTime) < 10.0f ) //only log one stuck spot per 10 second interval (in case it oscillates)
game/server/portal/portal_gamestats.cpp:	fLastStuckTime = gpGlobals->curtime;
game/server/portal/portal_gamestats.cpp:	m_pCurrentMapStats = FindOrAddMapStats( STRING( gpGlobals->mapname ) );
game/server/portal/portal_mp_client.cpp:	if (gpGlobals->coop || gpGlobals->deathmatch)
game/server/portal/portal_mp_client.cpp:	gpGlobals->teamplay = (teamplay.GetInt() != 0);
game/server/portal/portal_player.h:	void SetNeuroToxinDamageTime( float fCountdownSeconds ) { m_fNeuroToxinDamageTime = gpGlobals->curtime + fCountdownSeconds; }
game/server/portal/Portal_CustomStatsVisualizer.cpp:	m_fRefreshTimer = gpGlobals->curtime;
game/server/portal/Portal_CustomStatsVisualizer.cpp:	m_pCurrentMapStats = FindOrAddMapStats( STRING( gpGlobals->mapname ) );
game/server/portal/Portal_CustomStatsVisualizer.cpp:	if( m_fRefreshTimer > gpGlobals->curtime )
game/server/portal/Portal_CustomStatsVisualizer.cpp:	m_fRefreshTimer = gpGlobals->curtime + PORTALSTATSVISUALIZER_REFRESHTIME;
game/server/portal/prop_energy_ball.cpp:			float fTimeLeft = fCurTimeTillDeath - gpGlobals->curtime;
game/server/portal/prop_energy_ball.cpp:			SetContextThink( &CPropCombineBall::ExplodeThink, gpGlobals->curtime + fTimeToDie, "ExplodeTimerContext" );
game/server/portal/prop_energy_ball.cpp:		m_fTimeTillDeath = GetNextThink( "ExplodeTimerContext" ) - gpGlobals->curtime;
game/server/portal/prop_energy_ball.cpp:		SetNextThink ( gpGlobals->curtime + 0.5f );
game/server/portal/prop_energy_ball.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/portal/prop_energy_ball.cpp:	SetContextThink( &CPropCombineBall::SUB_Remove, gpGlobals->curtime + 0.5f, "RemoveContext" );
game/server/portal/prop_energy_ball.cpp:		SetContextThink( &CPropCombineBall::ExplodeThink, gpGlobals->curtime, "ExplodeTimerContext" );
game/server/portal/prop_energy_ball.cpp:	pBall->SetNextThink ( gpGlobals->curtime + 0.1f );
game/server/portal/prop_energy_ball.cpp:		pBall->SetNextThink ( gpGlobals->curtime + 0.1f );
game/server/portal/npc_portal_turret_ground.cpp:	m_flTimeNextShoot = gpGlobals->curtime;
game/server/portal/npc_portal_turret_ground.cpp:	m_flTimeNextPing = gpGlobals->curtime;
game/server/portal/npc_portal_turret_ground.cpp:	m_flTimeNextShoot = gpGlobals->curtime + 0.09;
game/server/portal/npc_portal_turret_ground.cpp:	if( gpGlobals->curtime >= m_flTimeNextPing )
game/server/portal/npc_portal_turret_ground.cpp:		m_flTimeNextPing = gpGlobals->curtime + 1.0f;
game/server/portal/npc_portal_turret_ground.cpp:	scanAngle.y += (m_fViewconeDegrees / 2.0f) * sin( gpGlobals->curtime * 6.0f );
game/server/portal/prop_glados_core.cpp:	SetContextThink( &CPropGladosCore::AnimateThink, gpGlobals->curtime + 0.1f, s_pAnimateThinkContext );
game/server/portal/prop_glados_core.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/prop_glados_core.cpp:		SetNextThink( gpGlobals->curtime );
game/server/portal/prop_glados_core.cpp:	SetNextThink( gpGlobals->curtime + m_flBetweenVOPadding + flCurDuration );
game/server/portal/prop_glados_core.cpp:	SetNextThink( gpGlobals->curtime + m_flBetweenVOPadding + flDelay );
game/server/portal/prop_glados_core.cpp:		SetNextThink( gpGlobals->curtime );
game/server/portal/prop_glados_core.cpp:	SetNextThink( gpGlobals->curtime + m_flBetweenVOPadding + flCurDuration );
game/server/portal/prop_glados_core.cpp:	SetContextThink( &CPropGladosCore::AnimateThink, gpGlobals->curtime + 0.1f, s_pAnimateThinkContext );
game/server/portal/trigger_portal_cleanser.cpp:					if ( pPortal && pPortal->GetNextThink( s_pDelayedPlacementContext ) > gpGlobals->curtime )
game/server/portal/trigger_portal_cleanser.cpp:						pPortal->SetContextThink( NULL, gpGlobals->curtime, s_pDelayedPlacementContext ); 
game/server/portal/trigger_portal_cleanser.cpp:					if ( pPortal && pPortal->GetNextThink( s_pDelayedPlacementContext ) > gpGlobals->curtime )
game/server/portal/trigger_portal_cleanser.cpp:						pPortal->SetContextThink( NULL, gpGlobals->curtime, s_pDelayedPlacementContext ); 
game/server/portal/trigger_portal_cleanser.cpp:			pDisolvingAnimating->Dissolve( "", gpGlobals->curtime, false, ENTITY_DISSOLVE_NORMAL );
game/server/portal/PhysicsCloneArea.cpp:		DevMsg( "PortalCloneArea %i Start Touch: %s : %f\n", ((m_pAttachedPortal->m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime );
game/server/portal/PhysicsCloneArea.cpp:		ADD_DEBUG_HISTORY( HISTORY_PLAYER_DAMAGE, UTIL_VarArgs( "PortalCloneArea %i Start Touch: %s : %f\n", ((m_pAttachedPortal->m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime  ) );
game/server/portal/PhysicsCloneArea.cpp:		DevMsg( "PortalCloneArea %i End Touch: %s : %f\n", ((m_pAttachedPortal->m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime );
game/server/portal/PhysicsCloneArea.cpp:		ADD_DEBUG_HISTORY( HISTORY_PLAYER_DAMAGE, UTIL_VarArgs( "PortalCloneArea %i End Touch: %s : %f\n", ((m_pAttachedPortal->m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime ) );
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1f, 0.3f ) );
game/server/portal/npc_security_camera.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime );
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime );
game/server/portal/npc_security_camera.cpp:		m_flLastSight = gpGlobals->curtime + SECURITY_CAMERA_MAX_WAIT;	
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_security_camera.cpp:		if ( gpGlobals->curtime > m_flLastSight )
game/server/portal/npc_security_camera.cpp:		m_flLastSight = gpGlobals->curtime + 0.5f;
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_security_camera.cpp:		for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/npc_security_camera.cpp:	if ( m_flPingTime > gpGlobals->curtime )
game/server/portal/npc_security_camera.cpp:	m_flPingTime = gpGlobals->curtime + SECURITY_CAMERA_PING_TIME;
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_security_camera.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:		SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:			if ( (gpGlobals->curtime - m_flTimeLastFired) > ROCKET_TURRET_ROCKET_FIRE_COOLDOWN_TIME )
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:		EmitSound ( ROCKET_TURRET_SOUND_LOCKING, gpGlobals->curtime + ROCKET_TURRET_QUARTER_LOCKON_TIME );
game/server/portal/npc_rocket_turret.cpp:		EmitSound ( ROCKET_TURRET_SOUND_LOCKED, gpGlobals->curtime + ROCKET_TURRET_HALF_LOCKON_TIME );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:		if ( (gpGlobals->curtime - m_flTimeLastFired) > ROCKET_PROJECTILE_DEFAULT_LIFE )
game/server/portal/npc_rocket_turret.cpp:			m_flTimeLastFired = gpGlobals->curtime;
game/server/portal/npc_rocket_turret.cpp:		m_flTimeLastFired = gpGlobals->curtime;
game/server/portal/npc_rocket_turret.cpp:	m_flTimeLastFired = gpGlobals->curtime;
game/server/portal/npc_rocket_turret.cpp:	m_flTimeLastFired = gpGlobals->curtime;
game/server/portal/npc_rocket_turret.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + RandomFloat( 2.0f, 8.0f ) );
game/server/portal/npc_rocket_turret.cpp:	if ( gpGlobals->tickcount != m_muzzleToWorldTick )
game/server/portal/npc_rocket_turret.cpp:		m_muzzleToWorldTick = gpGlobals->tickcount;
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + ROCKET_TURRET_THINK_RATE );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/portal/npc_rocket_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_rocket_turret.cpp:		Dissolve( NULL, gpGlobals->curtime + 0.1f, false, ENTITY_DISSOLVE_NORMAL );
game/server/portal/weapon_physcannon.cpp:	m_timeToArrive = gpGlobals->frametime;
game/server/portal/weapon_physcannon.cpp:					m_pPlayer->SetNextAttack( gpGlobals->curtime + 0.5f );
game/server/portal/weapon_physcannon.cpp:	m_flTimeNextObjectPurge = gpGlobals->curtime;
game/server/portal/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/portal/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/portal/weapon_physcannon.cpp:	m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/portal/weapon_physcannon.cpp:	m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	if( m_flNextPrimaryAttack > gpGlobals->curtime )
game/server/portal/weapon_physcannon.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	if ( m_flNextSecondaryAttack > gpGlobals->curtime )
game/server/portal/weapon_physcannon.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/portal/weapon_physcannon.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/server/portal/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.1f;
game/server/portal/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.01f;
game/server/portal/weapon_physcannon.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.4f;
game/server/portal/weapon_physcannon.cpp:	if( gpGlobals->curtime >= m_flTimeNextObjectPurge )
game/server/portal/weapon_physcannon.cpp:		m_flTimeNextObjectPurge = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	if ( m_flCheckSuppressTime > gpGlobals->curtime )
game/server/portal/weapon_physcannon.cpp:	if ( ( m_flElementDebounce < gpGlobals->curtime ) && ( m_nChangeState == ELEMENT_STATE_NONE ) )
game/server/portal/weapon_physcannon.cpp:		m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/portal/weapon_physcannon.cpp:	SetContextThink( &CWeaponPhysCannon::WaitForUpgradeThink, gpGlobals->curtime + 6.0f, s_pWaitForUpgradeContext );
game/server/portal/weapon_physcannon.cpp:		SetContextThink( &CWeaponPhysCannon::WaitForUpgradeThink, gpGlobals->curtime + 0.1f, s_pWaitForUpgradeContext );
game/server/portal/weapon_physcannon.cpp:		GlobalEntity_Add( MAKE_STRING("super_phys_gun"), gpGlobals->mapname, GLOBAL_ON );
game/server/portal/weapon_physcannon.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pWaitForUpgradeContext );
game/server/portal/weapon_physcannon.cpp:				pCore->SetNextThink( gpGlobals->curtime + 10.0f );
game/server/portal/weapon_physcannon.cpp:				m_flEndSpritesOverride[sprite] = gpGlobals->curtime + lifetime;
game/server/portal/weapon_physcannon.cpp:		if ( ( m_flElementDebounce < gpGlobals->curtime ) && ( m_nChangeState != ELEMENT_STATE_NONE ) )
game/server/portal/weapon_physcannon.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/portal/weapon_physcannon.cpp:		m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/portal/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.1f;
game/server/portal/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/portal/weapon_physcannon.cpp:			if ( m_flEndSpritesOverride[i] < gpGlobals->curtime )
game/server/portal/weapon_physcannon.cpp:	thrown.fTimeThrown = gpGlobals->curtime;
game/server/portal/weapon_physcannon.cpp:			else if( gpGlobals->curtime > (m_ThrownEntities[i].fTimeThrown + PHYSCANNON_THROWN_LIST_TIMEOUT) )
game/server/portal/weapon_physcannon.cpp:	for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/weapon_portalgun.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/portal/weapon_portalgun.cpp:	fxData.m_flScale = gpGlobals->curtime + fDelay;
game/server/portal/weapon_portalgun.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/weapon_portalgun.cpp:		m_fEffectsMaxSize1 -= gpGlobals->frametime * 400.0f;
game/server/portal/weapon_portalgun.cpp:		m_fEffectsMaxSize2 -= gpGlobals->frametime * 400.0f;
game/server/portal/weapon_portalgun.cpp:		pPortal->SetContextThink( &CProp_Portal::DelayedPlacementThink, gpGlobals->curtime + fDelay, s_pDelayedPlacementContext ); 
game/server/portal/env_lightrail_endpoint.cpp:		m_flStartTime = gpGlobals->curtime;
game/server/portal/env_lightrail_endpoint.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/portal/env_lightrail_endpoint.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/portal/env_lightrail_endpoint.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/portal/env_lightrail_endpoint.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/portal/env_lightrail_endpoint.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/portal/portal_player.cpp:	m_fTimeLastNumSecondsUpdate = gpGlobals->curtime;
game/server/portal/portal_player.cpp:		m_flExpressionLoopTime = gpGlobals->curtime + RandomFloat(30,40);
game/server/portal/portal_player.cpp:	m_flExpressionLoopTime = gpGlobals->curtime + flDuration;
game/server/portal/portal_player.cpp:	m_flExpressionLoopTime = gpGlobals->curtime;
game/server/portal/portal_player.cpp:		if ( gpGlobals->curtime > m_fTimeLastHurt + sv_regeneration_wait_time.GetFloat() )
game/server/portal/portal_player.cpp:	if ( IsAlive() && m_flExpressionLoopTime >= 0 && gpGlobals->curtime > m_flExpressionLoopTime )
game/server/portal/portal_player.cpp:		Vector vNewPos = GetAbsOrigin() + vForward * gpGlobals->frametime * -1000.0f;
game/server/portal/portal_player.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/portal_player.cpp:		if ( fAnyButtonDown || gpGlobals->curtime < m_flDeathTime + DEATH_ANIMATION_TIME )
game/server/portal/portal_player.cpp:	if ( g_pGameRules->IsMultiplayer() && ( gpGlobals->curtime > (m_flDeathTime + DEATH_ANIMATION_TIME) ) && !IsObserver() )
game/server/portal/portal_player.cpp:		&& !( g_pGameRules->IsMultiplayer() && forcerespawn.GetInt() > 0 && (gpGlobals->curtime > (m_flDeathTime + 5))) )
game/server/portal/portal_player.cpp:		m_pIk->Init( pStudioHdr, GetAbsAngles(), adjOrigin, gpGlobals->curtime, m_iIKCounter, boneMask );
game/server/portal/portal_player.cpp:		CalculateIKLocks( gpGlobals->curtime );
game/server/portal/portal_player.cpp:		pRagdoll->m_flAnimTime = gpGlobals->curtime;
game/server/portal/portal_player.cpp:			m_hRagdoll->GetBaseAnimating()->Dissolve( NULL, gpGlobals->curtime, false, ENTITY_DISSOLVE_NORMAL );
game/server/portal/portal_player.cpp:		m_fTimeLastHurt = gpGlobals->curtime;
game/server/portal/portal_player.cpp:	float fSecondsSinceLastUpdate = ( gpGlobals->curtime - m_fTimeLastNumSecondsUpdate );
game/server/portal/portal_player.cpp:	m_fTimeLastNumSecondsUpdate = gpGlobals->curtime;
game/server/portal/portal_player.cpp:		float fTimeRemaining = m_fNeuroToxinDamageTime - gpGlobals->curtime;
game/server/portal/portal_player.cpp:			info.SetDamage( gpGlobals->frametime * 50.0f );
game/server/portal/portal_player.cpp:	//m_flSlamProtectTime = gpGlobals->curtime + 0.5;
game/server/portal/npc_portal_turret_floor.cpp:		if ( gpGlobals->curtime > m_fNextTalk )
game/server/portal/npc_portal_turret_floor.cpp:			m_fNextTalk = gpGlobals->curtime + 3.0f;
game/server/portal/npc_portal_turret_floor.cpp:		m_fNextTalk = gpGlobals->curtime -1.0f;
game/server/portal/npc_portal_turret_floor.cpp:	if ( gpGlobals->curtime > m_fNextTalk && m_iLastState != iNewState )
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 1.75f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 1.75f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 2.5f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 1.5f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 1.75f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 3.5f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 1.15f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 2.25f;
game/server/portal/npc_portal_turret_floor.cpp:				m_fNextTalk = gpGlobals->curtime + 10.0f;	// Never going to talk again
game/server/portal/npc_portal_turret_floor.cpp:	if ( m_iLastState == TURRET_ACTIVE && gpGlobals->curtime > m_fNextTalk )
game/server/portal/npc_portal_turret_floor.cpp:		m_fNextTalk = gpGlobals->curtime + 2.5f;
game/server/portal/npc_portal_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/portal/npc_portal_turret_floor.cpp:		m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_MAX_WAIT;
game/server/portal/npc_portal_turret_floor.cpp:			m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_SHORT_WAIT;
game/server/portal/npc_portal_turret_floor.cpp:			m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_MAX_WAIT;
game/server/portal/npc_portal_turret_floor.cpp:		m_flLastSight = gpGlobals->curtime + 2.0f;
game/server/portal/npc_portal_turret_floor.cpp:	if ( m_flShotTime < gpGlobals->curtime )
game/server/portal/npc_portal_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/portal/npc_portal_turret_floor.cpp:		m_flShotTime = gpGlobals->curtime + fDistanceRatio * fDistanceRatio * PORTAL_FLOOR_TURRET_MAX_SHOT_DELAY;
game/server/portal/npc_portal_turret_floor.cpp:		if ( gpGlobals->curtime > m_flNextActivateSoundTime )
game/server/portal/npc_portal_turret_floor.cpp:			m_flNextActivateSoundTime = gpGlobals->curtime + 3.0;
game/server/portal/npc_portal_turret_floor.cpp:	if ( gpGlobals->curtime > m_flLastSight )
game/server/portal/npc_portal_turret_floor.cpp:	m_vecGoalAngles.x = GetAbsAngles().x + ( sin( ( m_flLastSight + gpGlobals->curtime * m_fSearchSpeed ) * 1.5f ) * 20.0f );
game/server/portal/npc_portal_turret_floor.cpp:	m_vecGoalAngles.y = GetAbsAngles().y + ( sin( ( m_flLastSight + gpGlobals->curtime * m_fSearchSpeed ) * 2.5f ) * 20.0f );
game/server/portal/npc_portal_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/portal/npc_portal_turret_floor.cpp:	if ( gpGlobals->curtime < m_flThrashTime && !IsDissolving() )
game/server/portal/npc_portal_turret_floor.cpp:		if ( m_flShotTime < gpGlobals->curtime )
game/server/portal/npc_portal_turret_floor.cpp:			m_flShotTime = gpGlobals->curtime + 0.05f;
game/server/portal/npc_portal_turret_floor.cpp:				SetNextThink( gpGlobals->curtime + 1.0f );
game/server/portal/npc_portal_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/portal/npc_portal_turret_floor.cpp:		m_fNextTalk = gpGlobals->curtime + 1.25f;
game/server/portal/npc_portal_turret_floor.cpp:		if ( m_flShotTime < gpGlobals->curtime )
game/server/portal/npc_portal_turret_floor.cpp:			m_flShotTime = gpGlobals->curtime + RandomFloat( 0.25f, 0.75f );
game/server/portal/npc_portal_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/portal/npc_portal_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.5 );
game/server/portal/npc_portal_turret_floor.cpp:			m_fMovingTargetThreashold += gpGlobals->curtime * 15.0f;
game/server/portal/npc_portal_turret_floor.cpp:					pPortalFloor->m_fNextTalk = gpGlobals->curtime + 1.2f;
game/server/portal/npc_portal_turret_floor.cpp:					m_fNextTalk = gpGlobals->curtime + 0.6f;
game/server/portal/npc_portal_turret_floor.cpp:	if ( m_flShotTime < gpGlobals->curtime )
game/server/portal/func_liquidportal.cpp:	AssertMsg( m_fFillEndTime <= gpGlobals->curtime, "Fill already in progress." );
game/server/portal/func_liquidportal.cpp:	m_fFillStartTime = gpGlobals->curtime;
game/server/portal/func_liquidportal.cpp:	m_fFillEndTime = gpGlobals->curtime + m_fFillTime;
game/server/portal/func_liquidportal.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/portal/func_liquidportal.cpp:		if( gpGlobals->curtime < m_fFillEndTime )
game/server/portal/func_liquidportal.cpp:			float fInterp = ((gpGlobals->curtime - m_fFillStartTime) / (m_fFillEndTime - m_fFillStartTime));
game/server/portal/func_liquidportal.cpp:			SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/portal/portal_client.cpp:	if (gpGlobals->coop || gpGlobals->deathmatch)
game/server/portal/portal_client.cpp:	gpGlobals->teamplay = (teamplay.GetInt() != 0);
game/server/portal/portal_client.cpp:	if ( !gpGlobals->deathmatch )
game/server/portal/portal_radio.cpp:	if ( gpGlobals->eLoadType == MapLoad_LoadGame )
game/server/portal/portal_radio.cpp:		if ( V_strcmp( STRING(gpGlobals->mapname), loc.mapname ) == 0 )
game/server/portal/portal_radio.cpp:	if ( V_strcmp( STRING(gpGlobals->mapname), "testchmb_a_02" ) == 0 )
game/server/portal/prop_portal.cpp:	SetContextThink( &CProp_Portal::TestRestingSurfaceThink, gpGlobals->curtime + 0.1f, s_pTestRestingSurfaceContext );
game/server/portal/prop_portal.cpp:		SetContextThink ( &CProp_Portal::TestRestingSurfaceThink, gpGlobals->curtime + 0.1f, s_pTestRestingSurfaceContext );
game/server/portal/prop_portal.cpp:	SetContextThink( &CProp_Portal::FizzleThink, gpGlobals->curtime, s_pFizzleThink );
game/server/portal/prop_portal.cpp:	for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/portal/prop_portal.cpp:			Msg( "Portal %i not teleporting %s because it's not simulated by this portal. : %f \n", ((m_bIsPortal2)?(2):(1)), pOther->GetDebugName(), gpGlobals->curtime );
game/server/portal/prop_portal.cpp:		DevMsg( "Portal %i StartTouch: %s : %f\n", ((m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime );
game/server/portal/prop_portal.cpp:		ADD_DEBUG_HISTORY( HISTORY_PLAYER_DAMAGE, UTIL_VarArgs( "Portal %i StartTouch: %s : %f\n", ((m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime ) );
game/server/portal/prop_portal.cpp:		DevMsg( "Portal %i EndTouch: %s : %f\n", ((m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime );
game/server/portal/prop_portal.cpp:		ADD_DEBUG_HISTORY( HISTORY_PLAYER_DAMAGE, UTIL_VarArgs( "Portal %i EndTouch: %s : %f\n", ((m_bIsPortal2)?(2):(1)), pOther->GetClassname(), gpGlobals->curtime ) );
game/server/basemultiplayerplayer.h:	void SetLastForcedChangeTeamTimeToNow( void ) { m_flLastForcedChangeTeamTime = gpGlobals->curtime; }
game/server/basemultiplayerplayer.cpp:	m_flConnectionTime = gpGlobals->curtime;
game/server/basemultiplayerplayer.cpp:		m_RateLimitLastCommandTimes.Insert( pcmd, gpGlobals->curtime );
game/server/basemultiplayerplayer.cpp:	else if ( (gpGlobals->curtime - m_RateLimitLastCommandTimes[i]) < COMMAND_MAX_RATE )
game/server/basemultiplayerplayer.cpp:		m_RateLimitLastCommandTimes[i] = gpGlobals->curtime;
game/server/basemultiplayerplayer.cpp:	float flTimeConnected = gpGlobals->curtime - m_flConnectionTime;
game/server/basemultiplayerplayer.cpp:	if ( flLastSwitchedTime > 0 && ( gpGlobals->curtime - flLastSwitchedTime ) < 300 )
game/server/basemultiplayerplayer.cpp:	SetContextThink( &CBaseMultiplayerPlayer::EscortScoringThink, gpGlobals->curtime + ESCORT_SCORE_INTERVAL, ESCORT_SCORE_CONTEXT );	
game/server/basemultiplayerplayer.cpp:	SetContextThink( &CBaseMultiplayerPlayer::EscortScoringThink, gpGlobals->curtime + ESCORT_SCORE_INTERVAL, ESCORT_SCORE_CONTEXT );
game/server/EntityParticleTrail.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/EntityParticleTrail.cpp:		SetContextThink( ZapThink, gpGlobals->curtime + random->RandomFloat( 0.1f, 0.3f ), s_pZapContext ); 
game/server/EntityParticleTrail.cpp:		SetContextThink( NULL, gpGlobals->curtime, s_pRetireContext );
game/server/EntityParticleTrail.cpp:		SetContextThink( &CEntityParticleTrail::SUB_Remove, gpGlobals->curtime + m_Info.m_flLifetime, s_pRetireContext );
game/server/EntityParticleTrail.cpp:			SetContextThink( &CEntityParticleTrail::SUB_Remove, gpGlobals->curtime + m_Info.m_flLifetime, s_pRetireContext );
game/server/ai_sentence.cpp:		DevMsg( "SENTENCE [%d %.2f] %s: %s\n", GetOuter()->entindex(), gpGlobals->curtime, pStatus, pSentence );
game/server/ai_sentence.cpp:		DevMsg( GetOuter(), "SENTENCE [%d %.2f] %s: %s\n", GetOuter()->entindex(), gpGlobals->curtime, pStatus, pSentence );
game/server/ai_sentence.cpp:	if ( m_flQueueTimeout < gpGlobals->curtime )
game/server/ai_sentence.cpp:	m_flQueueTimeout = gpGlobals->curtime + nSquadCount * 2.0f;
game/server/env_player_surface_trigger.cpp:		SetNextThink( gpGlobals->curtime );
game/server/nav_merge.cpp:		V_strncpy( fname, STRING( gpGlobals->mapname ), sizeof( fname ) );
game/server/EnvBeam.cpp:		SetNextThink( gpGlobals->curtime );
game/server/EnvBeam.cpp:		SetFireTime( gpGlobals->curtime );
game/server/EnvBeam.cpp:			SetNextThink( gpGlobals->curtime + 1.0f );
game/server/EnvBeam.cpp:		SetNextThink( gpGlobals->curtime );
game/server/EnvBeam.cpp:		SetFireTime( gpGlobals->curtime );
game/server/EnvBeam.cpp:		SetNextThink( gpGlobals->curtime );
game/server/EnvBeam.cpp:			SetNextThink( gpGlobals->curtime + m_life + random->RandomFloat( 0, m_restrike ) );
game/server/EnvBeam.cpp:			SetNextThink( gpGlobals->curtime + m_life + m_restrike );
game/server/EnvBeam.cpp:	if ( ( m_flDamage > 0 ) && ( gpGlobals->curtime >= m_flFireTime + 0.1 ) )
game/server/EnvBeam.cpp:	SetNextThink( gpGlobals->curtime );
game/server/physobj.cpp:	if ( eventType != NOTIFY_EVENT_TELEPORT || (unsigned int)gpGlobals->tickcount == m_teleportTick )
game/server/physobj.cpp:	m_teleportTick = gpGlobals->tickcount;
game/server/physobj.cpp:	if ( m_flNextSuckTime > gpGlobals->curtime )
game/server/physobj.cpp:	m_flNextSuckTime = gpGlobals->curtime + 2.0;
game/server/physobj.cpp:		SetNextThink( gpGlobals->curtime + 0.05f );
game/server/physobj.cpp:				pPhys->ApplyForceCenter( m_flMagnitude * flFalloff * 100.0f * vecPushDir * pPhys->GetMass() * gpGlobals->frametime );
game/server/physobj.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/physobj.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/physobj.cpp:	SetNextThink( gpGlobals->curtime );
game/server/ai_utils.cpp:		m_flNextShotTime = gpGlobals->curtime;
game/server/ai_utils.cpp:		m_flNextShotTime = gpGlobals->curtime + random->RandomFloat( m_flMinRestInterval, m_flMaxRestInterval );
game/server/ai_utils.cpp:	return ( !m_bDisabled && (m_flNextShotTime <= gpGlobals->curtime) ); 
game/server/ai_utils.cpp:		if ( m_flNextShotTime < gpGlobals->curtime )
game/server/ai_utils.cpp:			m_flNextShotTime = gpGlobals->curtime;
game/server/ai_utils.cpp:		if ( timePlayerLastSeen == AI_INVALID_TIME || gpGlobals->curtime - timePlayerLastSeen > .15 ) // If didn't see the player last think
game/server/ai_utils.cpp:					if ( ( timePlayerLastSeen == AI_INVALID_TIME || gpGlobals->curtime - timePlayerLastSeen > m_Params.timeToTrigger ) &&
game/server/ai_utils.cpp:						 ( lastTimeDamagedBy == AI_INVALID_TIME || gpGlobals->curtime - lastTimeDamagedBy > m_Params.timeToTrigger ) )
game/server/ai_utils.cpp:		if ( ( lastTimeSeen == AI_INVALID_TIME || gpGlobals->curtime - lastTimeSeen > m_Params.peekTime ) &&
game/server/ai_utils.cpp:			 ( lastTimeDamagedBy == AI_INVALID_TIME || gpGlobals->curtime - lastTimeDamagedBy > m_Params.peekTimeAfterDamage ) )
game/server/ai_basenpc_flyer.cpp:	float newYaw = AI_ClampYaw( GetHeadTurnRate() * 10.0f, m_fHeadYaw, flDestYaw, gpGlobals->curtime - GetLastThink() );
game/server/fish.cpp:	SetNextThink( gpGlobals->curtime );
game/server/fish.cpp:	SetNextThink( gpGlobals->curtime + deltaT );
game/server/ai_network.cpp:			m_NearestCache[cachePos].expiration	= gpGlobals->curtime + NEARNODE_CACHE_LIFE;
game/server/ai_network.cpp:		if ( m_NearestCache[iCurrent].hull == nHull && m_NearestCache[iCurrent].expiration > gpGlobals->curtime )
game/server/ai_network.cpp:	m_NearestCache[m_iNearestCacheNext].expiration		= gpGlobals->curtime + NEARNODE_CACHE_LIFE;
game/server/episodic/ai_behavior_alyx_injured.cpp:				GetOuter()->m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/episodic/ai_behavior_alyx_injured.cpp:				if ( m_flNextWarnTime < gpGlobals->curtime )
game/server/episodic/ai_behavior_alyx_injured.cpp:					m_flNextWarnTime = gpGlobals->curtime + random->RandomFloat( 3.0f, 5.0f );
game/server/episodic/ai_behavior_alyx_injured.cpp:				m_flNextWarnTime = gpGlobals->curtime + random->RandomFloat( 3.0f, 5.0f );
game/server/episodic/ai_behavior_alyx_injured.cpp:		if ( gpGlobals->curtime - pMemory->timeLastSeen > 0.5f )
game/server/episodic/npc_advisor.cpp:		m_flThrowPhysicsTime = gpGlobals->curtime + advisor_throw_warn_time.GetFloat();
game/server/episodic/npc_advisor.cpp:			m_flThrowPhysicsTime = gpGlobals->curtime + advisor_throw_rate.GetFloat();
game/server/episodic/npc_advisor.cpp:			m_flStagingEnd = gpGlobals->curtime + pTask->flTaskData;
game/server/episodic/npc_advisor.cpp:			m_playerPinFailsafeTime = gpGlobals->curtime + 10.0f;
game/server/episodic/npc_advisor.cpp:			float flTimeToThrow = m_flThrowPhysicsTime - gpGlobals->curtime;
game/server/episodic/npc_advisor.cpp:				bool bDesperate = m_flStagingEnd - gpGlobals->curtime < 0.50f; // less than one half second left
game/server/episodic/npc_advisor.cpp:			if (gpGlobals->curtime > m_flStagingEnd)
game/server/episodic/npc_advisor.cpp:			if ( (gpGlobals->curtime > m_flThrowPhysicsTime - advisor_throw_lead_prefetch_time.GetFloat()) && 
game/server/episodic/npc_advisor.cpp:			if (gpGlobals->curtime > m_flThrowPhysicsTime)
game/server/episodic/npc_advisor.cpp:				m_flLastThrowTime = gpGlobals->curtime;
game/server/episodic/npc_advisor.cpp:				m_flThrowPhysicsTime = gpGlobals->curtime + 0.75f;
game/server/episodic/npc_advisor.cpp:			if ( gpGlobals->curtime > m_playerPinFailsafeTime )
game/server/episodic/npc_advisor.cpp:			float desiredDisplacementLen = ExponentialDecay(0.250f,gpGlobals->frametime);// * sqrt(displacementLen);			
game/server/episodic/npc_advisor.cpp:	float threeSecondsAgo = gpGlobals->curtime - 3.0f; // two seconds ago
game/server/episodic/npc_advisor.cpp:	float threeSecondsAgo = gpGlobals->curtime - 3.0f; 
game/server/episodic/npc_advisor.cpp:	m_flaRecentlyThrownObjectTimes[oldestThrownObject] = gpGlobals->curtime;
game/server/episodic/npc_advisor.cpp:	float desiredDisplacementLen = ExponentialDecay(STAGING_OBJECT_FALLOFF_TIME, gpGlobals->frametime);// * sqrt(displacementLen);
game/server/episodic/npc_advisor.cpp:	vel = (1.0f / gpGlobals->frametime)*(displacement * (1.0f - desiredDisplacementLen));
game/server/episodic/npc_advisor.cpp:	m_flNextFlinchTime = gpGlobals->curtime;
game/server/episodic/npc_advisor.cpp:	if ( oldLastDamageTime != gpGlobals->curtime )
game/server/episodic/npc_advisor.cpp:		m_flLastPlayerAttackTime = gpGlobals->curtime;
game/server/episodic/npc_advisor.cpp:				objectToMe /= (1.5f * gpGlobals->frametime);
game/server/episodic/npc_combine_cannon.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/npc_combine_cannon.cpp:	flElapsedTime = flTime - (GetWaitFinishTime() - gpGlobals->curtime);
game/server/episodic/npc_combine_cannon.cpp:	SetNextThink( gpGlobals->curtime + 0.02f );
game/server/episodic/npc_combine_cannon.cpp:		flOffset += (M_PI/8.0f) * sin( gpGlobals->curtime * 3.0f );
game/server/episodic/npc_combine_cannon.cpp:	vecCurrentDir.x += flNoiseScale * ( sin( 3 * M_PI * gpGlobals->curtime ) * 0.0006 );
game/server/episodic/npc_combine_cannon.cpp:	vecCurrentDir.y += flNoiseScale * ( sin( 2 * M_PI * gpGlobals->curtime + 0.5 * M_PI ) * 0.0006 );
game/server/episodic/npc_combine_cannon.cpp:	vecCurrentDir.z += flNoiseScale * ( sin( 1.5 * M_PI * gpGlobals->curtime + M_PI ) * 0.0006 );
game/server/episodic/npc_combine_cannon.cpp:	if ( GetNextAttack() > gpGlobals->curtime )
game/server/episodic/npc_combine_cannon.cpp:	SetNextAttack( gpGlobals->curtime + GetRefireTime() );
game/server/episodic/npc_combine_cannon.cpp:		m_flBarrageDuration = gpGlobals->curtime + random->RandomFloat( 0.25f, 0.5f );
game/server/episodic/npc_combine_cannon.cpp:				if ( ( gpGlobals->curtime - m_flTimeLastAttackedPlayer ) < 1.0f )
game/server/episodic/npc_combine_cannon.cpp:				bool bBarrageFinished = m_flBarrageDuration < gpGlobals->curtime;
game/server/episodic/npc_combine_cannon.cpp:					m_flTimeLastAttackedPlayer = gpGlobals->curtime;
game/server/episodic/npc_combine_cannon.cpp:		SetNextThink( gpGlobals->curtime + 0.03 );
game/server/episodic/npc_combine_cannon.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/npc_combine_cannon.cpp:		if( gpGlobals->curtime - GetEnemies()->LastTimeSeen( GetEnemy() ) > 30 )
game/server/episodic/npc_combine_cannon.cpp:	float flTimeSinceLastMiss = gpGlobals->curtime - m_flTimeLastShotMissed;
game/server/episodic/npc_combine_cannon.cpp:	if( (pPlayer->GetFlags() & FL_DUCKING) && pPlayer->MuzzleFlashTime() > gpGlobals->curtime )
game/server/episodic/weapon_hopwire.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/server/episodic/weapon_hopwire.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/server/episodic/weapon_hopwire.cpp:	if ( ( m_bRedraw ) && ( m_flNextPrimaryAttack <= gpGlobals->curtime ) && ( m_flNextSecondaryAttack <= gpGlobals->curtime ) )
game/server/episodic/weapon_hopwire.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/episodic/weapon_hopwire.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/episodic/weapon_hopwire.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/server/episodic/weapon_hopwire.cpp:		m_flTimeWeaponIdle = m_flNextPrimaryAttack = gpGlobals->curtime + 2.0f;
game/server/episodic/npc_hunter.cpp:		SetContextThink( &CHunterFlechette::SeekThink, gpGlobals->curtime, s_szHunterFlechetteSeekThink );
game/server/episodic/npc_hunter.cpp:		SetNextThink( gpGlobals->curtime + (hunter_flechette_explode_delay.GetFloat() - HUNTER_FLECHETTE_WARN_TIME) );
game/server/episodic/npc_hunter.cpp:		SetNextThink( gpGlobals->curtime, s_szHunterFlechetteSeekThink );
game/server/episodic/npc_hunter.cpp:		SetNextThink( gpGlobals->curtime );
game/server/episodic/npc_hunter.cpp:	SetNextThink( gpGlobals->curtime + 0.1f, s_szHunterFlechetteBubbles );
game/server/episodic/npc_hunter.cpp:	SetNextThink( gpGlobals->curtime );
game/server/episodic/npc_hunter.cpp:	SetContextThink( &CHunterFlechette::BubbleThink, gpGlobals->curtime + 0.1, s_szHunterFlechetteBubbles );
game/server/episodic/npc_hunter.cpp:	SetNextThink( gpGlobals->curtime + HUNTER_FLECHETTE_WARN_TIME );
game/server/episodic/npc_hunter.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/npc_hunter.cpp:	if( !Q_strnicmp( STRING(gpGlobals->mapname), "ep2_outland_12", 14) )
game/server/episodic/npc_hunter.cpp:		GlobalEntity_Add( s_iszHuntersToRunOver, gpGlobals->mapname, GLOBAL_ON );
game/server/episodic/npc_hunter.cpp:			EntityText( text_offset, CFmtStr("Next Siege Attempt:%f", m_flTimeNextSiegeTargetAttack - gpGlobals->curtime ), 0 );
game/server/episodic/npc_hunter.cpp:		if ( m_flPupilDilateTime < gpGlobals->curtime )
game/server/episodic/npc_hunter.cpp:	if ( !hunter_charge_test.GetBool() && gpGlobals->curtime < m_flNextChargeTime )
game/server/episodic/npc_hunter.cpp:						if ( timeDrawnArrow != gpGlobals->curtime )
game/server/episodic/npc_hunter.cpp:							timeDrawnArrow = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:				if ( timeDrawnArrow != gpGlobals->curtime )
game/server/episodic/npc_hunter.cpp:					timeDrawnArrow = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:			m_flTimeSawEnemyAgain = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:	if( gpGlobals->curtime < m_flTimeNextSiegeTargetAttack )
game/server/episodic/npc_hunter.cpp:	m_flTimeNextSiegeTargetAttack = gpGlobals->curtime + (hunter_siege_frequency.GetFloat() * RandomFloat( 0.8f, 1.2f) );
game/server/episodic/npc_hunter.cpp:				pMemory->timeFirstSeen = gpGlobals->curtime - 5.0f;
game/server/episodic/npc_hunter.cpp:				pMemory->timeLastSeen = gpGlobals->curtime - 1.0f;
game/server/episodic/npc_hunter.cpp:	if ( IsCurSchedule( SCHED_HUNTER_RANGE_ATTACK2, false ) && ( gpGlobals->curtime < m_flShootAllowInterruptTime ) )
game/server/episodic/npc_hunter.cpp:			if( (gpGlobals->curtime - m_flTimeSawEnemyAgain) >= 2.0f )
game/server/episodic/npc_hunter.cpp:		if ( gpGlobals->curtime - CAI_HunterEscortBehavior::gm_flLastDefendSound > 10.0 )
game/server/episodic/npc_hunter.cpp:			CAI_HunterEscortBehavior::gm_flLastDefendSound = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:	if ( gpGlobals->curtime > m_flNextSideStepTime )
game/server/episodic/npc_hunter.cpp:			m_flNextSideStepTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 3.0f );
game/server/episodic/npc_hunter.cpp:	if ( HasCondition( COND_HEAVY_DAMAGE ) && ( gpGlobals->curtime > m_flNextSideStepTime ) )
game/server/episodic/npc_hunter.cpp:		m_flNextSideStepTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 3.0f );
game/server/episodic/npc_hunter.cpp:		&& m_fCorneredTimer < gpGlobals->curtime)
game/server/episodic/npc_hunter.cpp:		if ( m_fCorneredTimer < gpGlobals->curtime )
game/server/episodic/npc_hunter.cpp:			m_fCorneredTimer = gpGlobals->curtime + 6.0f;
game/server/episodic/npc_hunter.cpp:				GetEnemies()->SetTimeValidEnemy( GetEnemy(), gpGlobals->curtime + 10.0f );
game/server/episodic/npc_hunter.cpp:			m_flShootAllowInterruptTime = gpGlobals->curtime + 100.0f;
game/server/episodic/npc_hunter.cpp:				BeginVolley( nShots, gpGlobals->curtime + initialDelay );
game/server/episodic/npc_hunter.cpp:			SetLastAttackTime( gpGlobals->curtime );
game/server/episodic/npc_hunter.cpp:			m_fCorneredTimer = gpGlobals->curtime + pTask->flTaskData;
game/server/episodic/npc_hunter.cpp:			m_flNextChargeTime = gpGlobals->curtime + pTask->flTaskData;
game/server/episodic/npc_hunter.cpp:			if ( gpGlobals->curtime >= m_flNextFlechetteTime )
game/server/episodic/npc_hunter.cpp:						m_flNextFlechetteTime = gpGlobals->curtime + hunter_flechette_delay.GetFloat();
game/server/episodic/npc_hunter.cpp:					m_flNextChargeTime = gpGlobals->curtime + hunter_charge_min_delay.GetFloat() + random->RandomFloat( 0, 2.5 ) + random->RandomFloat( 0, 2.5 );
game/server/episodic/npc_hunter.cpp:					float groupDelay = gpGlobals->curtime +  ( 2.0  + random->RandomFloat( 0, 2 ) ) * delayMultiplier;
game/server/episodic/npc_hunter.cpp:	if ( IRelationType( pEntity ) == D_HT && ( GetNextAttack() < gpGlobals->curtime ) )
game/server/episodic/npc_hunter.cpp:		SetNextAttack( gpGlobals->curtime + 2.0f );
game/server/episodic/npc_hunter.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/npc_hunter.cpp:	m_flTimeEscortReturn = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:	m_flTimeNextSiegeTargetAttack = gpGlobals->curtime + random->RandomFloat( 1, hunter_siege_frequency.GetFloat() );
game/server/episodic/npc_hunter.cpp:				if ( gpGlobals->curtime - StriderBuster_GetPickupTime( pTarget ) > hunter_hate_held_striderbusters_delay.GetFloat())
game/server/episodic/npc_hunter.cpp:	if ( ( gpGlobals->curtime < m_flNextMeleeTime ) && // allow berzerk bashing if cornered
game/server/episodic/npc_hunter.cpp:		!( m_hAttachedBusters.Count() > 0 && gpGlobals->curtime < m_fCorneredTimer ) )
game/server/episodic/npc_hunter.cpp:	if ( !bIsPerfectBullseye && !bIsBuster && !hunter_flechette_test.GetBool() && ( gpGlobals->curtime < m_flNextRangeAttack2Time ) )
game/server/episodic/npc_hunter.cpp:	m_flNextMeleeTime = gpGlobals->curtime + hunter_melee_delay.GetFloat();
game/server/episodic/npc_hunter.cpp:	if ( gpGlobals->curtime > m_flNextDamageTime )
game/server/episodic/npc_hunter.cpp:		m_flNextDamageTime = gpGlobals->curtime + random->RandomFloat( 0.5, 1.2 ); 
game/server/episodic/npc_hunter.cpp:	if ( gpGlobals->curtime < m_flTeslaStopTime )
game/server/episodic/npc_hunter.cpp:		SetContextThink( &CNPC_Hunter::TeslaThink, gpGlobals->curtime + random->RandomFloat( 0.1f, 0.3f ), HUNTER_ZAP_THINK ); 
game/server/episodic/npc_hunter.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.6, 1.5 ), HUNTER_BLEED_THINK );
game/server/episodic/npc_hunter.cpp:			SetContextThink( &CNPC_Hunter::TeslaThink, gpGlobals->curtime, HUNTER_ZAP_THINK ); 
game/server/episodic/npc_hunter.cpp:			m_flTeslaStopTime = gpGlobals->curtime + 2.0f;
game/server/episodic/npc_hunter.cpp:					SetContextThink( &CNPC_Hunter::JostleVehicleThink, gpGlobals->curtime, HUNTER_JOSTLE_VEHICLE_THINK );
game/server/episodic/npc_hunter.cpp:					GetEnemies()->SetTimeValidEnemy( GetEnemy(), gpGlobals->curtime + HUNTER_IGNORE_ENEMY_TIME );
game/server/episodic/npc_hunter.cpp:		m_flTimeNextSiegeTargetAttack = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:	SetContextThink( &CNPC_Hunter::BleedThink, gpGlobals->curtime + 0.1, HUNTER_BLEED_THINK );
game/server/episodic/npc_hunter.cpp:		m_flNextRangeAttack2Time = gpGlobals->curtime + random->RandomFloat( minDelay, maxDelay ) * delayMultiplier;
game/server/episodic/npc_hunter.cpp:			float nextTime = gpGlobals->curtime + random->RandomFloat( minDelay, maxDelay ) * delayMultiplier;
game/server/episodic/npc_hunter.cpp:		m_flPupilDilateTime = gpGlobals->curtime + 0.2f;
game/server/episodic/npc_hunter.cpp:		( GetOuter()->GetSquad()->GetSquadSoundWaitTime() <= gpGlobals->curtime ) ) // && !FarFromFollowTarget()
game/server/episodic/npc_hunter.cpp:		m_flTimeEscortReturn = gpGlobals->curtime + random->RandomFloat( 15.0f, 25.0f );
game/server/episodic/npc_hunter.cpp:	if ( ( m_flTimeEscortReturn != 0 ) && ( gpGlobals->curtime > m_flTimeEscortReturn ) )
game/server/episodic/npc_hunter.cpp:	if ( m_flTimeEscortReturn != 0 && ( FarFromFollowTarget() || gpGlobals->curtime >= m_flTimeEscortReturn ) )
game/server/episodic/npc_hunter.cpp:			m_flTimeEscortReturn = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:			GetOuter()->GetSquad()->SetSquadSoundWaitTime( gpGlobals->curtime + random->RandomFloat( 5.0f, 12.0f ) );
game/server/episodic/npc_hunter.cpp:		if ( GetOuter()->GetSquad()->GetSquadSoundWaitTime() <= gpGlobals->curtime && ((CBasePlayer *)GetEnemy())->IsInAVehicle() )
game/server/episodic/npc_hunter.cpp:			m_flTimeEscortReturn = gpGlobals->curtime + random->RandomFloat( 15.0f, 25.0f );
game/server/episodic/npc_hunter.cpp:	if ( m_flTimeEscortReturn <= gpGlobals->curtime )
game/server/episodic/npc_hunter.cpp:						GetOuter()->BeginVolley( NUM_FLECHETTE_VOLLEY_ON_FOLLOW, gpGlobals->curtime + 1.0 + random->RandomFloat( 0, .25 ) + random->RandomFloat( 0, .25 ) );
game/server/episodic/npc_hunter.cpp:							if ( gpGlobals->curtime >= pHunter->m_flNextFlechetteTime )
game/server/episodic/npc_hunter.cpp:										pHunter->m_flNextFlechetteTime = gpGlobals->curtime + hunter_flechette_delay.GetFloat();
game/server/episodic/npc_hunter.cpp:										pHunter->BeginVolley( NUM_FLECHETTE_VOLLEY_ON_FOLLOW, gpGlobals->curtime + 1.0 + random->RandomFloat( 0, .25 ) + random->RandomFloat( 0, .25 ) );
game/server/episodic/npc_hunter.cpp:	if ( g_TimeLastDistributeFreeHunters != -1 && gpGlobals->curtime - g_TimeLastDistributeFreeHunters < FREE_HUNTER_DISTRIBUTE_INTERVAL )
game/server/episodic/npc_hunter.cpp:	g_TimeLastDistributeFreeHunters = gpGlobals->curtime;
game/server/episodic/npc_hunter.cpp:		if ( gpGlobals->curtime >= m_flTimeEscortReturn )
game/server/episodic/prop_scalable.cpp:	m_flGoalTimeX = gpGlobals->curtime;
game/server/episodic/prop_scalable.cpp:	m_flGoalTimeY = gpGlobals->curtime;
game/server/episodic/prop_scalable.cpp:	m_flGoalTimeZ = gpGlobals->curtime;
game/server/episodic/weapon_striderbuster.cpp:		if ( gpGlobals->curtime > 0.2f )
game/server/episodic/weapon_striderbuster.cpp:	SetNextThink(gpGlobals->curtime + 0.01f);
game/server/episodic/weapon_striderbuster.cpp:				SetContextThink( &CWeaponStriderBuster::BusterPingThink, gpGlobals->curtime + BUSTER_PING_SOUND_FREQ, s_pBusterPingThinkContext );
game/server/episodic/weapon_striderbuster.cpp:					SetContextThink( NULL, gpGlobals->curtime, s_pBusterPingThinkContext );
game/server/episodic/weapon_striderbuster.cpp:					SetNextThink( gpGlobals->curtime );
game/server/episodic/weapon_striderbuster.cpp:				float sinTime = sin( gpGlobals->curtime );
game/server/episodic/weapon_striderbuster.cpp:				m_CarryAngles.y = 15 * ( sin( gpGlobals->curtime ) + cos( gpGlobals->curtime * 0.5 ) ) * .5  + random->RandomFloat( -15, 15 );
game/server/episodic/weapon_striderbuster.cpp:				m_CarryAngles.z = 7.5 * ( sin( gpGlobals->curtime ) + sin( gpGlobals->curtime * 2.0 ) ) * .5 + random->RandomFloat( -7.5, 7.5 );
game/server/episodic/weapon_striderbuster.cpp:	m_PickupTime = gpGlobals->curtime;
game/server/episodic/weapon_striderbuster.cpp:	SetNextThink( gpGlobals->curtime );
game/server/episodic/weapon_striderbuster.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pBusterPingThinkContext );
game/server/episodic/weapon_striderbuster.cpp:		SetNextThink(gpGlobals->curtime + 0.01f);
game/server/episodic/weapon_striderbuster.cpp:		SetNextThink(gpGlobals->curtime + 0.01f);
game/server/episodic/weapon_striderbuster.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/weapon_striderbuster.cpp:	SetContextThink( &CWeaponStriderBuster::BusterPingThink, gpGlobals->curtime + BUSTER_PING_SOUND_FREQ, s_pBusterPingThinkContext );
game/server/episodic/ai_behavior_passenger_zombie.cpp:	GetOuter()->SetNextAttack( gpGlobals->curtime + flDuration );
game/server/episodic/ai_behavior_passenger_zombie.cpp:	if ( m_flNextLeapTime > gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_zombie.cpp:		if ( GetOuter()->GetNextAttack() < gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_zombie.cpp:				m_flNextLeapTime = gpGlobals->curtime + 2.0f;
game/server/episodic/grenade_hopwire.cpp:	if ( m_flEndTime > gpGlobals->curtime )
game/server/episodic/grenade_hopwire.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/grenade_hopwire.cpp:	m_flEndTime	= gpGlobals->curtime + duration;
game/server/episodic/grenade_hopwire.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/grenade_hopwire.cpp:	SetNextThink( gpGlobals->curtime + timer );
game/server/episodic/grenade_hopwire.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/episodic/grenade_hopwire.cpp:		SetNextThink( gpGlobals->curtime + 2.0f );
game/server/episodic/grenade_hopwire.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/episodic/grenade_hopwire.cpp:	SetNextThink( gpGlobals->curtime + apexTime);
game/server/episodic/vehicle_jeep_episodic.cpp:		if ( ( m_hIgnoreEntity == pOther ) || ( m_flIgnoreDuration >= gpGlobals->curtime ) )
game/server/episodic/vehicle_jeep_episodic.cpp:		m_flIgnoreDuration = gpGlobals->curtime + 0.5f;
game/server/episodic/vehicle_jeep_episodic.cpp:			if ( gpGlobals->curtime > 0.5f )
game/server/episodic/vehicle_jeep_episodic.cpp:			if ( gpGlobals->curtime > 0.5f )
game/server/episodic/vehicle_jeep_episodic.cpp:				if ( m_flNextWaterSound < gpGlobals->curtime )
game/server/episodic/vehicle_jeep_episodic.cpp:					m_flNextWaterSound = gpGlobals->curtime + random->RandomFloat( 0.25f, 1.0f );
game/server/episodic/vehicle_jeep_episodic.cpp:	if( !forceUpdate && gpGlobals->curtime < m_flNextRadarUpdateTime )
game/server/episodic/vehicle_jeep_episodic.cpp:	m_flNextRadarUpdateTime = gpGlobals->curtime + RADAR_UPDATE_FREQUENCY;
game/server/episodic/vehicle_jeep_episodic.cpp:		m_flNextRadarUpdateTime = gpGlobals->curtime + RADAR_UPDATE_FREQUENCY_FAST;
game/server/episodic/vehicle_jeep_episodic.cpp:	if ( m_flCargoStartTime + jalopy_cargo_anim_time.GetFloat() < gpGlobals->curtime )
game/server/episodic/vehicle_jeep_episodic.cpp:			m_flAmmoCrateCloseTime = gpGlobals->curtime;
game/server/episodic/vehicle_jeep_episodic.cpp:	float flPerc = (jalopy_cargo_anim_time.GetFloat()) ? (( gpGlobals->curtime - m_flCargoStartTime ) / jalopy_cargo_anim_time.GetFloat()) : 1.0f;
game/server/episodic/vehicle_jeep_episodic.cpp:	m_flAmmoCrateCloseTime += gpGlobals->frametime;
game/server/episodic/vehicle_jeep_episodic.cpp:	if ( m_flNextAvoidBroadcastTime > gpGlobals->curtime )
game/server/episodic/vehicle_jeep_episodic.cpp:	m_flNextAvoidBroadcastTime = gpGlobals->curtime + VEHICLE_AVOID_BROADCAST_RATE;
game/server/episodic/vehicle_jeep_episodic.cpp:		m_throttleDisableTime = gpGlobals->curtime + 0.25f;		
game/server/episodic/vehicle_jeep_episodic.cpp:	m_flCargoStartTime = gpGlobals->curtime;
game/server/episodic/vehicle_jeep_episodic.cpp:						if ( (gpGlobals->curtime - pUpdate->startUpdateTime) > 0.5f && DotProduct(velocity,normal) > 0)
game/server/episodic/vehicle_jeep_episodic.cpp:						pUpdate->startUpdateTime = gpGlobals->curtime;
game/server/episodic/vehicle_jeep_episodic.cpp:					pUpdate->stopUpdateTime = gpGlobals->curtime + 1.0f;
game/server/episodic/vehicle_jeep_episodic.cpp:			PhysCollisionSound( pVehicleEntity, npcList[i]->VPhysicsGetObject(), CHAN_BODY, pVehiclePhysics->GetMaterialIndex(), npcList[i]->VPhysicsGetObject()->GetMaterialIndex(), gpGlobals->frametime, 200.0f );
game/server/episodic/vehicle_jeep_episodic.cpp:	SetContextThink( &CPropJeepEpisodic::HazardBlinkThink, gpGlobals->curtime + 0.1f, "HazardBlink" );
game/server/episodic/vehicle_jeep_episodic.cpp:	SetContextThink( NULL, gpGlobals->curtime, "HazardBlink" );
game/server/episodic/vehicle_jeep_episodic.cpp:	m_flNextRadarUpdateTime = gpGlobals->curtime - 1.0f;
game/server/episodic/vehicle_jeep_episodic.cpp:		SetContextThink( &CPropJeepEpisodic::HazardBlinkThink, gpGlobals->curtime + 0.25f, "HazardBlink" );
game/server/episodic/vehicle_jeep_episodic.cpp:		SetContextThink( &CPropJeepEpisodic::HazardBlinkThink, gpGlobals->curtime + 0.5f, "HazardBlink" );
game/server/episodic/ai_behavior_passenger_companion.cpp:	if ( m_flNextJostleTime > gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:		m_flOverturnedDuration += ( gpGlobals->curtime - GetLastThink() );
game/server/episodic/ai_behavior_passenger_companion.cpp:	if ( m_flOverturnedDuration > MIN_OVERTURNED_WARN_DURATION && m_flNextOverturnWarning < gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:	m_flUnseenDuration += ( gpGlobals->curtime - GetLastThink() );
game/server/episodic/ai_behavior_passenger_companion.cpp:				GetOuter()->SetNextAttack( gpGlobals->curtime + ( GetOuter()->SequenceDuration( nSequence ) * 2.0f ) );
game/server/episodic/ai_behavior_passenger_companion.cpp:			if( pEMemory->timeLastSeen == gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:	if ( m_flNextEnterAttempt > gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:		if ( m_flNextEnterAttempt > gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:		m_flNextJostleTime = gpGlobals->curtime + random->RandomFloat( 2.5f, 4.0f );
game/server/episodic/ai_behavior_passenger_companion.cpp:		m_flNextOverturnWarning = gpGlobals->curtime + random->RandomFloat( 5.0f, 10.0f );
game/server/episodic/ai_behavior_passenger_companion.cpp:		if ( m_flNextEnterAttempt > gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:	if ( ( gpGlobals->curtime - m_flEnterBeginTime ) < 0.5f )
game/server/episodic/ai_behavior_passenger_companion.cpp:		m_flNextEnterAttempt = gpGlobals->curtime + 3.0f;
game/server/episodic/ai_behavior_passenger_companion.cpp:	m_flEnterBeginTime = gpGlobals->curtime;
game/server/episodic/ai_behavior_passenger_companion.cpp:			GetOuter()->SetNextAttack( gpGlobals->curtime + flStunTime );
game/server/episodic/ai_behavior_passenger_companion.cpp:	if ( m_flEntraceUpdateTime > gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:		m_flEntraceUpdateTime = gpGlobals->curtime + 0.5f;
game/server/episodic/ai_behavior_passenger_companion.cpp:	m_flEntraceUpdateTime = gpGlobals->curtime + 1.0f;
game/server/episodic/ai_behavior_passenger_companion.cpp:	failPos.flTime = gpGlobals->curtime;
game/server/episodic/ai_behavior_passenger_companion.cpp:		if ( ( gpGlobals->curtime - m_FailedEntryPositions[i].flTime ) > 3.0f )
game/server/episodic/ai_behavior_passenger_companion.cpp:	if ( m_flNextFidgetTime > gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:	if ( m_flNextFidgetTime < gpGlobals->curtime )
game/server/episodic/ai_behavior_passenger_companion.cpp:		m_flNextFidgetTime = gpGlobals->curtime + flDuration;
game/server/episodic/ep2_gamestats.cpp:	m_pCurrentMap = FindOrAddMapStats( STRING( gpGlobals->mapname ) );
game/server/episodic/ep2_gamestats.cpp:	m_pCurrentMap->Init( STRING( gpGlobals->mapname ), gpGlobals->curtime, pchTag, gpGlobals->mapversion );
game/server/episodic/ep2_gamestats.cpp:	Ep2LevelStats_t *map = FindOrAddMapStats( STRING( gpGlobals->mapname ) );
game/server/episodic/ep2_gamestats.cpp:	Ep2LevelStats_t *map = s_CEP2GameStats_Singleton.FindOrAddMapStats( STRING( gpGlobals->mapname ) );
game/server/cstrike/cs_nav_file.cpp:	Q_snprintf( bspFilename, sizeof( bspFilename ), "maps\\%s.bsp", STRING( gpGlobals->mapname ) );
game/server/cstrike/cs_nav_file.cpp:	Q_snprintf( filename, sizeof( filename ), "%s\\maps\\%s.nav", gamePath, STRING( gpGlobals->mapname ) );
game/server/cstrike/cs_nav_file.cpp:	Q_snprintf( filename, sizeof( filename ), "maps\\%s.nav", STRING( gpGlobals->mapname ) );
game/server/cstrike/cs_vehicle_jeep.cpp:	m_flHandbrakeTime = gpGlobals->curtime + 0.1;
game/server/cstrike/cs_vehicle_jeep.cpp:			m_throttleDisableTime = gpGlobals->curtime + 2;
game/server/cstrike/cs_vehicle_jeep.cpp:				if ( m_WaterData.m_flNextRippleTime[iWheel] < gpGlobals->curtime )
game/server/cstrike/cs_vehicle_jeep.cpp:					m_WaterData.m_flNextRippleTime[iWheel] = gpGlobals->curtime + RandomFloat( 0.1, 0.3 );
game/server/cstrike/cs_vehicle_jeep.cpp:	SetSimulationTime( gpGlobals->curtime );
game/server/cstrike/cs_vehicle_jeep.cpp:	SetNextThink( gpGlobals->curtime );
game/server/cstrike/cs_vehicle_jeep.cpp:		m_flOverturnedTime += gpGlobals->frametime;
game/server/cstrike/cs_vehicle_jeep.cpp:	if ( ( m_flAmmoCrateCloseTime < gpGlobals->curtime ) && ( GetSequence() == LookupSequence( "ammo_open" ) ) )
game/server/cstrike/cs_vehicle_jeep.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/cstrike/cs_vehicle_jeep.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/cstrike/cs_vehicle_jeep.cpp:	if ( m_flCannonTime > gpGlobals->curtime )
game/server/cstrike/cs_vehicle_jeep.cpp:	m_flCannonTime = gpGlobals->curtime + 0.2f;
game/server/cstrike/cs_vehicle_jeep.cpp:		m_hPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/cstrike/cs_vehicle_jeep.cpp:	m_flCannonTime		= gpGlobals->curtime + 0.5f;
game/server/cstrike/cs_vehicle_jeep.cpp:	float flChargeAmount = ( gpGlobals->curtime - m_flCannonChargeStartTime ) / MAX_GAUSS_CHARGE_TIME;
game/server/cstrike/cs_vehicle_jeep.cpp:		m_hPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5f );
game/server/cstrike/cs_vehicle_jeep.cpp:	if ( m_flCannonTime > gpGlobals->curtime )
game/server/cstrike/cs_vehicle_jeep.cpp:		m_flCannonChargeStartTime = gpGlobals->curtime;
game/server/cstrike/cs_vehicle_jeep.cpp:			m_flAnimTime = gpGlobals->curtime;
game/server/cstrike/cs_vehicle_jeep.cpp:		m_flAmmoCrateCloseTime = gpGlobals->curtime + JEEP_AMMO_CRATE_CLOSE_DELAY;
game/server/cstrike/cs_vehicle_jeep.cpp:	float flFrameTime = gpGlobals->frametime;
game/server/cstrike/cs_vehicle_jeep.cpp:	if ( ( m_throttleDisableTime > gpGlobals->curtime ) || ( IsOverturned() ) )
game/server/cstrike/cs_vehicle_jeep.cpp:	if ( m_flDangerSoundTime > gpGlobals->curtime )
game/server/cstrike/cs_vehicle_jeep.cpp:	m_flDangerSoundTime = gpGlobals->curtime + 0.1;
game/server/cstrike/cs_vehicle_jeep.cpp:	m_flPlayerExitedTime = gpGlobals->curtime;
game/server/cstrike/cs_vehicle_jeep.cpp:	m_flLastSawPlayerAt = gpGlobals->curtime;
game/server/cstrike/cs_vehicle_jeep.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/cstrike/item_defuser.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/cstrike/cs_playermove.cpp:	if (pVehicle && gpGlobals->frametime != 0)
game/server/cstrike/cs_playermove.cpp:	if (pVehicle && gpGlobals->frametime != 0)
game/server/cstrike/cs_player.h:	return gpGlobals->curtime < m_blindUntilTime;
game/server/cstrike/cs_player.h:	return (m_blindStartTime + m_flFlashDuration) > gpGlobals->curtime;
game/server/cstrike/cs_player.h:	return (gpGlobals->curtime > m_allowAutoFollowTime); 
game/server/cstrike/cs_player.h:	m_allowAutoFollowTime = gpGlobals->curtime + duration; 
game/server/cstrike/cs_player.cpp:	m_flLastMovement = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:	m_flNextMouseoverUpdate = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:		( ucmd->tick_count > (gpGlobals->tickcount + sv_max_usercmd_future_ticks.GetInt()) ) )
game/server/cstrike/cs_player.cpp:		DevMsg( "Client cmd out of sync (delta %i).\n", ucmd->tick_count - gpGlobals->tickcount );
game/server/cstrike/cs_player.cpp:	if ( iMimic > gpGlobals->maxClients )
game/server/cstrike/cs_player.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/cstrike/cs_player.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:	float flTimeBase = gpGlobals->curtime + gpGlobals->frametime - frametime;
game/server/cstrike/cs_player.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/cstrike/cs_player.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/cstrike/cs_player.cpp:	m_flRadioTime = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:	SetContextThink( &CCSPlayer::PushawayThink, gpGlobals->curtime + PUSHAWAY_THINK_INTERVAL, CS_PUSHAWAY_THINK_CONTEXT );
game/server/cstrike/cs_player.cpp:		m_flNextAttack = gpGlobals->curtime; // Allow reloads to finish, since we're playing the deploy anim instead.  This mimics goldsrc behavior, anyway.
game/server/cstrike/cs_player.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/cs_player.cpp:	if ( (m_flLastRadarUpdateTime + 1.0) > gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:	m_flLastRadarUpdateTime = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:	if ( m_flNextMouseoverUpdate < gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:		m_flNextMouseoverUpdate = gpGlobals->curtime + 0.2f;
game/server/cstrike/cs_player.cpp:	if ((m_applyDeafnessTime != 0.0f) && (m_applyDeafnessTime <= gpGlobals->curtime))
game/server/cstrike/cs_player.cpp:	SetNextThink( gpGlobals->curtime + PUSHAWAY_THINK_INTERVAL, CS_PUSHAWAY_THINK_CONTEXT );
game/server/cstrike/cs_player.cpp:			if ( (pCSAttacker->m_flLastAttackedTeammate + 0.6f) < gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:				pCSAttacker->m_flLastAttackedTeammate = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:				for ( int i=1; i<=gpGlobals->maxClients; ++i )
game/server/cstrike/cs_player.cpp:			gpGlobals->curtime, GetPlayerName(),
game/server/cstrike/cs_player.cpp:	m_blindUntilTime = MAX( m_blindUntilTime, gpGlobals->curtime + holdTime + 0.5f * fadeTime );
game/server/cstrike/cs_player.cpp:	m_blindStartTime = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:		if ( gpGlobals->curtime > oldBlindUntilTime )
game/server/cstrike/cs_player.cpp:			float remainingDuration = oldBlindStartTime + m_flFlashDuration - gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:		m_flLastMovement = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:		if ( m_flLastMovement + CSGameRules()->GetRoundLength()*2 < gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:			m_flLastMovement = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:	m_fIntroCamTime = gpGlobals->curtime + 6;
game/server/cstrike/cs_player.cpp:	if( m_flRadioTime > gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:	m_flRadioTime = gpGlobals->curtime + 1.5;
game/server/cstrike/cs_player.cpp:	if( m_flRadioTime > gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:	m_flRadioTime = gpGlobals->curtime + 1.5;
game/server/cstrike/cs_player.cpp:	if( m_flRadioTime > gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:	m_flRadioTime = gpGlobals->curtime + 1.5;
game/server/cstrike/cs_player.cpp:	for ( i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/cs_player.cpp:	for ( int i=1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/cs_player.cpp:	m_applyDeafnessTime = gpGlobals->curtime + 0.3;
game/server/cstrike/cs_player.cpp:	float timeIntoEffect = gpGlobals->curtime - m_applyDeafnessTime;
game/server/cstrike/cs_player.cpp:		m_RateLimitLastCommandTimes.Insert( pcmd, gpGlobals->curtime );
game/server/cstrike/cs_player.cpp:	else if ( (gpGlobals->curtime - m_RateLimitLastCommandTimes[i]) < CS_COMMAND_MAX_RATE )
game/server/cstrike/cs_player.cpp:		m_RateLimitLastCommandTimes[i] = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:		for ( int i=1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/cs_player.cpp:		m_applyDeafnessTime = gpGlobals->curtime + 0.3;
game/server/cstrike/cs_player.cpp:			m_fNextSuicideTime = gpGlobals->curtime;	// allow the suicide to work
game/server/cstrike/cs_player.cpp:	m_flLastMovement = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:	if ( !gpGlobals->startspot || !strlen(STRING(gpGlobals->startspot)))
game/server/cstrike/cs_player.cpp:		pSpot = gEntList.FindEntityByTarget( NULL, STRING(gpGlobals->startspot) );
game/server/cstrike/cs_player.cpp:	if( m_pIntroCamera && (gpGlobals->curtime >= m_fIntroCamTime) )
game/server/cstrike/cs_player.cpp:	m_flDeathTime = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:	if ( gpGlobals->curtime >= fDeathEnd )
game/server/cstrike/cs_player.cpp:			!m_bAbortFreezeCam && gpGlobals->curtime < fFreezeEnd && GetObserverMode() != OBS_MODE_FREEZECAM)
game/server/cstrike/cs_player.cpp:	if ( gpGlobals->curtime < fFreezeEnd )
game/server/cstrike/cs_player.cpp:	if (gpGlobals->curtime >= (m_flDeathTime + DEATH_ANIMATION_TIME + 3.0))
game/server/cstrike/cs_player.cpp:	if ( pPlayer && pPlayer->m_iNextTimeCheck >= gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:		pPlayer->m_iNextTimeCheck = gpGlobals->curtime + 1;
game/server/cstrike/cs_player.cpp:	if ( (m_flNameChangeHistory[0] + MIN_NAME_CHANGE_INTERVAL) >= gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:	if ( (m_flNameChangeHistory[NAME_CHANGE_HISTORY_SIZE-1] + NAME_CHANGE_HISTORY_INTERVAL) >= gpGlobals->curtime )
game/server/cstrike/cs_player.cpp:	m_flNameChangeHistory[0] = gpGlobals->curtime; // last change
game/server/cstrike/cs_player.cpp:		pAttacker->m_killTimes.AddToTail(gpGlobals->curtime);
game/server/cstrike/cs_player.cpp:		while (pAttacker->m_killTimes.Count() > 0 && pAttacker->m_killTimes[0] + AchievementConsts::KillingSpree_WindowTime < gpGlobals->curtime)
game/server/cstrike/cs_player.cpp:			pAttacker->m_KillingSpreeStartTime = gpGlobals->curtime;
game/server/cstrike/cs_player.cpp:		if (pVictim->m_KillingSpreeStartTime >= 0 && pVictim->m_KillingSpreeStartTime - gpGlobals->curtime <= AchievementConsts::KillingSpreeEnder_TimeWindow)
game/server/cstrike/cs_player.cpp:		if (pVictim->HasC4() && pVictim->GetBombPickuptime() + AchievementConsts::KillBombPickup_MaxTime > gpGlobals->curtime)
game/server/cstrike/cs_player.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/cs_player.cpp:			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/cs_player.cpp:				gpGlobals->curtime - CSGameRules()->GetRoundStartTime() < AchievementConsts::FastRoundWin_Time &&
game/server/cstrike/cs_player.cpp:	if ( gpGlobals->curtime < fEndFreezeTravel )
game/server/cstrike/cs_player.cpp:	for ( int i = 1 ; i <= gpGlobals->maxClients ; i++ )
game/server/cstrike/cs_player.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/bot/cs_bot.h:	if (!m_enemy->IsAlive() && gpGlobals->curtime - GetEnemyDeathTimestamp() > (1.0f - 0.8f * GetProfile()->GetSkill()))
game/server/cstrike/bot/cs_bot.h:	return gpGlobals->curtime - m_followTimestamp;
game/server/cstrike/bot/cs_bot.h:	return (gpGlobals->curtime > m_allowAutoFollowTime);
game/server/cstrike/bot/cs_bot.h:	return gpGlobals->curtime - m_attackedTimestamp;
game/server/cstrike/bot/cs_bot.h:	return gpGlobals->curtime - m_lastSawEnemyTimestamp;
game/server/cstrike/bot/cs_bot.h:	return gpGlobals->curtime - m_currentEnemyAcquireTimestamp;
game/server/cstrike/bot/cs_bot.h:	return m_voiceEndTimestamp > gpGlobals->curtime; 
game/server/cstrike/bot/cs_bot_weapon.cpp:	if (gpGlobals->curtime > m_fireWeaponTimestamp &&
game/server/cstrike/bot/cs_bot_weapon.cpp:			//gpGlobals->curtime > m_reacquireTimestamp &&
game/server/cstrike/bot/cs_bot_weapon.cpp:				m_fireWeaponTimestamp += gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_weapon.cpp:			m_aimSpreadTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_weapon.cpp:		float focusInterval = gpGlobals->curtime - m_aimSpreadTimestamp;
game/server/cstrike/bot/cs_bot_weapon.cpp:	m_aimOffsetTimestamp = gpGlobals->curtime + RandomFloat( 0.25f, 1.0f ); // 0.25, 1.5f
game/server/cstrike/bot/cs_bot_weapon.cpp:	if (gpGlobals->curtime >= m_aimOffsetTimestamp)
game/server/cstrike/bot/cs_bot_weapon.cpp:		PrintIfWatched( "%3.2f: Grenade: START_THROW\n", gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_weapon.cpp:	return ( GetActiveWeapon() && GetActiveWeapon()->m_flNextPrimaryAttack <= gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_weapon.cpp:	if (tossArea->GetEarliestOccupyTime( enemyTeam ) > gpGlobals->curtime)
game/server/cstrike/bot/cs_bot_weapon.cpp:				PrintIfWatched( "%3.2f: Grenade: THROW FAILED\n", gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_weapon.cpp:					PrintIfWatched( "%3.2f: Grenade: FINISH_THROW\n", gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_weapon.cpp:					PrintIfWatched( "%3.2f: Grenade: Friend is in the way...\n", gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_weapon.cpp:				PrintIfWatched( "%3.2f: Grenade: THROW COMPLETE\n", gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_weapon.cpp:			if (ag->IsFlashbang() && ag->GetEntity()->m_flDetonateTime - gpGlobals->curtime < aboutToBlow)
game/server/cstrike/bot/cs_bot_weapon.cpp:		if ( weapon->m_flNextSecondaryAttack >= gpGlobals->curtime )
game/server/cstrike/bot/cs_bot_weapon.cpp:	return (weapon && !weapon->IsSilenced() && weapon->m_flNextPrimaryAttack > gpGlobals->curtime);
game/server/cstrike/bot/cs_bot_manager.cpp:	m_earliestBombPlantTimestamp = gpGlobals->curtime + RandomFloat( 10.0f, 30.0f ); // 60
game/server/cstrike/bot/cs_bot_manager.cpp:	m_roundStartTimestamp = gpGlobals->curtime + mp_freezetime.GetFloat();
game/server/cstrike/bot/cs_bot_manager.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot_manager.cpp:	for (int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot_manager.cpp:	for ( i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot_manager.cpp:	for ( i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot_manager.cpp:		desiredBotCount = MIN( desiredBotCount, gpGlobals->maxClients - (humanPlayersInGame + 1) );
game/server/cstrike/bot/cs_bot_manager.cpp:		desiredBotCount = MIN( desiredBotCount, gpGlobals->maxClients - humanPlayersInGame );
game/server/cstrike/bot/cs_bot_manager.cpp:	for( i=1; i<gpGlobals->maxEntities; ++i )
game/server/cstrike/bot/cs_bot_manager.cpp:	m_bombPlantTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_manager.cpp:					gpGlobals->curtime, i, m_zone[i].m_area[0]->GetID(),
game/server/cstrike/bot/cs_bot_manager.cpp:	return (mp_c4timer.GetFloat() - (gpGlobals->curtime - m_bombPlantTimestamp));
game/server/cstrike/bot/cs_bot_manager.cpp:		return gpGlobals->curtime - m_radioMsgTimestamp[ event - RADIO_START_1 ][ i ];
game/server/cstrike/bot/cs_bot_manager.cpp:		m_radioMsgTimestamp[ event - RADIO_START_1 ][ i ] = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_vision.cpp:	if (gpGlobals->framecount > info->m_validFrame)
game/server/cstrike/bot/cs_bot_vision.cpp:		info->m_validFrame = gpGlobals->framecount;
game/server/cstrike/bot/cs_bot_vision.cpp:	PrintIfWatched( "%3.1f SetLookAt( %s ), duration = %f\n", gpGlobals->curtime, desc, duration );
game/server/cstrike/bot/cs_bot_vision.cpp:	m_inhibitLookAroundTimestamp = gpGlobals->curtime + duration;
game/server/cstrike/bot/cs_bot_vision.cpp:	if (gpGlobals->curtime - m_peripheralTimestamp < peripheralUpdateInterval)
game/server/cstrike/bot/cs_bot_vision.cpp:	m_peripheralTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_vision.cpp:		if (!IsLookingAtSpot( PRIORITY_MEDIUM ) && gpGlobals->curtime - m_lastSawEnemyTimestamp < recentThreatTime)
game/server/cstrike/bot/cs_bot_vision.cpp:	if (gpGlobals->curtime < m_inhibitLookAroundTimestamp)
game/server/cstrike/bot/cs_bot_vision.cpp:		if (gpGlobals->curtime < m_lookAroundStateTimestamp)
game/server/cstrike/bot/cs_bot_vision.cpp:			m_lookAroundStateTimestamp = gpGlobals->curtime + RandomFloat( 5.0f, 10.0f );
game/server/cstrike/bot/cs_bot_vision.cpp:			m_lookAroundStateTimestamp = gpGlobals->curtime + RandomFloat( 1.0f, 2.0f );	// 0.5, 1.0
game/server/cstrike/bot/cs_bot_vision.cpp:			if (gpGlobals->curtime < m_spotCheckTimestamp)
game/server/cstrike/bot/cs_bot_vision.cpp:			m_spotCheckTimestamp = gpGlobals->curtime + asleep * RandomFloat( 10.0f, 30.0f );
game/server/cstrike/bot/cs_bot_vision.cpp:				if (gpGlobals->curtime - GetHidingSpotCheckTimestamp( spotOrder->spot ) <= checkTime)
game/server/cstrike/bot/cs_bot_vision.cpp:		for( i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot_vision.cpp:					m_watchInfo[idx].timestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_vision.cpp:			m_watchInfo[idx].timestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_vision.cpp:			if (gpGlobals->curtime - m_watchInfo[i].timestamp < recentTime)
game/server/cstrike/bot/cs_bot_vision.cpp:			m_firstSawEnemyTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_chatter.cpp:	for( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/bot/cs_bot_chatter.cpp:	m_timestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_chatter.cpp:	m_startTime = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_chatter.cpp:	m_expireTime = gpGlobals->curtime + expireDuration;
game/server/cstrike/bot/cs_bot_chatter.cpp:	return (gpGlobals->curtime > m_expireTime);
game/server/cstrike/bot/cs_bot_chatter.cpp:				m_startTime = gpGlobals->curtime + RandomFloat( 0.5f, 1.0f );
game/server/cstrike/bot/cs_bot_chatter.cpp:				m_startTime = gpGlobals->curtime + RandomFloat( 3.0f, 4.0f );
game/server/cstrike/bot/cs_bot_chatter.cpp:		m_speakTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_chatter.cpp:		if (me->GetNearbyEnemyCount() > 3 || gpGlobals->curtime - m_speakTimestamp > reportTime)
game/server/cstrike/bot/cs_bot_chatter.cpp:	if (gpGlobals->curtime > m_nextTime)
game/server/cstrike/bot/cs_bot_chatter.cpp:					m_nextTime = gpGlobals->curtime + RandomFloat( 0.1f, 0.5f );
game/server/cstrike/bot/cs_bot_chatter.cpp:					m_nextTime = gpGlobals->curtime + RandomFloat( 1.0f, 2.0f );
game/server/cstrike/bot/cs_bot_chatter.cpp:			m_nextTime = gpGlobals->curtime + duration + gap;
game/server/cstrike/bot/cs_bot_chatter.cpp:		m_timeWhenSawFirstEnemy = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_chatter.cpp:	for( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/bot/cs_bot_chatter.cpp:	if (earliest && earliest->GetStartTime() > gpGlobals->curtime)
game/server/cstrike/bot/cs_bot_chatter.cpp:		say->SetStartTime( gpGlobals->curtime + 2.0f );
game/server/cstrike/bot/cs_bot_chatter.cpp:	say->SetStartTime( gpGlobals->curtime + RandomFloat( 2.0f, 4.0f ) );
game/server/cstrike/bot/cs_bot_chatter.cpp:	say->SetStartTime( gpGlobals->curtime + RandomFloat( 2.0f, 5.0f ) );
game/server/cstrike/bot/cs_bot_chatter.cpp:	say->SetStartTime( gpGlobals->curtime + RandomFloat( 0.5f, 1.0f ) );
game/server/cstrike/bot/cs_bot_chatter.cpp:	say->SetStartTime( gpGlobals->curtime + RandomFloat( 0.3f, 0.5f ) );
game/server/cstrike/bot/cs_bot_event.cpp:											gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_event.cpp:			if (gpGlobals->curtime - m_noiseTimestamp < shortTermMemoryTime)
game/server/cstrike/bot/cs_bot_event.cpp:		m_noiseTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/states/cs_bot_attack.cpp:	m_pinnedDownTimestamp = gpGlobals->curtime + RandomFloat( 7.0f, 10.0f );
game/server/cstrike/bot/states/cs_bot_attack.cpp:	m_shieldToggleTimestamp = gpGlobals->curtime + RandomFloat( 2.0f, 10.0f );
game/server/cstrike/bot/states/cs_bot_attack.cpp:		else if (gpGlobals->curtime >= m_nextDodgeStateTimestamp)
game/server/cstrike/bot/states/cs_bot_attack.cpp:			m_nextDodgeStateTimestamp = gpGlobals->curtime + RandomFloat( 0.3f, 1.0f );
game/server/cstrike/bot/states/cs_bot_attack.cpp:		bool isPinnedDown = (gpGlobals->curtime > m_pinnedDownTimestamp);
game/server/cstrike/bot/states/cs_bot_attack.cpp:		if (gpGlobals->curtime > m_shieldToggleTimestamp)
game/server/cstrike/bot/states/cs_bot_attack.cpp:			m_shieldToggleTimestamp = gpGlobals->curtime + RandomFloat( 0.5, 2.0f );
game/server/cstrike/bot/states/cs_bot_attack.cpp:			m_scopeTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/states/cs_bot_attack.cpp:			m_scopeTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/states/cs_bot_attack.cpp:		if (gpGlobals->curtime - m_scopeTimestamp < waitScopeTime)
game/server/cstrike/bot/states/cs_bot_attack.cpp:	float notSeenEnemyTime = gpGlobals->curtime - me->GetLastSawEnemyTimestamp();
game/server/cstrike/bot/states/cs_bot_attack.cpp:			m_reacquireTimestamp = gpGlobals->curtime + me->GetProfile()->GetReactionTime();
game/server/cstrike/bot/states/cs_bot_attack.cpp:	if (true || gpGlobals->curtime > m_reacquireTimestamp)
game/server/cstrike/bot/states/cs_bot_move_to.cpp:								if (gpGlobals->curtime - me->GetStateTimestamp() > radioTime)
game/server/cstrike/bot/states/cs_bot_move_to.cpp:					say->SetStartTime( gpGlobals->curtime + RandomFloat( 3.0f, 5.0f ) );
game/server/cstrike/bot/states/cs_bot_follow.cpp:		m_lastSawLeaderTime = gpGlobals->curtime;
game/server/cstrike/bot/states/cs_bot_follow.cpp:	if (gpGlobals->curtime - m_lastSawLeaderTime > longTime)
game/server/cstrike/bot/states/cs_bot_follow.cpp:				me->PrintIfWatched( "%4.1f: Bored. Repathing to a new nearby area\n", gpGlobals->curtime );
game/server/cstrike/bot/states/cs_bot_follow.cpp:				me->PrintIfWatched( "%4.1f: Repathing to stay with leader.\n", gpGlobals->curtime );
game/server/cstrike/bot/states/cs_bot_hunt.cpp:	if (gpGlobals->curtime - me->GetStateTimestamp() > huntingTooLongTime)
game/server/cstrike/bot/states/cs_bot_hunt.cpp:						(me->IsAtBombsite() && gpGlobals->curtime - me->GetLastSawEnemyTimestamp() > safeTime))
game/server/cstrike/bot/states/cs_bot_hunt.cpp:				float age = gpGlobals->curtime - area->GetClearedTimestamp( me->GetTeamNumber()-1 );
game/server/cstrike/bot/states/cs_bot_defuse_bomb.cpp:	if (gpGlobals->curtime - me->GetStateTimestamp() > 1.0f)
game/server/cstrike/bot/states/cs_bot_buy.cpp:		if (gpGlobals->curtime - me->GetStateTimestamp() < waitToBuyTime)
game/server/cstrike/bot/states/cs_bot_buy.cpp:	if (gpGlobals->curtime - me->GetStateTimestamp() > buyInterval)
game/server/cstrike/bot/states/cs_bot_buy.cpp:		me->m_stateTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/states/cs_bot_hide.cpp:			if (m_isHoldingPosition && m_heardEnemy && (gpGlobals->curtime - m_firstHeardEnemyTime > m_holdPositionTime))
game/server/cstrike/bot/states/cs_bot_hide.cpp:						m_firstHeardEnemyTime = gpGlobals->curtime;
game/server/cstrike/bot/states/cs_bot_use_entity.cpp:	if (me->GetStateTimestamp() - gpGlobals->curtime > useTimeout)
game/server/cstrike/bot/states/cs_bot_plant_bomb.cpp:	if (gpGlobals->curtime - me->GetStateTimestamp() > timeout)
game/server/cstrike/bot/cs_bot_event_player.cpp:		m_friendDeathTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_event_player.cpp:			m_lastRadioRecievedTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_radio.cpp:	if (gpGlobals->curtime - m_lastRadioRecievedTimestamp < respondTime)
game/server/cstrike/bot/cs_bot_radio.cpp:	PrintIfWatched( "%3.1f: SendRadioMessage( %s )\n", gpGlobals->curtime, RadioEventName[ event ] );
game/server/cstrike/bot/cs_bot_radio.cpp:	m_lastRadioSentTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_radio.cpp:	m_voiceEndTimestamp = gpGlobals->curtime + duration;
game/server/cstrike/bot/cs_bot_pathfind.cpp:		m_areaEnteredTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_pathfind.cpp:		m_pathLadderTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_pathfind.cpp:	if (gpGlobals->curtime - m_pathLadderTimestamp > ladderTimeoutDuration && !cv_bot_debug.GetBool())
game/server/cstrike/bot/cs_bot_pathfind.cpp:	m_areaEnteredTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_pathfind.cpp:				m_pathLadderDismountTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_pathfind.cpp:			if (gpGlobals->curtime - m_pathLadderDismountTimestamp >= 0.4f)
game/server/cstrike/bot/cs_bot_pathfind.cpp:	m_areaEnteredTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_pathfind.cpp:	for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot_pathfind.cpp:	if (didFall || gpGlobals->curtime - m_areaEnteredTimestamp > giveUpDuration)
game/server/cstrike/bot/cs_bot_pathfind.cpp:	m_areaEnteredTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_pathfind.cpp:	m_areaEnteredTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_listen.cpp:	if (gpGlobals->curtime - m_noiseTimestamp >= GetProfile()->GetReactionTime())
game/server/cstrike/bot/cs_bot_listen.cpp:	if (gpGlobals->curtime - m_noiseTimestamp > 0.5f)
game/server/cstrike/bot/cs_bot_manager.h:		for ( int idx = 1; idx <= gpGlobals->maxClients; ++idx ) \
game/server/cstrike/bot/cs_bot_manager.h:	void SetLastSeenEnemyTimestamp( void ) 			{ m_lastSeenEnemyTimestamp = gpGlobals->curtime; }
game/server/cstrike/bot/cs_bot_manager.h:	float GetElapsedRoundTime( void ) const			{ return gpGlobals->curtime - m_roundStartTimestamp; }	///< return the elapsed time since the current round began
game/server/cstrike/bot/cs_bot_manager.h:	return (gpGlobals->curtime >= m_earliestBombPlantTimestamp);
game/server/cstrike/bot/cs_bot_nav.cpp:		else if ( GetActiveWeapon() && GetActiveWeapon()->m_flNextPrimaryAttack <= gpGlobals->curtime )
game/server/cstrike/bot/cs_bot_nav.cpp:	m_areaEnteredTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_nav.cpp:				m_stuckTimestamp = gpGlobals->curtime;			
game/server/cstrike/bot/cs_bot_init.cpp:		for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot_update.cpp:					m_lookAtSpotTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_update.cpp:				if (m_lookAtSpotDuration >= 0.0f && gpGlobals->curtime - m_lookAtSpotTimestamp > m_lookAtSpotDuration)
game/server/cstrike/bot/cs_bot_update.cpp:			m_lookYaw += driftAmplitude * BotCOS( 33.0f * gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_update.cpp:			m_lookPitch += driftAmplitude * BotSIN( 13.0f * gpGlobals->curtime );
game/server/cstrike/bot/cs_bot_update.cpp:	if (m_noiseTimestamp > 0.0f && gpGlobals->curtime - m_noiseTimestamp > rememberNoiseDuration)
game/server/cstrike/bot/cs_bot_update.cpp:				m_lastSawEnemyTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_update.cpp:				m_enemyDeathTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_update.cpp:	if (gpGlobals->curtime - m_avoidTimestamp < avoidTime && m_avoid != NULL)
game/server/cstrike/bot/cs_bot_update.cpp:			m_allowAutoFollowTime = gpGlobals->curtime + 15.0f + (1.0f - GetProfile()->GetTeamwork()) * 30.0f;
game/server/cstrike/bot/cs_bot_update.cpp:		for( int i=1; i<=gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot.cpp:	for( int i=1; i <= gpGlobals->maxClients; ++i )
game/server/cstrike/bot/cs_bot.cpp:		m_attackedTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot.cpp:		m_avoidTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot.cpp:		m_currentEnemyAcquireTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot.cpp:	float leastRecentTime = gpGlobals->curtime + 1.0f;
game/server/cstrike/bot/cs_bot.cpp:			m_checkedHidingSpot[i].timestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot.cpp:		m_checkedHidingSpot[ m_checkedHidingSpotCount ].timestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot.cpp:		m_checkedHidingSpot[ leastRecent ].timestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot.cpp:	if (m_hostageEscortCount == 0 || gpGlobals->curtime - m_hostageEscortCountTimestamp < updateInterval)
game/server/cstrike/bot/cs_bot.cpp:	m_hostageEscortCountTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/bot/cs_bot.cpp:		cmd.command_number = gpGlobals->tickcount;
game/server/cstrike/bot/cs_bot_chatter.h:		say->SetStartTime( gpGlobals->curtime + delay );
game/server/cstrike/bot/cs_bot_statemachine.cpp:	m_stateTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_statemachine.cpp:		m_followTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_statemachine.cpp:	m_allowAutoFollowTime = gpGlobals->curtime + 10.0f;
game/server/cstrike/bot/cs_bot_statemachine.cpp:	m_lastSawEnemyTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_statemachine.cpp:	m_aimSpreadTimestamp = gpGlobals->curtime;
game/server/cstrike/bot/cs_bot_statemachine.cpp:	m_aimOffsetTimestamp = gpGlobals->curtime + RandomFloat( 0.25f + turn, 1.5f );
game/server/cstrike/cs_nav_path.cpp:		float deltaT = gpGlobals->curtime - m_lastTime;
game/server/cstrike/cs_nav_path.cpp:		m_lastTime = gpGlobals->curtime;
game/server/cstrike/hostage/cs_simple_hostage.cpp:	SetNextThink( gpGlobals->curtime + HOSTAGE_THINK_INTERVAL );
game/server/cstrike/hostage/cs_simple_hostage.cpp:	SetContextThink( &CHostage::PushawayThink, gpGlobals->curtime + PUSHAWAY_THINK_INTERVAL, HOSTAGE_PUSHAWAY_THINK_CONTEXT );
game/server/cstrike/hostage/cs_simple_hostage.cpp:		m_disappearTime = gpGlobals->curtime + 3.0f;
game/server/cstrike/hostage/cs_simple_hostage.cpp:					if (gpGlobals->curtime - CSGameRules()->GetRoundStartTime() < AchievementConsts::FastHostageRescue_Time)
game/server/cstrike/hostage/cs_simple_hostage.cpp:	SetNextThink( gpGlobals->curtime + PUSHAWAY_THINK_INTERVAL, HOSTAGE_PUSHAWAY_THINK_CONTEXT );
game/server/cstrike/hostage/cs_simple_hostage.cpp:	SetNextThink( gpGlobals->curtime + deltaT );
game/server/cstrike/hostage/cs_simple_hostage.cpp:	if ( m_disappearTime && m_disappearTime < gpGlobals->curtime )
game/server/cstrike/cs_gamestats.cpp:		for ( int i = 1 ; i <= gpGlobals->maxClients ; i++ )
game/server/cstrike/cs_gamestats.cpp:	const char *pzMapName = gpGlobals->mapname.ToCStr();
game/server/cstrike/cs_gamestats.cpp:    int mapIndex = GetCSLevelIndex(gpGlobals->mapname.ToCStr());
game/server/cstrike/cs_gamestats.cpp:	//	year, month, day, hour, minute, second, gpGlobals->mapname.ToCStr());
game/server/cstrike/cs_gamestats.cpp:			    if (ServerStatBasedAchievements[i].mapFilter != NULL && V_strcmp(gpGlobals->mapname.ToCStr(), ServerStatBasedAchievements[i].mapFilter) != 0)
game/server/cstrike/cs_gamestats.cpp:				if (ServerStatBasedAchievements[i].mapFilter != NULL && V_strcmp(gpGlobals->mapname.ToCStr(), ServerStatBasedAchievements[i].mapFilter) != 0)
game/server/cstrike/cs_gamestats.cpp:	m_fDisseminationTimerHigh += gpGlobals->frametime;
game/server/cstrike/cs_gamestats.cpp:	m_fDisseminationTimerLow += gpGlobals->frametime;
game/server/cstrike/cs_gamestats.cpp:        for ( int i = 1 ; i <= gpGlobals->maxClients ; i++ )
game/server/cstrike/funfact_cs.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/funfact_cs.cpp:		  for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/funfact_cs.cpp:		  for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/funfact_cs.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/funfact_cs.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/funfact_cs.cpp:    for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/funfact_cs.cpp:    for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/funfact_cs.cpp:    for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/smokegrenade_projectile.cpp:	SetNextThink( gpGlobals->curtime + timer );
game/server/cstrike/smokegrenade_projectile.cpp:		SetNextThink( gpGlobals->curtime + 0.2 );
game/server/cstrike/smokegrenade_projectile.cpp:	SetNextThink( gpGlobals->curtime + 5 );
game/server/cstrike/smokegrenade_projectile.cpp:	SetNextThink( gpGlobals->curtime );
game/server/cstrike/smokegrenade_projectile.cpp:		SetNextThink( gpGlobals->curtime + 20 );
game/server/cstrike/cs_gamestats.h:		const char *pszMapName = gpGlobals->mapname.ToCStr() ? gpGlobals->mapname.ToCStr() : "unknown";
game/server/cstrike/cs_client.cpp:	if (gpGlobals->coop || gpGlobals->deathmatch)
game/server/cstrike/cs_client.cpp:	gpGlobals->teamplay = teamplay.GetInt() ? true : false;
game/server/cstrike/cs_player_resource.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/cs_bot_temp.cpp:	pData->m_flJoinTeamTime = gpGlobals->curtime + 0.3;
game/server/cstrike/cs_bot_temp.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/cstrike/cs_bot_temp.cpp:	if ( bot_mimic.GetInt() > gpGlobals->maxClients )
game/server/cstrike/cs_bot_temp.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/cstrike/cs_bot_temp.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/cstrike/cs_bot_temp.cpp:	float flTimeBase = gpGlobals->curtime;
game/server/cstrike/cs_bot_temp.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/cstrike/cs_bot_temp.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/cstrike/cs_bot_temp.cpp:	float frametime = gpGlobals->frametime;
game/server/cstrike/cs_bot_temp.cpp:	if ( pBot->GetTeamNumber() == TEAM_UNASSIGNED && gpGlobals->curtime > botdata->m_flJoinTeamTime )
game/server/cstrike/cs_bot_temp.cpp:						//if ( gpGlobals->curtime < botdata->nextturntime )
game/server/cstrike/cs_bot_temp.cpp:					botdata->nextturntime = gpGlobals->curtime + 2.0;
game/server/cstrike/cs_bot_temp.cpp:				if ( gpGlobals->curtime >= botdata->nextstrafetime )
game/server/cstrike/cs_bot_temp.cpp:					botdata->nextstrafetime = gpGlobals->curtime + 1.0f;
game/server/cstrike/cs_bot_temp.cpp:		iBotClient >= gpGlobals->maxClients || 
game/server/cstrike/cs_gameinterface.cpp:	if ( Q_strcmp( STRING(gpGlobals->mapname), "cs_" ) )
game/server/cstrike/holiday_gift.cpp:	SetContextThink( &CBaseEntity::SUB_Remove, gpGlobals->curtime + 30, "DIE_THINK" );
game/server/cstrike/holiday_gift.cpp:	SetContextThink( &CHolidayGift::DropSoundThink, gpGlobals->curtime + 0.2f, "SOUND_THINK" );
game/server/doors.cpp:		int		fplaysound = (pls->sLockedSound != NULL_STRING && gpGlobals->curtime > pls->flwaitSound);
game/server/doors.cpp:		int		fplaysentence = (pls->sLockedSentence != NULL_STRING && !pls->bEOFLocked && gpGlobals->curtime > pls->flwaitSentence);
game/server/doors.cpp:			pls->flwaitSound = gpGlobals->curtime + flsoundwait;
game/server/doors.cpp:			pls->flwaitSentence = gpGlobals->curtime + DOOR_SENTENCEWAIT;
game/server/doors.cpp:		int fplaysound = (pls->sUnlockedSound != NULL_STRING && gpGlobals->curtime > pls->flwaitSound);
game/server/doors.cpp:		int fplaysentence = (pls->sUnlockedSentence != NULL_STRING && !pls->bEOFUnlocked && gpGlobals->curtime > pls->flwaitSentence);
game/server/doors.cpp:			pls->flwaitSound = gpGlobals->curtime + flsoundwait;
game/server/doors.cpp:			pls->flwaitSentence = gpGlobals->curtime + DOOR_SENTENCEWAIT;
game/server/doors.cpp:		SetContextThink( &CBaseDoor::MovingSoundThink, gpGlobals->curtime + duration, "MovingSound" );
game/server/doors.cpp:	SetContextThink( NULL, gpGlobals->curtime, "MovingSound" );
game/server/doors.cpp:	SetContextThink( NULL, gpGlobals->curtime, CLOSE_AREAPORTAL_THINK_CONTEXT );
game/server/doors.cpp:	SetContextThink( NULL, gpGlobals->curtime, CLOSE_AREAPORTAL_THINK_CONTEXT );
game/server/doors.cpp:	SetContextThink( &CBaseDoor::CloseAreaPortalsThink, gpGlobals->curtime + 0.5f, CLOSE_AREAPORTAL_THINK_CONTEXT );
game/server/EnvLaser.cpp:	m_flFireTime = gpGlobals->curtime;
game/server/EnvLaser.cpp:	if ( gpGlobals->curtime >= m_flFireTime + 0.1 )
game/server/EnvLaser.cpp:	SetNextThink( gpGlobals->curtime );
game/server/basecombatcharacter.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/basecombatcharacter.cpp:		if ( gpGlobals->curtime - g_VisibilityCache[iCache].time < VIS_CACHE_ENTRY_LIFE )
game/server/basecombatcharacter.cpp:	g_VisibilityCache[iCache].time = gpGlobals->curtime;
game/server/basecombatcharacter.cpp:	if ( gpGlobals->eLoadType == MapLoad_Transition )
game/server/basecombatcharacter.cpp:	CRagdollBoogie::Create( pRagdoll, 200, gpGlobals->curtime, duration, flags );
game/server/basecombatcharacter.cpp:			bRagdollCreated = Dissolve( NULL, gpGlobals->curtime, false, nDissolveType );
game/server/basecombatcharacter.cpp:				pDroppedWeapon->Dissolve( NULL, gpGlobals->curtime, false, nDissolveType );
game/server/basecombatcharacter.cpp:				pDroppedWeapon->Dissolve( NULL, gpGlobals->curtime, false, ENTITY_DISSOLVE_NORMAL );
game/server/basecombatcharacter.cpp:		if( FStrEq(STRING(gpGlobals->mapname), "d3_c17_09") && FClassnameIs(pWeapon, "weapon_rpg") && pWeapon->NameMatches("player_spawn_items") )
game/server/basecombatcharacter.cpp:		dmgInfo.SetDamageForce( Vector( 0, 0, -stressOut.receivedStress * GetCurrentGravity() * gpGlobals->frametime ) );
game/server/GameStats.cpp:		DevMsg( "[GS %s - %7.2f] %s", timeString, gpGlobals->realtime, buf );
game/server/GameStats.cpp:			filesystem->FPrintf( g_LogFileHandle, "[GS %s - %7.2f] %s", timeString, gpGlobals->realtime, buf );
game/server/GameStats.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/GameStats.cpp:		elapsed = gpGlobals->realtime - CBGSDriver.m_flLevelStartTime;
game/server/GameStats.cpp:		Warning( "EVENT_CREDITS with negative elapsed time (rt %f starttime %f)\n", gpGlobals->realtime, CBGSDriver.m_flLevelStartTime );
game/server/GameStats.cpp:	if ( Q_stricmp( m_PrevMapName.String(), STRING( gpGlobals->mapname ) ) )
game/server/GameStats.cpp:		m_PrevMapName = STRING( gpGlobals->mapname );
game/server/GameStats.cpp:		gamestats->Event_MapChange( PrevMapBackup.String(), STRING( gpGlobals->mapname ) );
game/server/GameStats.cpp:	m_flLevelStartTime = gpGlobals->realtime;
game/server/GameStats.cpp:	float flElapsed = gpGlobals->realtime - m_flLevelStartTime;
game/server/GameStats.cpp:		Warning( "EVENT_LEVELSHUTDOWN:  with negative elapsed time (rt %f starttime %f)\n", gpGlobals->realtime, m_flLevelStartTime );
game/server/GameStats.cpp:	if ( m_bInLevel && ( gpGlobals->eLoadType != MapLoad_Background ) )
game/server/GameStats.cpp:	bool bGamePaused = ( gpGlobals->frametime == 0.0f );
game/server/GameStats.cpp:			m_flPauseStartTime = gpGlobals->realtime;
game/server/GameStats.cpp:			float flPausedTime = gpGlobals->realtime - m_flPauseStartTime;
game/server/GameStats.cpp:				Warning( "Game paused time showing up negative (rt %f pausestart %f)\n", gpGlobals->realtime, m_flPauseStartTime );
game/server/serverbenchmark_base.h:// to get a tick count since the start of the benchmark instead of looking at gpGlobals->tickcount.
game/server/ai_behavior_fear.cpp:		m_flTimeToSafety = gpGlobals->curtime + BEHAVIOR_FEAR_SAFETY_TIME;
game/server/ai_behavior_fear.cpp:			m_flTimeToSafety = gpGlobals->curtime + BEHAVIOR_FEAR_SAFETY_TIME;
game/server/ai_behavior_fear.cpp:			if( gpGlobals->curtime > m_flTimeToSafety )
game/server/ai_behavior_fear.cpp:						m_flDeferUntil = gpGlobals->curtime + 3.0f;// Don't bang the hell out of this behavior. If we don't find a node, take a short break and run regular AI.
game/server/ai_behavior_fear.cpp:	if( m_flDeferUntil > gpGlobals->curtime )
game/server/ai_behavior_fear.cpp:		m_flTimePlayerLastVisible = gpGlobals->curtime;
game/server/ai_behavior_fear.cpp:		if( gpGlobals->curtime - m_flTimePlayerLastVisible >= 2.0f )
game/server/ai_behavior_fear.cpp:	m_flTimePlayerLastVisible = gpGlobals->curtime;
game/server/soundent.h:	MAX_WORLD_SOUNDS_MP	= 128	// The sound array size is set this large but we'll only use gpGlobals->maxPlayers+32 entries in mp.
game/server/triggers.cpp:		SetNextThink( gpGlobals->curtime + random->RandomFloat(0.0, 0.5) );
game/server/triggers.cpp:	float dt = gpGlobals->curtime - m_flLastDmgTime;
game/server/triggers.cpp:	SetNextThink( gpGlobals->curtime + 0.25 );
game/server/triggers.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/triggers.cpp:	m_flLastDmgTime = gpGlobals->curtime;
game/server/triggers.cpp:			if( gpGlobals->curtime > m_flDmgResetTime  )
game/server/triggers.cpp:			m_flDmgResetTime = gpGlobals->curtime + TRIGGER_HURT_FORGIVE_TIME;
game/server/triggers.cpp:		SetNextThink( gpGlobals->curtime );
game/server/triggers.cpp:	if (GetNextThink() > gpGlobals->curtime)
game/server/triggers.cpp:		SetNextThink( gpGlobals->curtime + m_flWait );
game/server/triggers.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/triggers.cpp:		SetNextThink(gpGlobals->curtime + m_flTimeoutDuration);
game/server/triggers.cpp:				m_flLookTimeLast	= gpGlobals->curtime;
game/server/triggers.cpp:				m_flLookTimeTotal	+= gpGlobals->curtime - m_flLookTimeLast;
game/server/triggers.cpp:				m_flLookTimeLast	=  gpGlobals->curtime;
game/server/triggers.cpp:		SetNextThink(gpGlobals->curtime);
game/server/triggers.cpp:	if ( gpGlobals->eLoadType == MapLoad_NewGame )
game/server/triggers.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/triggers.cpp:	if ( stricmp( pMapName, STRING(gpGlobals->mapname) ) == 0 )
game/server/triggers.cpp:	if ( !gpGlobals->pSaveData || ( static_cast<CSaveRestoreData *>(gpGlobals->pSaveData)->NumEntities() == 0 ) )
game/server/triggers.cpp:	CSave saveHelper( static_cast<CSaveRestoreData *>(gpGlobals->pSaveData) );
game/server/triggers.cpp:				pPhys->ApplyForceCenter( m_flPushSpeed * vecAbsDir * 100.0f * gpGlobals->frametime );
game/server/triggers.cpp:		if ( g_ServerGameDLL.m_fAutoSaveDangerousTime != 0.0f && g_ServerGameDLL.m_fAutoSaveDangerousTime >= gpGlobals->curtime )
game/server/triggers.cpp:			if ( pPlayer->GetDeathTime() == 0.0f || pPlayer->GetDeathTime() > gpGlobals->curtime )
game/server/triggers.cpp:			g_ServerGameDLL.m_fAutoSaveDangerousTime = gpGlobals->curtime + m_fDangerousTimer;
game/server/triggers.cpp:	m_flReturnTime = gpGlobals->curtime + m_flWait;
game/server/triggers.cpp:	m_flStopTime = gpGlobals->curtime;
game/server/triggers.cpp:		m_flInterpStartTime = gpGlobals->curtime;
game/server/triggers.cpp:		SetNextThink( gpGlobals->curtime );
game/server/triggers.cpp:	m_flReturnTime = gpGlobals->curtime;
game/server/triggers.cpp:	if ( !HasSpawnFlags(SF_CAMERA_PLAYER_INFINITE_WAIT) && (!m_hTarget || m_flReturnTime < gpGlobals->curtime) )
game/server/triggers.cpp:		vecAngVel.Init( dx * 40 * gpGlobals->frametime, dy * 40 * gpGlobals->frametime, GetLocalAngularVelocity().z );
game/server/triggers.cpp:	SetNextThink( gpGlobals->curtime );
game/server/triggers.cpp:		m_moveDistance -= m_flSpeed * gpGlobals->frametime;
game/server/triggers.cpp:				m_flStopTime = gpGlobals->curtime + m_pPath->GetDelay();
game/server/triggers.cpp:		if ( m_flStopTime > gpGlobals->curtime )
game/server/triggers.cpp:			m_flSpeed = UTIL_Approach( 0, m_flSpeed, m_deceleration * gpGlobals->frametime );
game/server/triggers.cpp:			m_flSpeed = UTIL_Approach( m_targetSpeed, m_flSpeed, m_acceleration * gpGlobals->frametime );
game/server/triggers.cpp:		float fraction = 2 * gpGlobals->frametime;
game/server/triggers.cpp:		float tt = (gpGlobals->curtime - m_flInterpStartTime) / kflPosInterpTime;
game/server/triggers.cpp:			Vector desiredVel = (nextPos - GetAbsOrigin()) * (1.0f / gpGlobals->frametime);
game/server/triggers.cpp:	Assert(gpGlobals->maxClients == 1);
game/server/triggers.cpp:		SetNextThink( gpGlobals->curtime );
game/server/triggers.cpp:	SetNextThink( gpGlobals->curtime );
game/server/triggers.cpp:		vWindAngle[1] = m_nWindYaw+(30*cos(nNoiseMod * gpGlobals->curtime + nNoiseMod));
game/server/triggers.cpp:		vWind.z = 1.1 + (1.0 * sin(nNoiseMod * gpGlobals->curtime + nNoiseMod));
game/server/triggers.cpp:	SetContextThink( &CTriggerWind::WindThink, gpGlobals->curtime, WIND_THINK_CONTEXT );
game/server/triggers.cpp:	SetContextThink( &CTriggerWind::WindThink, gpGlobals->curtime + 0.1f, WIND_THINK_CONTEXT );
game/server/triggers.cpp:	SetContextThink( &CTriggerWind::WindThink, gpGlobals->curtime + 0.1, WIND_THINK_CONTEXT );
game/server/triggers.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/triggers.cpp:	float dt = gpGlobals->curtime - m_linearLimitStartTime;
game/server/triggers.cpp:	m_linearLimitStartTime = gpGlobals->curtime;
game/server/EffectsServer.cpp:	return gpGlobals->curtime;
game/server/physics_main.cpp:		info.m_pEntity->UpdatePhysicsShadowToCurrentPosition( gpGlobals->frametime );
game/server/physics_main.cpp:		info.m_pEntity->UpdatePhysicsShadowToCurrentPosition( gpGlobals->frametime );
game/server/physics_main.cpp:					SetGroundChangeTime( gpGlobals->curtime + (flTime - (1 - trace.fraction) * time_left) );
game/server/physics_main.cpp:	vecAbsVelocity[2] += GetBaseVelocity()[2] * gpGlobals->frametime;
game/server/physics_main.cpp:	if (movetime > gpGlobals->frametime)
game/server/physics_main.cpp:		movetime = gpGlobals->frametime;
game/server/physics_main.cpp:	SimulateAngles( gpGlobals->frametime );
game/server/physics_main.cpp:	VectorMA( GetLocalOrigin(), gpGlobals->frametime, GetLocalVelocity(), origin );
game/server/physics_main.cpp:		step->m_Previous.nTickCount = gpGlobals->tickcount;
game/server/physics_main.cpp:	SetSimulationTime( gpGlobals->curtime );
game/server/physics_main.cpp:	float deltaThink = thinktime - gpGlobals->curtime;
game/server/physics_main.cpp:		PhysicsStepRunTimestep( gpGlobals->frametime );
game/server/physics_main.cpp:		SetLastThink( -1, gpGlobals->curtime );
game/server/physics_main.cpp:		UpdatePhysicsShadowToCurrentPosition(gpGlobals->frametime);
game/server/physics_main.cpp:		PhysicsRelinkChildren(gpGlobals->frametime);
game/server/physics_main.cpp:		if ( pUpdate->stopUpdateTime > gpGlobals->curtime )
game/server/physics_main.cpp:	if ( thinktick > gpGlobals->tickcount )
game/server/physics_main.cpp:	if ( thinktime < gpGlobals->curtime )
game/server/physics_main.cpp:		thinktime = gpGlobals->curtime;	
game/server/physics_main.cpp:				( simulatingPlayer->GetTimeBase() > gpGlobals->curtime - PLAYER_PACKETS_STOPPED_SO_RETURN_TO_PHYSICS_TIME ) )
game/server/physics_main.cpp:	float starttime = gpGlobals->curtime;
game/server/physics_main.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/physics_main.cpp:				gpGlobals->curtime = starttime;
game/server/physics_main.cpp:				// Force usercmd processing even though gpGlobals->tickcount isn't incrementing
game/server/physics_main.cpp:			gpGlobals->curtime = starttime;
game/server/physics_main.cpp:	gpGlobals->curtime = starttime;
game/server/ai_goalentity.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/ai_goalentity.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/bmodels.cpp:		SetNextThink( gpGlobals->curtime + .2 );	// leave a magic delay for client to start up
game/server/ai_speech.h:	void Acquire( float time, CBaseEntity *pTalker )		{ m_ReleaseTime = gpGlobals->curtime + time; m_hCurrentTalker = pTalker; }
game/server/ai_speech.h:	bool IsAvailable( CBaseEntity *pTalker ) const		{ return ((gpGlobals->curtime > m_ReleaseTime) || (m_hCurrentTalker == pTalker)); }
game/server/func_movelinear.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/ai_looktarget.cpp:	m_flTimeNextAvailable = gpGlobals->curtime + flDuration;
game/server/baseentity.cpp:	int tickbase = gpGlobals->GetNetworkBase( gpGlobals->tickcount, pEntity->entindex() );
game/server/baseentity.cpp:	int tickbase = gpGlobals->GetNetworkBase( gpGlobals->tickcount, pEntity->entindex() );
game/server/baseentity.cpp:	m_nLastThinkTick = gpGlobals->tickcount;
game/server/baseentity.cpp:	pNewTO->msgEndTime = gpGlobals->curtime + endTime;
game/server/baseentity.cpp:	pNewTO->msgStartTime = gpGlobals->curtime;
game/server/baseentity.cpp:		if ((!CBaseEntity::Debug_IsPaused() && gpGlobals->curtime > pTO->msgEndTime) ||
game/server/baseentity.cpp:				nAlpha = 255*((gpGlobals->curtime - pTO->msgStartTime)/(pTO->msgEndTime - pTO->msgStartTime));
game/server/baseentity.cpp:		if( ((int)gpGlobals->curtime) % 2 == 1 )
game/server/baseentity.cpp:		//Msg("%s took %.2f Damage, at %.2f\n", GetClassname(), info.GetDamage(), gpGlobals->curtime );
game/server/baseentity.cpp:		//NDebugOverlay::BoxAngles( origin, CollisionProp()->OBBMins(), CollisionProp()->OBBMaxs(), angles, 255,0,0,0, gpGlobals->frametime);
game/server/baseentity.cpp:	SetContextThink( NULL, gpGlobals->curtime, "ShadowCastDistThink" );
game/server/baseentity.cpp:		SetContextThink( &CBaseEntity::ShadowCastDistThink, gpGlobals->curtime + flDelay, "ShadowCastDistThink" );
game/server/baseentity.cpp:		V_snprintf( szMsg, sizeof(szMsg), "\nInvalid save, unable to load. Please run \"map %s\" to restart this level manually\n\n", gpGlobals->mapname.ToCStr() );
game/server/baseentity.cpp:	CBaseEntity::sm_bDisableTouchFuncs = ( gpGlobals->eLoadType != MapLoad_Transition );
game/server/baseentity.cpp:		Q_snprintf( bigstring,sizeof(bigstring), "%3.1f  (%s,%d) <-- (%s)\n", gpGlobals->curtime, szInputName, Value.Int(), pCaller ? pCaller->GetDebugName() : NULL);
game/server/baseentity.cpp:		Q_snprintf( bigstring,sizeof(bigstring), "%3.1f  (%s,%s) <-- (%s)\n", gpGlobals->curtime, szInputName, Value.String(), pCaller ? pCaller->GetDebugName() : NULL);
game/server/baseentity.cpp:		Q_snprintf( bigstring,sizeof(bigstring), "%3.1f  (%s) <-- (%s)\n", gpGlobals->curtime, szInputName, pCaller ? pCaller->GetDebugName() : NULL);
game/server/baseentity.cpp:		Q_snprintf( bigstring,sizeof(bigstring), "%3.1f  (%s) --> (%s),%.1f) \n", gpGlobals->curtime, STRING(ev->m_iTargetInput), STRING(ev->m_iTarget), ev->m_flDelay);
game/server/baseentity.cpp:		Q_snprintf( bigstring,sizeof(bigstring), "%3.1f  (%s) --> (%s)\n", gpGlobals->curtime,  STRING(ev->m_iTargetInput), STRING(ev->m_iTarget));
game/server/baseentity.cpp:						Q_snprintf( szBuffer, sizeof(szBuffer), "(%0.2f) input %s: %s.%s(%s)\n", gpGlobals->curtime, STRING(pCaller->m_iName), GetDebugName(), szInputName, Value.String() );
game/server/baseentity.cpp:						Q_snprintf( szBuffer, sizeof(szBuffer), "(%0.2f) input <NULL>: %s.%s(%s)\n", gpGlobals->curtime, GetDebugName(), szInputName, Value.String() );
game/server/baseentity.cpp:			Msg( "[%03d] Found: %s, firing\n", gpGlobals->tickcount%1000, pEntity->GetDebugName());
game/server/baseentity.cpp:			else if ( gpGlobals->maxClients > 1 )
game/server/baseentity.cpp:		SetSimulationTime( gpGlobals->curtime );
game/server/baseentity.cpp:		SetSimulationTime( gpGlobals->curtime );
game/server/baseentity.cpp:		SetSimulationTime( gpGlobals->curtime );
game/server/baseentity.cpp:		SetSimulationTime( gpGlobals->curtime );
game/server/baseentity.cpp:	set.AppendCriteria( "map", gpGlobals->mapname.ToCStr() );
game/server/baseentity.cpp:	return ( m_ResponseContexts[ index ].m_fExpirationTime <= gpGlobals->curtime );
game/server/baseentity.cpp:			duration += gpGlobals->curtime;
game/server/baseentity.cpp:	if ( step->m_nLastProcessTickCount == gpGlobals->tickcount )
game/server/baseentity.cpp:	step->m_nLastProcessTickCount = gpGlobals->tickcount;
game/server/baseentity.cpp:				frac = (float)( gpGlobals->tickcount - step->m_Previous.nTickCount ) / (float) tickdelta;
game/server/baseentity.cpp:					if (gpGlobals->tickcount > step->m_Discontinuity.nTickCount)
game/server/baseentity.cpp:						frac = (float)( gpGlobals->tickcount - pOlder->nTickCount ) / (float) tickdelta;
game/server/baseentity.cpp:				frac = (float)( gpGlobals->tickcount - step->m_Previous.nTickCount ) / (float) tickdelta;
game/server/baseentity.cpp:					if (gpGlobals->tickcount > step->m_Discontinuity.nTickCount)
game/server/baseentity.cpp:						frac = (float)( gpGlobals->tickcount - pOlder->nTickCount ) / (float) tickdelta;
game/server/baseentity.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/baseentity.cpp:	SetNextThink( gpGlobals->curtime + delay );
game/server/baseentity.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/baseentity.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/baseentity.cpp:	float dt = gpGlobals->frametime;
game/server/baseentity.cpp:		SetNextThink( gpGlobals->curtime + 1 );
game/server/baseentity.cpp:		SetNextThink( gpGlobals->curtime );
game/server/baseentity.cpp:		else if ( gpGlobals->maxClients > 1 )
game/server/vehicle_base.cpp:	SetNextThink( gpGlobals->curtime );
game/server/vehicle_base.cpp:	if (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime)
game/server/vehicle_base.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/vehicle_base.cpp:	m_VehiclePhysics.SetSteering( inputdata.value.Float(), 2*gpGlobals->frametime );
game/server/vehicle_base.cpp:		SetNextThink(gpGlobals->curtime);
game/server/vehicle_base.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/vehicle_base.cpp:	m_flNoImpactDamageTime = gpGlobals->curtime + 5.0f;
game/server/vehicle_base.cpp:		SetNextThink( gpGlobals->curtime );
game/server/vehicle_base.cpp:		SetNextThink( gpGlobals->curtime );
game/server/vehicle_base.cpp:		SetNextThink( gpGlobals->curtime );
game/server/vehicle_base.cpp:		if ( m_hKeepUpright != NULL && m_flTurnOffKeepUpright < gpGlobals->curtime )
game/server/vehicle_base.cpp:	if ( flDamage > 0 && m_flNoImpactDamageTime < gpGlobals->curtime )
game/server/vehicle_base.cpp:			m_flTurnOffKeepUpright = gpGlobals->curtime + GetUprightTime();
game/server/vehicle_base.cpp:			SetNextThink( gpGlobals->curtime );
game/server/vehicle_base.cpp:		GetFourWheelVehicle()->SetNextThink( gpGlobals->curtime );
game/server/vehicle_base.cpp:	GetFourWheelVehicle()->DriveVehicle( gpGlobals->frametime, &fakeCmd, afButtonPressed, afButtonReleased );
game/server/soundscape.cpp:				float periodic = 2.0f * sin((fmod(gpGlobals->curtime,2.0f) - 1.0f) * M_PI); // = -4f .. 4f
game/server/soundscape.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/soundscape.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/soundscape.cpp:	for ( i=1; i <= gpGlobals->maxClients; ++i )
game/server/EntityDissolve.cpp:			SetContextThink( &CEntityDissolve::ElectrocuteThink, gpGlobals->curtime + 0.01f, s_pElectroThinkContext );
game/server/EntityDissolve.cpp:	if ( gpGlobals->curtime > m_flStartTime )
game/server/EntityDissolve.cpp:		SetNextThink( gpGlobals->curtime + 0.01f );
game/server/EntityDissolve.cpp:			pBaseAnim->Dissolve( NULL, gpGlobals->curtime, false, m_nDissolveType, GetAbsOrigin(), m_nMagnitude );
game/server/EntityDissolve.cpp:	float dt = gpGlobals->curtime - m_flStartTime;
game/server/EntityDissolve.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/EntityDissolve.cpp:	SetContextThink( &CEntityDissolve::ElectrocuteThink, gpGlobals->curtime + random->RandomFloat( 0.1, 0.2f ), 
game/server/ai_baseactor.h:	virtual void			ExpireCurrentRandomLookTarget() { m_flNextRandomLookTime = gpGlobals->curtime - 0.1f; }
game/server/sceneentity.cpp:		SetNextThink( gpGlobals->curtime );
game/server/sceneentity.cpp:	ADD_DEBUG_HISTORY( HISTORY_SCENE_PRINT, UTIL_VarArgs( "(%0.2f) %s", gpGlobals->curtime, msg ) );
game/server/sceneentity.cpp:	if ( gpGlobals->maxClients == 1 || bForceClientSync )
game/server/sceneentity.cpp:	m_flAutomationTime += (gpGlobals->frametime);
game/server/sceneentity.cpp:		float soundtime = gpGlobals->curtime - time_in_past;
game/server/sceneentity.cpp:		es.m_flSoundTime = ( gpGlobals->maxClients == 1 ) ? soundtime : 0.0f;
game/server/sceneentity.cpp:			speechListSounds[ speechListIndex ].time = gpGlobals->curtime;
game/server/sceneentity.cpp:	actor->SetPermitResponse( gpGlobals->curtime + event->GetDuration() );
game/server/sceneentity.cpp:	// Msg("%.2f %s\n", gpGlobals->curtime, STRING( m_iszSceneFile ) );
game/server/sceneentity.cpp:	//Msg( "SV:  %d, %f for %s\n", gpGlobals->tickcount, m_flCurrentTime, m_pScene->GetFilename() );
game/server/sceneentity.cpp:				if ( gpGlobals->maxClients == 1 )
game/server/sceneentity.cpp:		entity = ( gpGlobals->maxClients == 1 ) ? ( CBaseEntity * )UTIL_GetLocalPlayer() : NULL;
game/server/sceneentity.cpp:		entity = ( gpGlobals->maxClients == 1 ) ? ( CBaseEntity * )UTIL_GetLocalPlayer() : NULL;
game/server/sceneentity.cpp:	SetNextThink( gpGlobals->curtime + SCENE_THINK_INTERVAL );
game/server/sceneentity.cpp:	float frameTime = ( gpGlobals->curtime - GetLastThink() );
game/server/sceneentity.cpp:		es.m_flSoundTime = gpGlobals->curtime - sound->time_in_past;
game/server/sceneentity.cpp:	if ( gpGlobals->eLoadType != MapLoad_LoadGame )
game/server/sceneentity.cpp:	Msg( "Current time: %6.3f\n", gpGlobals->curtime );
game/server/world.cpp:		(gpGlobals->deathmatch && HasSpawnFlags( SF_DECAL_NOTINDEATHMATCH )) )
game/server/world.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/world.cpp:		(gpGlobals->deathmatch && HasSpawnFlags( SF_DECAL_NOTINDEATHMATCH )) )
game/server/world.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/world.cpp:	GlobalEntity_Add( "is_console", STRING(gpGlobals->mapname), ( IsConsole() ) ? GLOBAL_ON : GLOBAL_OFF );
game/server/world.cpp:	GlobalEntity_Add( "is_pc", STRING(gpGlobals->mapname), ( !IsConsole() ) ? GLOBAL_ON : GLOBAL_OFF );
game/server/world.cpp:			pMessage->SetNextThink( gpGlobals->curtime + 1.0f );
game/server/ai_scriptconditions.h:	void SetThinkTime()			{ SetNextThink( gpGlobals->curtime + 0.250 ); }
game/server/props.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/props.cpp:	m_createTick = gpGlobals->tickcount;
game/server/props.cpp:		if ( flNextThink < gpGlobals->curtime + TICK_INTERVAL )
game/server/props.cpp:			flNextThink = gpGlobals->curtime + TICK_INTERVAL;
game/server/props.cpp:			SetNextThink( gpGlobals->curtime + m_flPressureDelay );
game/server/props.cpp:	if ( m_createTick == (unsigned int)gpGlobals->tickcount )
game/server/props.cpp:			SetContextThink( &CBreakableProp::AnimateThink, gpGlobals->curtime + 0.1, s_pPropAnimateThink );
game/server/props.cpp:		StudioFrameAdvanceManual( gpGlobals->frametime );
game/server/props.cpp:				SetContextThink( &CBreakableProp::AnimateThink, gpGlobals->curtime + 0.1, s_pPropAnimateThink );
game/server/props.cpp:		StudioFrameAdvanceManual( (reason == PICKED_UP_BY_CANNON) ? gpGlobals->frametime : 0.5f );
game/server/props.cpp:		SetNextThink( gpGlobals->curtime + 0.1, s_pPropAnimateThink );
game/server/props.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pFadeScaleThink );
game/server/props.cpp:		SetContextThink( NULL, gpGlobals->curtime, s_pFadeScaleThink );
game/server/props.cpp:		SetContextThink( &CBreakableProp::RampToDefaultFadeScale, gpGlobals->curtime + TICK_INTERVAL, s_pFadeScaleThink );
game/server/props.cpp:		SetContextThink( &CBreakableProp::RampToDefaultFadeScale, gpGlobals->curtime + 2.0f, s_pFadeScaleThink );
game/server/props.cpp:	SetPhysicsAttacker( pPhysGunUser, gpGlobals->curtime );
game/server/props.cpp:		SetNextThink( gpGlobals->curtime + flLifetime + 5.0f );
game/server/props.cpp:	SetContextThink( &CBreakableProp::RampToDefaultFadeScale, gpGlobals->curtime + 2.0f, s_pFadeScaleThink );
game/server/props.cpp:	SetPhysicsAttacker( pPhysGunUser, gpGlobals->curtime );
game/server/props.cpp:	if (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime)
game/server/props.cpp:		if( gpGlobals->curtime - m_flLastPhysicsInfluenceTime <= 2.0f )
game/server/props.cpp:	if ( gpGlobals->maxClients > 1 && breakable_multiplayer.GetBool() )
game/server/props.cpp:			m_flNextRandAnim = gpGlobals->curtime + random->RandomFloat( m_flMinRandAnimTime, m_flMaxRandAnimTime );
game/server/props.cpp:			SetNextThink( gpGlobals->curtime + m_flNextRandAnim + 0.1 );
game/server/props.cpp:	if ( m_bRandomAnimator && m_flNextRandAnim < gpGlobals->curtime )
game/server/props.cpp:		m_flNextRandAnim = gpGlobals->curtime + random->RandomFloat( m_flMinRandAnimTime, m_flMaxRandAnimTime );
game/server/props.cpp:				SetNextThink( gpGlobals->curtime + m_flNextRandAnim + 0.1 );
game/server/props.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/props.cpp:	// Msg("%.2f CDynamicProp::FinishSetSequence( %d )\n", gpGlobals->curtime, nSequence );
game/server/props.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/props.cpp:	// Msg("%.2f CDynamicProp::PropSetSequence( %d (%d:%.1f:%.3f)\n", gpGlobals->curtime, nSequence, GetSequence(), GetPlaybackRate(), GetCycle() );
game/server/props.cpp:	if ( GetNextThink() <= gpGlobals->curtime )
game/server/props.cpp:		SetNextThink( gpGlobals->curtime + flInterval );
game/server/props.cpp:		SetContextThink( &CPhysicsProp::ClearFlagsThink, gpGlobals->curtime, "PROP_CLEARFLAGS" );
game/server/props.cpp:	SetNextThink( gpGlobals->curtime + m_flRespawnTime );
game/server/props.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/CommentarySystem.cpp:	if ( gpGlobals->maxClients <= 1 )
game/server/CommentarySystem.cpp:		Q_snprintf(szFullName,sizeof(szFullName), "maps/%s_commentary.txt", STRING( gpGlobals->mapname) );
game/server/CommentarySystem.cpp:		if ( gpGlobals->eLoadType == MapLoad_LoadGame || gpGlobals->eLoadType == MapLoad_Background )
game/server/CommentarySystem.cpp:			if ( m_flNextTeleportTime <= gpGlobals->curtime )
game/server/CommentarySystem.cpp:					m_flNextTeleportTime = gpGlobals->curtime + 0.35;
game/server/CommentarySystem.cpp:					m_flNextTeleportTime = gpGlobals->curtime + 0.6;
game/server/CommentarySystem.cpp:					m_flNextTeleportTime = gpGlobals->curtime + 0.25;
game/server/CommentarySystem.cpp:		Q_snprintf(szFullName,sizeof(szFullName), "maps/%s_commentary.txt", STRING( gpGlobals->mapname ));
game/server/CommentarySystem.cpp:		if ( m_flNextTeleportTime > gpGlobals->curtime || m_iTeleportStage != TELEPORT_NONE )
game/server/CommentarySystem.cpp:				m_flNextTeleportTime = gpGlobals->curtime;
game/server/CommentarySystem.cpp:	SetNextThink( gpGlobals->curtime + 0.1f ); 
game/server/CommentarySystem.cpp:			m_flAnimTime = gpGlobals->curtime;
game/server/CommentarySystem.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/CommentarySystem.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/CommentarySystem.cpp:	m_flPrevAnimTime = gpGlobals->curtime;
game/server/CommentarySystem.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/CommentarySystem.cpp: 		SetContextThink( &CPointCommentaryNode::UpdateViewThink, gpGlobals->curtime, s_pCommentaryUpdateViewThink );
game/server/CommentarySystem.cpp:	//SetContextThink( &CPointCommentaryNode::FinishCommentary, gpGlobals->curtime + flDuration, s_pFinishCommentaryThink );
game/server/CommentarySystem.cpp:		float mod = 1.0 - ExponentialDecay( 0.5, 0.3, gpGlobals->frametime );
game/server/CommentarySystem.cpp:		SetNextThink( gpGlobals->curtime, s_pCommentaryUpdateViewThink );
game/server/CommentarySystem.cpp: 		float flCurTime = (gpGlobals->curtime - m_flStartTime);
game/server/CommentarySystem.cpp:		SetNextThink( gpGlobals->curtime, s_pCommentaryUpdateViewThink );
game/server/CommentarySystem.cpp:   		float flCurTime = (gpGlobals->curtime - m_flFinishedTime);
game/server/CommentarySystem.cpp:			SetNextThink( gpGlobals->curtime, s_pCommentaryUpdateViewThink );
game/server/CommentarySystem.cpp:	m_flFinishedTime = gpGlobals->curtime;
game/server/CommentarySystem.cpp:		SetContextThink( &CPointCommentaryNode::UpdateViewPostThink, gpGlobals->curtime, s_pCommentaryUpdateViewThink );
game/server/CommentarySystem.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/ai_memory.cpp:		 gpGlobals->curtime > pMemory->timeLastSeen + m_flEnemyDiscardTime )
game/server/ai_memory.cpp:			if ( gpGlobals->curtime <= pMemory->timeLastSeen + m_flFreeKnowledgeDuration )
game/server/ai_memory.cpp:			if ( gpGlobals->curtime <= pMemory->timeLastSeen )
game/server/ai_memory.cpp:			pMemory->timeLastSeen = gpGlobals->curtime;
game/server/ai_memory.cpp:		if (deltaDist>DIST_TRIGGER_REACQUIRE_SQ || ( deltaDist>MIN_DIST_TIME_TRIGGER_REACQUIRE_SQ && ( gpGlobals->curtime - pMemory->timeLastSeen ) > TIME_TRIGGER_REACQUIRE ) )
game/server/ai_memory.cpp:			pMemory->timeLastReacquired = gpGlobals->curtime;
game/server/ai_memory.cpp:			pMemory->timeAtFirstHand = gpGlobals->curtime;
game/server/ai_memory.cpp:		pAddMemory->timeLastReacquired = pAddMemory->timeFirstSeen = pAddMemory->timeLastSeen = pAddMemory->timeAtFirstHand = gpGlobals->curtime;
game/server/ai_memory.cpp:		pAddMemory->timeLastReacquired = pAddMemory->timeFirstSeen = pAddMemory->timeLastSeen = ( gpGlobals->curtime - (m_flFreeKnowledgeDuration + 0.01) );
game/server/ai_memory.cpp:		pAddMemory->timeValidEnemy = gpGlobals->curtime + reactionDelay;
game/server/ai_memory.cpp:		pMemory->timeLastReceivedDamageFrom = gpGlobals->curtime;
game/server/ai_memory.cpp:		return ( gpGlobals->curtime < flFreeKnowledgeTime );
game/server/grenadethrown.cpp:	SetNextThink( gpGlobals->curtime + flExplodeTime );
game/server/hltvdirector.cpp:	gameevent.m_Tick = gpGlobals->tickcount;
game/server/hltvdirector.cpp:	int newBroadcastTick = gpGlobals->tickcount;
game/server/hltvdirector.cpp:	if ( (m_nNextAnalyzeTick < gpGlobals->tickcount) && 
game/server/hltvdirector.cpp:		m_nNextAnalyzeTick = gpGlobals->tickcount + TIME_TO_TICKS( 0.5f );
game/server/hltvdirector.cpp:	if ( m_nNextShotTick > gpGlobals->tickcount )
game/server/hltvdirector.cpp:	m_nNextShotTick = gpGlobals->tickcount + TIME_TO_TICKS( DEF_SHOT_LENGTH );
game/server/hltvdirector.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/hltvdirector.cpp:	int smallestTick = MAX(0, gpGlobals->tickcount - TIME_TO_TICKS(HLTV_MAX_DELAY) );
game/server/hltvdirector.cpp:	for ( int i =1; i <= gpGlobals->maxClients; i++ )
game/server/ai_behavior_passenger.cpp:	m_vehicleState.m_flNextWarningTime = gpGlobals->curtime;
game/server/ai_eventresponse.cpp:	m_flNextEventPoll = gpGlobals->curtime;
game/server/ai_eventresponse.cpp:		newEvent.flEventTime = gpGlobals->curtime;
game/server/ai_eventresponse.cpp:			Msg( "NPCEVENTRESPONSE: (%.2f) Trigger fired for event named: %s\n", gpGlobals->curtime, pResponse );
game/server/ai_eventresponse.cpp:		m_ActiveEvents[iIndex].flEventTime = gpGlobals->curtime;
game/server/ai_eventresponse.cpp:			Msg( "NPCEVENTRESPONSE: (%.2f) Trigger resetting already-active event firing named: %s\n", gpGlobals->curtime, pResponse );
game/server/ai_eventresponse.cpp:	if ( m_flNextEventPoll > gpGlobals->curtime )
game/server/ai_eventresponse.cpp:	m_flNextEventPoll = gpGlobals->curtime + 0.2;
game/server/ai_eventresponse.cpp:		if ( !m_ActiveEvents[i].bPreventExpiration && (flTime + NPCEVENTRESPONSE_GIVEUP_TIME) < gpGlobals->curtime )
game/server/ai_eventresponse.cpp:				Msg( "NPCEVENTRESPONSE: (%.2f) Removing expired event named: %s\n", gpGlobals->curtime, pResponse );
game/server/ai_eventresponse.cpp:		else if ( m_ActiveEvents[i].flNextResponseTime < gpGlobals->curtime )
game/server/ai_eventresponse.cpp:			if ( m_ActiveEvents[i].bPreventExpiration && (flTime + NPCEVENTRESPONSE_GIVEUP_TIME) < gpGlobals->curtime )
game/server/ai_eventresponse.cpp:					Msg( "NPCEVENTRESPONSE: (%.2f) Removing expired fired event named: %s\n", gpGlobals->curtime, pResponse );
game/server/ai_eventresponse.cpp:						m_ActiveEvents[i].flNextResponseTime = gpGlobals->curtime + NPCEVENTRESPONSE_REFIRE_TIME;
game/server/ai_eventresponse.cpp:							Msg( "NPCEVENTRESPONSE: (%.2f) Event '%s' responded to by NPC '%s'. Refire available at: %.2f\n", gpGlobals->curtime, pResponse, pNearestNPC->GetDebugName(), m_ActiveEvents[i].flNextResponseTime );
game/server/AI_Interest_Target.cpp:	if (m_flEndTime < gpGlobals->curtime) return false;
game/server/AI_Interest_Target.cpp:	float t = (gpGlobals->curtime - m_flStartTime) / (m_flEndTime - m_flStartTime);
game/server/AI_Interest_Target.cpp:			if (target.m_flStartTime == gpGlobals->curtime)
game/server/AI_Interest_Target.cpp:			if (target.m_flStartTime == gpGlobals->curtime)
game/server/AI_Interest_Target.cpp:	target.m_flStartTime = gpGlobals->curtime;
game/server/AI_Interest_Target.cpp:	target.m_flEndTime = gpGlobals->curtime + flDuration;
game/server/ai_behavior_follow.cpp:	if ( m_flTimeUpdatedFollowPosition == gpGlobals->curtime )
game/server/ai_behavior_follow.cpp:	m_flTimeUpdatedFollowPosition = gpGlobals->curtime;
game/server/ai_behavior_follow.cpp:		m_flTimeFailFollowStarted = gpGlobals->curtime;
game/server/ai_behavior_follow.cpp:	if ( m_flTimeUpdatedFollowPosition == 0 || gpGlobals->curtime - m_flTimeUpdatedFollowPosition > 2.0 )
game/server/ai_behavior_follow.cpp:		m_flTimeFollowTargetVisible = gpGlobals->curtime;
game/server/ai_behavior_follow.cpp:	if ( HasFollowPoint() && ( m_flTimeFollowTargetVisible != 0 && gpGlobals->curtime - m_flTimeFollowTargetVisible > 5.0 ) )
game/server/ai_behavior_follow.cpp:				if( gpGlobals->curtime - GetOuter()->GetEnemyLastTimeSeen() < 5.0 )
game/server/ai_behavior_follow.cpp:					GetOuter()->m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/particle_smokegrenade.cpp:	m_flSpawnTime = gpGlobals->curtime;
game/server/particle_smokegrenade.cpp:	float flCurrentTime = gpGlobals->curtime - m_flSpawnTime;
game/server/func_breakablesurf.cpp:					SetNextThink( gpGlobals->curtime );
game/server/func_breakablesurf.cpp:	SetNextThink( gpGlobals->curtime );
game/server/ai_playerally.cpp:				m_flTimePlayerStartStare = gpGlobals->curtime;
game/server/ai_playerally.cpp:	if ( GetLastEnemyTime() == 0 || gpGlobals->curtime - GetLastEnemyTime() > 30 )
game/server/ai_playerally.cpp:		m_flNextIdleSpeechTime = gpGlobals->curtime + RandomFloat(5,10);
game/server/ai_playerally.cpp:		m_flTimeLastRegen = gpGlobals->curtime;
game/server/ai_playerally.cpp:		float flDelta = gpGlobals->curtime - m_flTimeLastRegen;
game/server/ai_playerally.cpp:		m_flTimeLastRegen = gpGlobals->curtime;
game/server/ai_playerally.cpp:		if ( m_flNextIdleSpeechTime && m_flNextIdleSpeechTime < gpGlobals->curtime )
game/server/ai_playerally.cpp:				m_flNextIdleSpeechTime = gpGlobals->curtime + RandomFloat( 20,30 );
game/server/ai_playerally.cpp:				m_flNextIdleSpeechTime = gpGlobals->curtime + RandomFloat( 10,20 );
game/server/ai_playerally.cpp:	m_TimePendingSet = gpGlobals->curtime;
game/server/ai_playerally.cpp:		float duration = GetExpresser()->GetSemaphoreAvailableTime(this) - gpGlobals->curtime;
game/server/ai_playerally.cpp:		float duration = GetExpresser()->GetSemaphoreAvailableTime(this) - gpGlobals->curtime;
game/server/ai_playerally.cpp:		if ( m_TimePendingSet == gpGlobals->curtime || IsAllowedToSpeak( m_PendingConcept.c_str() ) )
game/server/ai_playerally.cpp:			  gpGlobals->curtime - pKilled->MyNPCPointer()->GetLastPlayerDamageTime() > 5 ) )
game/server/ai_playerally.cpp:		for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_playerally.cpp:		GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + response->GetWeaponDelay() );
game/server/fire.cpp:			if ( m_lastDamage > gpGlobals->curtime && m_flHeatAbsorb > 0 )
game/server/fire.cpp:	if ( m_flDamageTime <= gpGlobals->curtime )
game/server/fire.cpp:		m_flDamageTime = gpGlobals->curtime + fire_dmginterval.GetFloat();
game/server/fire.cpp:	SetNextThink( gpGlobals->curtime + FIRE_THINK_INTERVAL );
game/server/fire.cpp:	SetNextThink( gpGlobals->curtime + seconds );
game/server/fire.cpp:		m_lastDamage = gpGlobals->curtime + 0.5;
game/server/fire.cpp:	m_lastDamage = gpGlobals->curtime + 0.5;
game/server/fire.cpp:	m_flAttackTime = Approach( averageAttackTime, m_flAttackTime, 2 * gpGlobals->frametime );
game/server/fire.cpp:	SetNextThink( gpGlobals->curtime + FIRESOURCE_THINK_TIME );
game/server/fire.cpp:	SetNextThink( gpGlobals->curtime );
game/server/fire.cpp:	SetNextThink( gpGlobals->curtime + time );
game/server/fire.cpp:	SetNextThink( gpGlobals->curtime );
game/server/serverbenchmark_base.cpp:				m_nBenchmarkStartTick = gpGlobals->tickcount;
game/server/serverbenchmark_base.cpp:		int nTicksRunSoFar = gpGlobals->tickcount - m_nBenchmarkStartTick;
game/server/serverbenchmark_base.cpp:				for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/serverbenchmark_base.cpp:			Msg( "Benchmark: %d%% complete.\n", ((gpGlobals->tickcount - m_nBenchmarkStartTick) * 100) / sv_benchmark_numticks.GetInt() );
game/server/serverbenchmark_base.cpp:			Assert( gpGlobals->tickcount >= m_nBenchmarkStartTick );
game/server/serverbenchmark_base.cpp:			return gpGlobals->tickcount - m_nBenchmarkStartTick;
game/server/serverbenchmark_base.cpp:			return gpGlobals->tickcount;
game/server/serverbenchmark_base.cpp:		int nTicksRunSoFar = gpGlobals->tickcount - m_nBenchmarkStartTick;
game/server/serverbenchmark_base.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/basegrenade_timed.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/basegrenade_timed.cpp:	if ((m_flDetonateTime - gpGlobals->curtime) < 0.1)
game/server/basegrenade_timed.cpp:		SetNextThink( gpGlobals->curtime );
game/server/ai_behavior_lead.h:	void SetWaitForWeapon( string_t iszWeaponName ) { m_weaponname = iszWeaponName; m_flWeaponSafetyTimeOut = gpGlobals->curtime + 60; }
game/server/point_devshot_camera.cpp:	if ( gpGlobals->maxClients > 1 )
game/server/point_devshot_camera.cpp:	SetNextThink( gpGlobals->curtime + DEVSHOT_INITIAL_WAIT + (g_iDevShotCameraCount * DEVSHOT_INTERVAL) );
game/server/point_devshot_camera.cpp:	SetNextThink( gpGlobals->curtime );
game/server/point_devshot_camera.cpp:	SetNextThink( gpGlobals->curtime + (DEVSHOT_INTERVAL - 1) );
game/server/point_devshot_camera.cpp:		if ( gpGlobals->curtime < 5 )
game/server/point_devshot_camera.cpp:			Q_snprintf(szFullName,sizeof(szFullName), "maps/%s.txt", STRING( gpGlobals->mapname ));
game/server/point_devshot_camera.cpp:				Warning( "Devshots: No point_devshot_camera in %s. Moving to next map.\n", STRING( gpGlobals->mapname ) );
game/server/gib.cpp:		SetNextThink( gpGlobals->curtime + m_lifeTime );
game/server/gib.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/gib.cpp:		SetNextThink( gpGlobals->curtime );
game/server/gib.cpp:	SetPhysicsAttacker( pPhysGunUser, gpGlobals->curtime );
game/server/gib.cpp:	SetPhysicsAttacker( pPhysGunUser, gpGlobals->curtime );
game/server/gib.cpp:	if (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime)
game/server/gib.cpp:	SetNextThink( gpGlobals->curtime + 10 );
game/server/gib.cpp:		SetNextThink( gpGlobals->curtime );
game/server/gib.cpp:	SetNextThink( gpGlobals->curtime + 4 );
game/server/gib.cpp:	SetNextThink( gpGlobals->curtime + m_lifeTime );
game/server/nav_file.cpp:	Q_snprintf( bspFilename, sizeof( bspFilename ), FORMAT_BSPFILE, STRING( gpGlobals->mapname ) );
game/server/nav_file.cpp:	Q_snprintf( filename, sizeof( filename ), "%s\\" FORMAT_NAVFILE, gamePath, STRING( gpGlobals->mapname ) );
game/server/nav_file.cpp:	Q_snprintf( filename, sizeof( filename ), FORMAT_NAVFILE, STRING( gpGlobals->mapname ) );
game/server/nav_file.cpp:	Q_snprintf( filename, sizeof( filename ), FORMAT_NAVFILE, STRING( gpGlobals->mapname ) );
game/server/phys_controller.cpp:		SetNextThink( gpGlobals->curtime + m_forceTime );
game/server/phys_controller.cpp:	SetNextThink( gpGlobals->curtime );
game/server/phys_controller.cpp:	m_lastTime = gpGlobals->curtime;
game/server/phys_controller.cpp:		m_lastTime = gpGlobals->curtime - TICK_INTERVAL;
game/server/phys_controller.cpp:	m_motor.m_speed = UTIL_Approach( m_flSpeed, m_motor.m_speed, m_angularAcceleration*(gpGlobals->curtime-m_lastTime) );
game/server/phys_controller.cpp:	m_lastTime = gpGlobals->curtime;
game/server/phys_controller.cpp:		SetNextThink( gpGlobals->curtime );
game/server/phys_controller.cpp:			if ( pEntity && pEntity->GetServerVehicle() && Q_stristr( gpGlobals->mapname.ToCStr(), "d2_coast_01" ) )
game/server/ai_behavior_rappel.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/ai_behavior_rappel.cpp:	SetNextThink( gpGlobals->curtime + 3.0 );
game/server/ai_behavior_rappel.cpp:	SetNextThink( gpGlobals->curtime );
game/server/logicrelay.cpp:		SetNextThink( gpGlobals->curtime + 0.01 );
game/server/colorcorrectionvolume.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/colorcorrectionvolume.cpp:	m_LastEnterTime = gpGlobals->curtime;
game/server/colorcorrectionvolume.cpp:	m_LastExitTime = gpGlobals->curtime;
game/server/colorcorrectionvolume.cpp:				float dt = gpGlobals->curtime - m_LastEnterTime;
game/server/colorcorrectionvolume.cpp:				float dt = gpGlobals->curtime - m_LastExitTime;
game/server/colorcorrectionvolume.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/func_break.cpp:		SetNextThink( gpGlobals->curtime + m_flPressureDelay );
game/server/func_break.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/func_break.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/func_break.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/func_break.cpp:	if (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime)
game/server/explode.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/explode.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/explode.cpp:	SetNextThink( gpGlobals->curtime + 0.3 );
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_EVENTS, Color( 100, 100, 100, 255 ), "%3.2f: %s:%s: %s received EVENT %s\n", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName(), _action->GetFullName(), #METHOD );	\
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 0, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName() ); \
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_EVENTS, Color( 100, 100, 100, 255 ), "%3.2f: %s:%s: %s received EVENT %s\n", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName(), _action->GetFullName(), #METHOD );	\
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 0, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName() ); \
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_EVENTS, Color( 100, 100, 100, 255 ), "%3.2f: %s:%s: %s received EVENT %s\n", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName(), _action->GetFullName(), #METHOD );	\
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 0, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName() ); \
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_EVENTS, Color( 100, 100, 100, 255 ), "%3.2f: %s:%s: %s received EVENT %s\n", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName(), _action->GetFullName(), #METHOD );	\
game/server/NextBot/NextBotBehavior.h:					m_actor->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 0, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, m_actor->GetDebugIdentifier(), m_behavior->GetName() ); \
game/server/NextBot/NextBotBehavior.h:					DevMsg( "%3.2f: WARNING: %s::%s() RESULT_CRITICAL collision\n", gpGlobals->curtime, GetName(), eventName );
game/server/NextBot/NextBotBehavior.h:	ConColorMsg( Color( 255, 0, 255, 255 ), "%3.2f: NEW %0X\n", gpGlobals->curtime, this );
game/server/NextBot/NextBotBehavior.h:	ConColorMsg( Color( 255, 0, 255, 255 ), "%3.2f: DELETE %0X\n", gpGlobals->curtime, this );
game/server/NextBot/NextBotBehavior.h:		me->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 150, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, me->GetDebugIdentifier(), behavior->GetName() );
game/server/NextBot/NextBotBehavior.h:		me->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 150, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, me->GetDebugIdentifier(), behavior->GetName() );
game/server/NextBot/NextBotBehavior.h:		me->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 150, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, me->GetDebugIdentifier(), behavior->GetName() );
game/server/NextBot/NextBotBehavior.h:		me->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 150, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, me->GetDebugIdentifier(), behavior->GetName() );
game/server/NextBot/NextBotBehavior.h:				me->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 150, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, me->GetDebugIdentifier(), behavior->GetName() );
game/server/NextBot/NextBotBehavior.h:				me->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 150, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, me->GetDebugIdentifier(), behavior->GetName() );
game/server/NextBot/NextBotBehavior.h:				me->DebugConColorMsg( NEXTBOT_BEHAVIOR, Color( 255, 255, 150, 255 ), "%3.2f: %s:%s: ", gpGlobals->curtime, me->GetDebugIdentifier(), behavior->GetName() );
game/server/NextBot/NextBot.cpp:	SetNextThink( gpGlobals->curtime );
game/server/NextBot/NextBot.cpp:	SetNextThink( gpGlobals->curtime );
game/server/NextBot/NextBotKnownEntity.h:		m_whenBecameKnown = gpGlobals->curtime;
game/server/NextBot/NextBotKnownEntity.h:			m_whenLastKnown = gpGlobals->curtime;
game/server/NextBot/NextBotKnownEntity.h:		return gpGlobals->curtime - m_whenLastKnown;
game/server/NextBot/NextBotKnownEntity.h:		return gpGlobals->curtime - m_whenBecameKnown;
game/server/NextBot/NextBotKnownEntity.h:				m_whenLastBecameVisible = gpGlobals->curtime;
game/server/NextBot/NextBotKnownEntity.h:			m_whenLastSeen = gpGlobals->curtime;
game/server/NextBot/NextBotKnownEntity.h:		return gpGlobals->curtime - m_whenLastBecameVisible;
game/server/NextBot/NextBotKnownEntity.h:		return gpGlobals->curtime - m_whenLastSeen;
game/server/NextBot/NextBotComponentInterface.h:		float interval = gpGlobals->curtime - m_lastUpdateTime;
game/server/NextBot/NextBotComponentInterface.h:			m_lastUpdateTime = gpGlobals->curtime;
game/server/NextBot/NextBotComponentInterface.h:	m_lastUpdateTime = gpGlobals->curtime - m_curInterval;
game/server/NextBot/Player/NextBotPlayerBody.cpp:	const float deltaT = gpGlobals->frametime;
game/server/NextBot/Player/NextBotPlayerBody.cpp:								gpGlobals->curtime,
game/server/NextBot/Player/NextBotPlayerBody.cpp:								gpGlobals->curtime,
game/server/NextBot/Player/NextBotPlayerBody.cpp:							gpGlobals->curtime,
game/server/NextBot/Player/NextBotPlayerBody.cpp:						gpGlobals->curtime,
game/server/NextBot/Player/NextBotPlayerBody.cpp:								gpGlobals->curtime,
game/server/NextBot/Player/NextBotPlayerBody.cpp:							gpGlobals->curtime,
game/server/NextBot/Player/NextBotPlayerBody.cpp:						gpGlobals->curtime,
game/server/NextBot/Player/NextBotPlayer.h:	if ( UTIL_ClientsInGame() >= gpGlobals->maxClients )
game/server/NextBot/Player/NextBotPlayer.h:	Msg( "CreatePlayerBot: Failed - server is full (%d/%d clients).\n", UTIL_ClientsInGame(), gpGlobals->maxClients );
game/server/NextBot/Player/NextBotPlayer.h:	cmd->command_number = gpGlobals->tickcount;
game/server/NextBot/Player/NextBotPlayer.h:	if ( PlayerType::m_nSimulationTick == gpGlobals->tickcount )
game/server/NextBot/NextBotGroundLocomotion.cpp:		if ( GetBot()->IsDebugging( NEXTBOT_LOCOMOTION ) && !( gpGlobals->framecount % 60 ) )
game/server/NextBot/NextBotGroundLocomotion.cpp:			DevMsg( "%3.2f: Inside ground, ( %.0f, %.0f, %.0f )\n", gpGlobals->curtime, m_nextBot->GetPosition().x, m_nextBot->GetPosition().y, m_nextBot->GetPosition().z );
game/server/NextBot/NextBotGroundLocomotion.cpp:				DevMsg( "%3.2f: NextBotGroundLocomotion - Too steep to stand here\n", gpGlobals->curtime );
game/server/NextBot/NextBotGroundLocomotion.cpp:		DevMsg( "%3.2f: NextBotGroundLocomotion::OnLeaveGround\n", gpGlobals->curtime );
game/server/NextBot/NextBotGroundLocomotion.cpp:		DevMsg( "%3.2f: NextBotGroundLocomotion::GetBot()->OnLandOnGround\n", gpGlobals->curtime );
game/server/NextBot/NextBotLocomotionInterface.cpp:		DevMsg( "%3.2f: ClearStuckStatus: %s %s\n", gpGlobals->curtime, GetBot()->GetDebugIdentifier(), reason );
game/server/NextBot/NextBotLocomotionInterface.cpp:					DevMsg( "%3.2f: %s STILL STUCK\n", gpGlobals->curtime, GetBot()->GetDebugIdentifier() );
game/server/NextBot/NextBotLocomotionInterface.cpp:					DevMsg( "%3.2f: %s STUCK at position( %3.2f, %3.2f, %3.2f )\n", gpGlobals->curtime, GetBot()->GetDebugIdentifier(), m_stuckPos.x, m_stuckPos.y, m_stuckPos.z );
game/server/NextBot/NextBotManager.cpp:		if ( iCurFrame != gpGlobals->framecount )
game/server/NextBot/NextBotManager.cpp:			iCurFrame = gpGlobals->framecount;
game/server/NextBot/NextBotManager.cpp:			int curtickcount = gpGlobals->tickcount;
game/server/NextBot/NextBotManager.cpp:					if ( gpGlobals->tickcount - m_botList[i]->GetTickLastUpdate() >= m_iUpdateTickrate )
game/server/NextBot/NextBotManager.cpp:			Msg( "Frame %8d/tick %8d: %3d run of %3d, %3d sliders, %3d blocked slides, scheduled %3d for next tick, %3d intentional sliders, %d nonresponsive, %d dead\n", gpGlobals->framecount - 1, gpGlobals->tickcount - 1, g_nRun, m_botList.Count() - nDead, g_nSlid, g_nBlockedSlides, nScheduled, nIntentionalSliders, nNonResponsive, nDead );
game/server/NextBot/NextBotManager.cpp:				Msg( "Frame %8d/tick %8d: frame out of budget (%.2fms > %.2fms)\n", gpGlobals->framecount, gpGlobals->tickcount, sumFrameTime, frameLimit );
game/server/NextBot/NextBotManager.cpp:	int nTicksSlid = ( gpGlobals->tickcount - bot->GetTickLastUpdate() ) - m_iUpdateTickrate;
game/server/NextBot/NextBotManager.cpp:	bot->SetTickLastUpdate( gpGlobals->tickcount );
game/server/NextBot/NextBotManager.cpp:		DevMsg( "%3.2f: OnSpokeConcept( %s, %s )\n", gpGlobals->curtime, who->GetDebugName(), "concept.GetStringConcept()" );
game/server/NextBot/NextBotManager.cpp:		DevMsg( "%3.2f: OnWeaponFired( %s, %s )\n", gpGlobals->curtime, whoFired->GetDebugName(), weapon->GetName() );
game/server/NextBot/Path/NextBotChasePath.cpp:		if ( iServer != gpGlobals->serverCount )
game/server/NextBot/Path/NextBotChasePath.cpp:			iServer = gpGlobals->serverCount;
game/server/NextBot/Path/NextBotChasePath.h:			DevMsg( "%3.2f: bot(#%d) ChasePath::RefreshPath failed. Bot is on a ladder.\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotChasePath.h:			DevMsg( "%3.2f: bot(#%d) CasePath::RefreshPath failed. No subject.\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotChasePath.h:// 			DevMsg( "%3.2f: bot(#%d) ChasePath::RefreshPath failed. Fail timer not elapsed.\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotChasePath.h:			DevMsg( "%3.2f: bot(#%d) Chase path subject changed (from %p to %p).\n", gpGlobals->curtime, bot->GetEntity()->entindex(), m_lastPathSubject.Get(), subject );
game/server/NextBot/Path/NextBotChasePath.h:// 			DevMsg( "%3.2f: bot(#%d) ChasePath::RefreshPath failed. Rate throttled.\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotChasePath.h:				DevMsg( "%3.2f: bot(#%d) REPATH\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotChasePath.h:				DevMsg( "%3.2f: bot(#%d) REPATH FAILED\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotRetreatPath.h:			DevMsg( "%3.2f: bot(#%d) Chase path threat changed (from %X to %X).\n", gpGlobals->curtime, bot->GetEntity()->entindex(), m_pathThreat.Get(), threat );
game/server/NextBot/Path/NextBotRetreatPath.h:			DevMsg( "%3.2f: bot(#%d) CasePath::RefreshPath failed. No threat.\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotRetreatPath.h:			DevMsg( "%3.2f: bot(#%d) RetreatPath::RefreshPath failed. Bot is on a ladder.\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotRetreatPath.h:				DevMsg( "%3.2f: bot(#%d) RetreatPath::RefreshPath failed. Rate throttled.\n", gpGlobals->curtime, bot->GetEntity()->entindex() );
game/server/NextBot/Path/NextBotPathFollow.cpp:			DevMsg( "%3.2f: %s ON STAIRS\n", gpGlobals->curtime, bot->GetDebugIdentifier() );
game/server/NextBot/Path/NextBotPathFollow.cpp:				DevMsg( "%3.2f: %s at potential ledge climb\n", gpGlobals->curtime, bot->GetDebugIdentifier() );
game/server/NextBot/Path/NextBotPathFollow.cpp:							DevMsg( "%3.2f: Climbing - found wall.\n", gpGlobals->curtime );
game/server/NextBot/Path/NextBotPathFollow.cpp:							DevMsg( "%3.2f: Climbing - skipping overhead climb we can walk/crawl under.\n", gpGlobals->curtime );
game/server/NextBot/Path/NextBotPathFollow.cpp:					DevMsg( "%3.2f: STARTING LEDGE CLIMB UP\n", gpGlobals->curtime );
game/server/NextBot/Path/NextBotPathFollow.cpp:				DevMsg( "%3.2f: CANT FIND LEDGE TO CLIMB\n", gpGlobals->curtime );
game/server/NextBot/Path/NextBotPathFollow.cpp:					DevMsg( "%3.2f: GAP JUMP\n", gpGlobals->curtime );
game/server/NextBot/NextBotVisionInterface.cpp:				if ( gpGlobals->curtime - known.GetTimeWhenBecameVisible() >= GetMinRecognizeTime() &&
game/server/NextBot/NextBotVisionInterface.cpp:										gpGlobals->curtime,
game/server/NextBot/NextBotVisionInterface.cpp:										gpGlobals->curtime,
game/server/NextBot/NextBotVisionInterface.cpp:	m_lastVisionUpdateTimestamp = gpGlobals->curtime;
game/server/physconstraint.cpp:	if ( eventType != NOTIFY_EVENT_TELEPORT || (unsigned int)gpGlobals->tickcount == m_teleportTick )
game/server/physconstraint.cpp:	m_teleportTick = gpGlobals->tickcount;
game/server/physconstraint.cpp:				SetNextThink(gpGlobals->curtime + m_soundInfo.getThinkRate());
game/server/physconstraint.cpp:		SetNextThink( gpGlobals->curtime + m_soundInfo.getThinkRate() );
game/server/physconstraint.cpp:		SetNextThink(gpGlobals->curtime + m_soundInfo.getThinkRate());
game/server/physconstraint.cpp:				SetNextThink(gpGlobals->curtime + m_soundInfo.getThinkRate());
game/server/physconstraint.cpp:		SetNextThink(gpGlobals->curtime + m_soundInfo.getThinkRate());
game/server/physconstraint.cpp:	SetNextThink(gpGlobals->curtime + m_soundInfo.getThinkRate());
game/server/physconstraint.cpp:			projection = -(accel.Dot(m_prevSample) / prevSampleLength) / (gpGlobals->curtime - m_fPrevSampleTime);
game/server/physconstraint.cpp:			projection = accel.Length() / (gpGlobals->curtime - m_fPrevSampleTime);
game/server/physconstraint.cpp:			projection = -(accel.Dot(m_prevSample) / prevSampleLength) / (gpGlobals->curtime - m_fPrevSampleTime);
game/server/physconstraint.cpp:			projection = accel.Length() / (gpGlobals->curtime - m_fPrevSampleTime);
game/server/physconstraint.cpp:	SetNextThink(gpGlobals->curtime + m_vSampler.getSampleRate());
game/server/recipientfilter.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/recipientfilter.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/recipientfilter.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/recipientfilter.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/recipientfilter.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/recipientfilter.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/recipientfilter.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/energy_wave.cpp:// 	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/energy_wave.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/energy_wave.cpp:	m_flLaunchTime = gpGlobals->curtime;
game/server/energy_wave.cpp:	pEnergy->SetNextThink(gpGlobals->curtime + 0.1f);
game/server/energy_wave.cpp:	float flLifeLeft = 1 - (gpGlobals->curtime - m_flLaunchTime) / ENERGY_GRENADE_LIFETIME;
game/server/energy_wave.cpp:	SetNextThink(gpGlobals->curtime + 0.01f);
game/server/energy_wave.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/energy_wave.cpp:		float flLifeLeft = 1 - (gpGlobals->curtime - m_flLaunchTime) / ENERGY_GRENADE_LIFETIME;
game/server/SkyCamera.cpp:			if ( !Q_stricmp( s_pBogusFogMaps[i], STRING(gpGlobals->mapname) ) )
game/server/player_command.cpp:	//gpGlobals->curtime = thinktime;
game/server/player_command.cpp:				Warning( "sv_maxusrcmdprocessticks_warning at server tick %u: Ignored client %s usrcmd (%.6f < %.6f)!\n", gpGlobals->tickcount, player->GetPlayerName(), flTimeAllowedForProcessing, playerFrameTime );
game/server/player_command.cpp:	gpGlobals->curtime		=  playerCurTime;
game/server/player_command.cpp:	gpGlobals->frametime	=  playerFrameTime;
game/server/player_command.cpp:			gpGlobals->frametime = TICK_INTERVAL;
game/server/player_command.cpp:	if ( gpGlobals->frametime > 0 )
game/server/functorutils.h:	for( int i=1; i<=gpGlobals->maxClients; ++i )
game/server/functorutils.h:	for( int i=1; i<=gpGlobals->maxClients; ++i )
game/server/testfunctions.cpp:		else if ( gpGlobals->maxClients > 1 )
game/server/RagdollBoogie.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/RagdollBoogie.cpp:		SetContextThink( &CRagdollBoogie::ZapThink, gpGlobals->curtime + random->RandomFloat( 0.1f, 0.3f ), s_pZapContext ); 
game/server/RagdollBoogie.cpp:	SetContextThink( &CRagdollBoogie::ZapThink, gpGlobals->curtime + random->RandomFloat( 0.1f, 0.3f ), s_pZapContext ); 
game/server/RagdollBoogie.cpp:			float dt = gpGlobals->curtime - pBoogie->m_flStartTime;
game/server/RagdollBoogie.cpp:		float dt = gpGlobals->curtime - m_flStartTime;
game/server/RagdollBoogie.cpp:			SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1, 0.2f ) );
game/server/RagdollBoogie.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1, 0.2f ) );
game/server/ai_baseactor.cpp:				m_flBlinktime = gpGlobals->curtime + MAX( flDuration, random->RandomFloat( 1.5, 4.5 ) ); 
game/server/ai_baseactor.cpp:					info->m_flNext = gpGlobals->curtime + remaining;
game/server/ai_baseactor.cpp:						m_flBlinktime = MAX( m_flBlinktime, gpGlobals->curtime + flDuration );
game/server/ai_baseactor.cpp:						if (info->m_flNext < gpGlobals->curtime)
game/server/ai_baseactor.cpp:							info->m_flNext = gpGlobals->curtime + PickLookTarget( m_syntheticLookQueue ) - 0.4;
game/server/ai_baseactor.cpp:								m_syntheticLookQueue[i].m_flEndTime = MIN( m_syntheticLookQueue[i].m_flEndTime, gpGlobals->curtime + flDuration );
game/server/ai_baseactor.cpp:					if (info->m_hTarget && info->m_flNext < gpGlobals->curtime)
game/server/ai_baseactor.cpp:						info->m_flNext = gpGlobals->curtime + remaining;
game/server/ai_baseactor.cpp:	if (info->m_flNext < gpGlobals->curtime)
game/server/ai_baseactor.cpp:			info->m_flNext = gpGlobals->curtime + random->RandomFloat( 0.3, 0.5 ) * (30.0 / pSettinghdr->numflexsettings);
game/server/ai_baseactor.cpp:		m_flNextRandomLookTime = gpGlobals->curtime + 1.0;
game/server/ai_baseactor.cpp:			if (gpGlobals->curtime < m_randomLookQueue[i].m_flEndTime - m_randomLookQueue[i].m_flRamp - 0.2)
game/server/ai_baseactor.cpp:				m_randomLookQueue[i].m_flEndTime = gpGlobals->curtime + m_randomLookQueue[i].m_flRamp + 0.2;
game/server/ai_baseactor.cpp:		m_flNextRandomLookTime = gpGlobals->curtime + 1.0;
game/server/ai_baseactor.cpp:	else if (gpGlobals->curtime >= m_flNextRandomLookTime && GetState() != NPC_STATE_SCRIPT)
game/server/ai_baseactor.cpp:		m_flNextRandomLookTime = gpGlobals->curtime + PickLookTarget( m_randomLookQueue ) - 0.4;
game/server/ai_baseactor.cpp:	if ( m_flNextRandomExpressionTime && gpGlobals->curtime > m_flNextRandomExpressionTime )
game/server/ai_baseactor.cpp:	if (m_flBlinktime < gpGlobals->curtime)
game/server/ai_baseactor.cpp:		m_flBlinktime = gpGlobals->curtime + random->RandomFloat( 1.5, 4.5 );
game/server/ai_baseactor.cpp:		m_flNextRandomExpressionTime = gpGlobals->curtime + flDuration;
game/server/team_control_point.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/team_control_point.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/team_control_point.cpp:		event->SetFloat( "captime", gpGlobals->curtime - flLastOwnershipChangeTime );
game/server/team_control_point.cpp:			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/team_control_point.cpp:			Assert( playerIndex > 0 && playerIndex <= gpGlobals->maxClients );
game/server/team_control_point.cpp:			pMaster->SetLastOwnershipChangeTime( gpGlobals->curtime );
game/server/team_control_point.cpp:	m_flUnlockTime = gpGlobals->curtime + nTime;
game/server/team_control_point.cpp:	SetContextThink( &CTeamControlPoint::UnlockThink, gpGlobals->curtime + 0.1, CONTROL_POINT_UNLOCK_THINK );
game/server/team_control_point.cpp:		 m_flUnlockTime < gpGlobals->curtime && 
game/server/team_control_point.cpp:	SetContextThink( &CTeamControlPoint::UnlockThink, gpGlobals->curtime + 0.1, CONTROL_POINT_UNLOCK_THINK );
game/server/nav_area.cpp:	ConColorMsg( Color( 128, 255, 128, 255 ), "%f: Adding ent %d (team %d) to area %d\n", gpGlobals->curtime, entIndex, teamID, GetID() );
game/server/nav_area.cpp:	ConColorMsg( Color( 128, 128, 255, 255 ), "%f: Removing ent %d (team %d) from area %d\n", gpGlobals->curtime, entIndex, teamID, GetID() );
game/server/nav_area.cpp:		float deltaT = gpGlobals->curtime - m_dangerTimestamp[i];
game/server/nav_area.cpp:		m_dangerTimestamp[i] = gpGlobals->curtime;
game/server/nav_area.cpp:	m_dangerTimestamp[ teamIdx ] = gpGlobals->curtime;
game/server/logicauto.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/logicauto.cpp:		if (gpGlobals->eLoadType == MapLoad_Transition)
game/server/logicauto.cpp:		else if (gpGlobals->eLoadType == MapLoad_NewGame)
game/server/logicauto.cpp:		else if (gpGlobals->eLoadType == MapLoad_LoadGame)
game/server/logicauto.cpp:		else if (gpGlobals->eLoadType == MapLoad_Background)
game/server/particle_system.cpp:		m_flStartTime = gpGlobals->curtime;
game/server/rope.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/timedeventmgr.cpp:		m_flNextEventTime = gpGlobals->curtime + m_flUpdateInterval;
game/server/timedeventmgr.cpp:		while ( m_flNextEventTime <= gpGlobals->curtime )
game/server/timedeventmgr.cpp:		if ( gpGlobals->curtime >= pEvent->m_flNextEventTime )
game/server/dod/dod_control_point_master.h:		SetNextThink( gpGlobals->curtime + m_iTickLength );
game/server/dod/dod_control_point_master.h:		SetNextThink( gpGlobals->curtime + m_iTickLength );	
game/server/dod/dod_player.cpp:	m_flLastMovement = gpGlobals->curtime;
game/server/dod/dod_player.cpp:	m_flNextVoice = gpGlobals->curtime;
game/server/dod/dod_player.cpp:	m_flNextHandSignal = gpGlobals->curtime;
game/server/dod/dod_player.cpp:	m_flNextTimeCheck = gpGlobals->curtime;
game/server/dod/dod_player.cpp:	m_flLastClassChangeTime = gpGlobals->curtime;
game/server/dod/dod_player.cpp:		( ucmd->tick_count > (gpGlobals->tickcount + sv_max_usercmd_future_ticks.GetInt()) ) )
game/server/dod/dod_player.cpp:		DevMsg( "Client cmd out of sync (delta %i).\n", ucmd->tick_count - gpGlobals->tickcount );
game/server/dod/dod_player.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/dod/dod_player.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/dod/dod_player.cpp:	float flTimeBase = gpGlobals->curtime + gpGlobals->frametime - frametime;
game/server/dod/dod_player.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/dod/dod_player.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/dod/dod_player.cpp:	m_flIdleTime = gpGlobals->curtime + random->RandomFloat( 20, 30 );
game/server/dod/dod_player.cpp:	SetContextThink( &CDODPlayer::PushawayThink, gpGlobals->curtime + PUSHAWAY_THINK_INTERVAL, DOD_PUSHAWAY_THINK_CONTEXT );
game/server/dod/dod_player.cpp:	SetNextThink( gpGlobals->curtime + PUSHAWAY_THINK_INTERVAL, DOD_PUSHAWAY_THINK_CONTEXT );
game/server/dod/dod_player.cpp:	if ( gpGlobals->curtime > m_fHandleSignalsTime )
game/server/dod/dod_player.cpp:		m_fHandleSignalsTime = gpGlobals->curtime + 0.1;
game/server/dod/dod_player.cpp:	if (m_flNextVoice > gpGlobals->curtime )
game/server/dod/dod_player.cpp:	m_flNextVoice = gpGlobals->curtime + 1.0;
game/server/dod/dod_player.cpp:	if (m_flNextHandSignal > gpGlobals->curtime )
game/server/dod/dod_player.cpp:	m_flNextHandSignal = gpGlobals->curtime + 1.0;
game/server/dod/dod_player.cpp:					//m_flUnslowTime = gpGlobals->curtime + 2;
game/server/dod/dod_player.cpp:		m_flLastMovement = gpGlobals->curtime;
game/server/dod/dod_player.cpp:		if ( m_flLastMovement + mp_autokick.GetInt()*60 < gpGlobals->curtime )
game/server/dod/dod_player.cpp:			m_flLastMovement = gpGlobals->curtime;
game/server/dod/dod_player.cpp:			m_fNextSuicideTime = gpGlobals->curtime + 1.0;
game/server/dod/dod_player.cpp:	if( m_pIntroCamera && (gpGlobals->curtime >= m_fIntroCamTime) )
game/server/dod/dod_player.cpp:	m_flDeathTime = gpGlobals->curtime;
game/server/dod/dod_player.cpp:			if ( gpGlobals->curtime >= flFreezeSoundTime )
game/server/dod/dod_player.cpp:		if ( gpGlobals->curtime >= (m_flDeathTime + DOD_DEATH_ANIMATION_TIME ) )	// allow 2 seconds death animation / death cam
game/server/dod/dod_player.cpp:				if ( !m_bAbortFreezeCam && gpGlobals->curtime < flFreezeEnd )
game/server/dod/dod_player.cpp:			if ( gpGlobals->curtime >= flFreezeEnd )
game/server/dod/dod_player.cpp:		if ( gpGlobals->curtime >= (m_flDeathTime + DEATH_CAM_TIME ) )	// allow x seconds death animation / death cam
game/server/dod/dod_player.cpp:	if ( gpGlobals->curtime < flFreezeTravelTime )
game/server/dod/dod_player.cpp:		m_fIntroCamTime = gpGlobals->curtime + 6;
game/server/dod/dod_player.cpp:				pSpot->SetNextThink( gpGlobals->curtime + 0.5 );
game/server/dod/dod_player.cpp:		SetContextThink( &CDODPlayer::DeafenThink, gpGlobals->curtime + 0.3, DOD_DEAFEN_CONTEXT );
game/server/dod/dod_player.cpp:	if ( m_fNextSuicideTime > gpGlobals->curtime )
game/server/dod/dod_player.cpp:	m_fNextSuicideTime = gpGlobals->curtime + 5;  
game/server/dod/dod_player.cpp:		m_pIk->Init( pStudioHdr, GetAbsAngles(), adjOrigin, gpGlobals->curtime, m_iIKCounter, boneMask );
game/server/dod/dod_player.cpp:		CalculateIKLocks( gpGlobals->curtime );
game/server/dod/dod_player.cpp:	m_flTimePlayedPerClass[playerclass] += ( gpGlobals->curtime - m_flLastClassChangeTime );
game/server/dod/dod_player.cpp:	m_flLastClassChangeTime = gpGlobals->curtime;
game/server/dod/dod_player.cpp:	Msg( "Total time connected %.0f\n", ( gpGlobals->curtime - m_flConnectTime ) );
game/server/dod/dod_player.cpp:			m_flTimePlayedPerClass_Allies[iOldPlayerClass] += ( gpGlobals->curtime - m_flLastClassChangeTime );
game/server/dod/dod_player.cpp:			m_flTimePlayedPerClass_Axis[iOldPlayerClass] += ( gpGlobals->curtime - m_flLastClassChangeTime );
game/server/dod/dod_player.cpp:	m_flLastClassChangeTime = gpGlobals->curtime;
game/server/dod/dod_player.cpp:	for ( int i = 1 ; i <= gpGlobals->maxClients ; i++ )
game/server/dod/dod_player.cpp:	int iSecondsAlive = (int)( gpGlobals->curtime - m_flTimeAsClassAccumulator );
game/server/dod/dod_player.cpp:	m_flTimeAsClassAccumulator = gpGlobals->curtime;
game/server/dod/dod_smokegrenade.cpp:	SetNextThink( gpGlobals->curtime + 0.5 );
game/server/dod/dod_smokegrenade.cpp:		m_flRemoveTime = gpGlobals->curtime + 10;
game/server/dod/dod_smokegrenade.cpp:		m_flSmokeSpawnTime = gpGlobals->curtime;
game/server/dod/dod_smokegrenade.cpp:	if ( m_flRemoveTime > 0 && gpGlobals->curtime > m_flRemoveTime )
game/server/dod/dod_smokegrenade.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/dod/dod_smokegrenade.cpp:	SetNextThink( gpGlobals->curtime );
game/server/dod/dod_smokegrenade.cpp:		SetNextThink( gpGlobals->curtime + 10 );
game/server/dod/dod_ammo_box.cpp:	SetNextThink( gpGlobals->curtime + 0.75f );
game/server/dod/dod_area_capture.cpp:	SetNextThink( gpGlobals->curtime + AREA_THINK_TIME );
game/server/dod/dod_area_capture.cpp:	SetNextThink( gpGlobals->curtime + AREA_THINK_TIME );
game/server/dod/dod_area_capture.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/dod/dod_basegrenade.cpp:	m_flCollideWithTeammatesTime = gpGlobals->curtime + 0.25;
game/server/dod/dod_basegrenade.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/dod/dod_basegrenade.cpp:	if ( gpGlobals->curtime > m_flCollideWithTeammatesTime && m_bCollideWithTeammates == false )
game/server/dod/dod_basegrenade.cpp:	if( gpGlobals->curtime > m_flDetonateTime )
game/server/dod/dod_basegrenade.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/dod/dod_basegrenade.cpp:	m_flDetonateTime = gpGlobals->curtime + timer;
game/server/dod/dod_basegrenade.cpp:		if ( vecVelocity.z < ( GetCurrentGravity() * gpGlobals->frametime ) )
game/server/dod/dod_basegrenade.cpp:			VectorScale( vecAbsVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, vecVelocity ); 
game/server/dod/dod_basegrenade.cpp:			VectorMA( vecVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, GetBaseVelocity() * flScale, vecVelocity );
game/server/dod/dod_basegrenade.cpp:	SetNextThink( gpGlobals->curtime );
game/server/dod/dod_basegrenade.cpp:	UTIL_TraceLine( start, start + vel * gpGlobals->frametime, CONTENTS_HITBOX|CONTENTS_MONSTER|CONTENTS_SOLID, &filter, &tr );
game/server/dod/dod_baserocket.cpp:	m_flCollideWithTeammatesTime = gpGlobals->curtime + 0.25;
game/server/dod/dod_baserocket.cpp:	SetNextThink( gpGlobals->curtime );
game/server/dod/dod_baserocket.cpp:	if ( gpGlobals->curtime > m_flCollideWithTeammatesTime && m_bCollideWithTeammates == false )
game/server/dod/dod_baserocket.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/dod/dod_control_point.cpp:			Assert( playerIndex > 0 && playerIndex <= gpGlobals->maxClients );
game/server/dod/dod_control_point.cpp:	m_flBombExplodeTime = gpGlobals->curtime + flTimerLength;
game/server/dod/dod_client.cpp:	if (gpGlobals->coop || gpGlobals->deathmatch)
game/server/dod/dod_client.cpp:	gpGlobals->teamplay = teamplay.GetInt() ? true : false;
game/server/dod/dod_player_resource.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/dod/dod_bot_temp.cpp:	g_BotData[pPlayer->entindex()-1].m_flJoinTeamTime = gpGlobals->curtime + 0.3;
game/server/dod/dod_bot_temp.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/dod/dod_bot_temp.cpp:	if ( bot_mimic.GetInt() > gpGlobals->maxClients )
game/server/dod/dod_bot_temp.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/dod/dod_bot_temp.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/dod/dod_bot_temp.cpp:	float flTimeBase = gpGlobals->curtime + gpGlobals->frametime - frametime;
game/server/dod/dod_bot_temp.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/dod/dod_bot_temp.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/dod/dod_bot_temp.cpp:	float frametime = gpGlobals->frametime;
game/server/dod/dod_bot_temp.cpp:	if ( pBot->GetTeamNumber() == TEAM_UNASSIGNED && gpGlobals->curtime > botdata->m_flJoinTeamTime )
game/server/dod/dod_bot_temp.cpp:					if ( gpGlobals->curtime < botdata->nextturntime )
game/server/dod/dod_bot_temp.cpp:				botdata->nextturntime = gpGlobals->curtime + 2.0;
game/server/dod/dod_bot_temp.cpp:			if ( gpGlobals->curtime >= botdata->nextstrafetime )
game/server/dod/dod_bot_temp.cpp:				botdata->nextstrafetime = gpGlobals->curtime + 1.0f;
game/server/dod/dod_bot_temp.cpp:		botdata->lastAngles.x = sin( gpGlobals->curtime + pBot->entindex() ) * 90;
game/server/dod/dod_bot_temp.cpp:		botdata->lastAngles.y = AngleNormalize( ( gpGlobals->curtime * 1.7 + pBot->entindex() ) * 45 );
game/server/dod/dod_bot_temp.cpp:		float speed = 300; // sin( gpGlobals->curtime / 1.7 + pBot->entindex() ) * 600;
game/server/dod/dod_bot_temp.cpp:		forwardmove = sin( gpGlobals->curtime + pBot->entindex() ) * speed;
game/server/dod/dod_bot_temp.cpp:		sidemove = cos( gpGlobals->curtime * 2.3 + pBot->entindex() ) * speed;
game/server/dod/dod_bot_temp.cpp:		if (sin(gpGlobals->curtime ) < -0.5)
game/server/dod/dod_bot_temp.cpp:		else if (sin(gpGlobals->curtime ) < 0.5)
game/server/dod/dod_control_point_master.cpp:	m_fGivePointsTime = gpGlobals->curtime + mp_tickpointinterval.GetInt();
game/server/dod/dod_control_point_master.cpp:		SetContextThink( &CControlPointMaster::CPMThink, gpGlobals->curtime + 0.2, FLAGS_CONTEXT );
game/server/dod/dod_control_point_master.cpp:	if( gpGlobals->curtime > m_fGivePointsTime )
game/server/dod/dod_control_point_master.cpp:		m_fGivePointsTime = gpGlobals->curtime + mp_tickpointinterval.GetInt();
game/server/dod/dod_control_point_master.cpp:	SetContextThink( &CControlPointMaster::CPMThink, gpGlobals->curtime + 0.2, FLAGS_CONTEXT );
game/server/dod/dod_control_point_master.cpp:		SetContextThink( &CControlPointMaster::CPMThink, gpGlobals->curtime + 0.1, FLAGS_CONTEXT );
game/server/dod/dod_bombtarget.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/dod/dod_bombtarget.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/dod/dod_bombtarget.cpp:	m_flExplodeTime = gpGlobals->curtime + GetBombTimerLength();
game/server/dod/dod_bombtarget.cpp:		if ( m_pPlantingPlayer && FStrEq( STRING(gpGlobals->mapname), "dod_jagd" ) )
game/server/dod/dod_bombtarget.cpp:	if ( !pDefuseRecord || pDefuseRecord->m_flDefuseTimeoutTime < gpGlobals->curtime )
game/server/dod/dod_bombtarget.cpp:	float flTimeLeft = m_flExplodeTime - gpGlobals->curtime;
game/server/dod/dod_bombtarget.cpp:				if ( pDefuseRecord->m_flDefuseCompleteTime < gpGlobals->curtime )
game/server/dod/dod_bombtarget.cpp:	else if ( gpGlobals->curtime > m_flExplodeTime )
game/server/dod/dod_bombtarget.cpp:		pDefusingPlayerRecord->m_flDefuseTimeoutTime = gpGlobals->curtime + 0.2;
game/server/dod/dod_bombtarget.cpp:		defusingPlayer.m_flDefuseCompleteTime = gpGlobals->curtime + DOD_BOMB_DEFUSE_TIME;
game/server/dod/dod_bombtarget.cpp:		defusingPlayer.m_flDefuseTimeoutTime = gpGlobals->curtime + 0.2;
game/server/dod/holiday_gift.cpp:	SetContextThink( &CBaseEntity::SUB_Remove, gpGlobals->curtime + 30, "DIE_THINK" );
game/server/dod/holiday_gift.cpp:	SetContextThink( &CHolidayGift::DropSoundThink, gpGlobals->curtime + 0.2f, "SOUND_THINK" );
game/server/EnvShake.cpp:				m_stopTime = gpGlobals->curtime + Duration();
game/server/EnvShake.cpp:				SetNextThink( gpGlobals->curtime );
game/server/EnvShake.cpp:	if ( gpGlobals->curtime > m_nextShake )
game/server/EnvShake.cpp:		m_nextShake = gpGlobals->curtime + (1.0f / Frequency());
game/server/EnvShake.cpp:	float fraction = ( m_stopTime - gpGlobals->curtime ) / Duration();
game/server/EnvShake.cpp:	fraction = fraction * sin( gpGlobals->curtime * freq );
game/server/EnvShake.cpp:	m_currentAmp -= m_currentAmp * ( gpGlobals->frametime / (Duration() * Frequency()) );
game/server/EnvShake.cpp:	SetNextThink( gpGlobals->curtime );
game/server/player.cpp:	if ( IsEffectActive( EF_NODRAW ) || ( IsObserver() && ( gpGlobals->curtime - m_flDeathTime > 0.5 ) && 
game/server/player.cpp:		( m_lifeState == LIFE_DEAD ) && ( gpGlobals->curtime - m_flDeathAnimTime > 0.5 ) ) )
game/server/player.cpp:	Q_snprintf(buf, 256, "[%f] Player %s healed for %d with damagetype %X\n", gpGlobals->curtime, GetDebugName(), healingTaken, bitsDamageType);
game/server/player.cpp:		Q_snprintf( outputString, 256, "%f: Player %s at [%0.2f %0.2f %0.2f] took %f damage from %s, type %s\n", gpGlobals->curtime, GetDebugName(),
game/server/player.cpp:		//Msg( "%f: Player %s at [%0.2f %0.2f %0.2f] took %f damage from %s, type %s\n", gpGlobals->curtime, GetDebugName(),
game/server/player.cpp:				m_tbdPrev = gpGlobals->curtime;
game/server/player.cpp:	m_flDeathTime = gpGlobals->curtime;
game/server/player.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/player.cpp:		m_AirFinished = gpGlobals->curtime + AIRTIME;
game/server/player.cpp:		if (m_AirFinished < gpGlobals->curtime)
game/server/player.cpp:		m_AirFinished = gpGlobals->curtime + AIRTIME;
game/server/player.cpp:		if (m_AirFinished < gpGlobals->curtime && !(GetFlags() & FL_GODMODE) )		// drown!
game/server/player.cpp:			if (m_PainFinished < gpGlobals->curtime)
game/server/player.cpp:				m_PainFinished = gpGlobals->curtime + 1;
game/server/player.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/player.cpp:		m_flDeathAnimTime = gpGlobals->curtime;
game/server/player.cpp:	if ( g_pGameRules->IsMultiplayer() && ( gpGlobals->curtime > (m_flDeathTime + DEATH_ANIMATION_TIME) ) && !IsObserver() )
game/server/player.cpp:		&& !( g_pGameRules->IsMultiplayer() && forcerespawn.GetInt() > 0 && (gpGlobals->curtime > (m_flDeathTime + 5))) )
game/server/player.cpp:	if ( gpGlobals->eLoadType != MapLoad_Background )
game/server/player.cpp:	m_flDeathAnimTime = gpGlobals->curtime;
game/server/player.cpp:	m_fReplayEnd = gpGlobals->curtime + fDuration;
game/server/player.cpp:	if ( m_fReplayEnd > gpGlobals->curtime )
game/server/player.cpp:		if ( (player->m_flDeathTime + DEATH_ANIMATION_TIME ) < gpGlobals->curtime )
game/server/player.cpp:	if (startIndex > gpGlobals->maxClients)
game/server/player.cpp:		startIndex = gpGlobals->maxClients;
game/server/player.cpp:/*	if ( m_flNextFollowTime && m_flNextFollowTime > gpGlobals->time )
game/server/player.cpp:	m_flNextFollowTime = gpGlobals->time + 0.25;
game/server/player.cpp:  		if (currentIndex > gpGlobals->maxClients)
game/server/player.cpp:  			currentIndex = gpGlobals->maxClients;
game/server/player.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/player.cpp:		// set TickBase so that player simulation tick matches gpGlobals->tickcount after
game/server/player.cpp:		m_nTickBase = gpGlobals->tickcount - simulation_ticks + gpGlobals->simTicksThisFrame;
game/server/player.cpp:		//  alternate around this target tick without getting smaller than gpGlobals->tickcount.
game/server/player.cpp:		// After running the commands simulation time should be equal or after current gpGlobals->tickcount, 
game/server/player.cpp:		int	nIdealFinalTick = gpGlobals->tickcount + nCorrectionTicks;
game/server/player.cpp:			int nCorrectedTick = nIdealFinalTick - simulation_ticks + gpGlobals->simTicksThisFrame;
game/server/player.cpp:		pi->m_flFinalSimulationTime = TICKS_TO_TIME( m_nTickBase + simulation_ticks + gpGlobals->simTicksThisFrame );
game/server/player.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/player.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/player.cpp:	float flTimeBase = gpGlobals->curtime;
game/server/player.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/player.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/player.cpp:	if ( m_nSimulationTick == gpGlobals->tickcount )
game/server/player.cpp:	m_nSimulationTick = gpGlobals->tickcount;
game/server/player.cpp:	float savetime		= gpGlobals->curtime;
game/server/player.cpp:	float saveframetime = gpGlobals->frametime;
game/server/player.cpp:	// gpGlobals->simTicksThisFrame == number of ticks remaining to be run, so we should take the last N CUserCmds and postpone them until the next frame
game/server/player.cpp:	if ( gpGlobals->simTicksThisFrame >= commandLimit && vecAvailCommands.Count() > commandLimit )
game/server/player.cpp:		int commandsToRollOver = MIN( vecAvailCommands.Count(), ( gpGlobals->simTicksThisFrame - 1 ) );
game/server/player.cpp:	if ( gpGlobals->maxClients != 1 && numUsrCmdProcessTicksMax ) // don't apply this filter in SP games
game/server/player.cpp:			pi->m_flGameSimulationTime = gpGlobals->curtime;
game/server/player.cpp:	gpGlobals->curtime		= savetime;
game/server/player.cpp:	gpGlobals->frametime	= saveframetime;	
game/server/player.cpp:	const int nCmdMaxTickDelta = ( 1.f / gpGlobals->interval_per_tick ) * 2.5f;
game/server/player.cpp:	const int nMinDelta = Max( 0, gpGlobals->tickcount - nCmdMaxTickDelta );
game/server/player.cpp:	const int nMaxDelta = gpGlobals->tickcount + nCmdMaxTickDelta;
game/server/player.cpp:		(developer.GetInt() == 0 && gpGlobals->eLoadType == MapLoad_NewGame && gpGlobals->curtime < 3.0 ) )
game/server/player.cpp:	if ( abs( gpGlobals->curtime - m_tbdPrev ) < 2.0 )
game/server/player.cpp:	m_tbdPrev = gpGlobals->curtime;
game/server/player.cpp:	if (gpGlobals->curtime < m_flgeigerDelay)
game/server/player.cpp:	m_flgeigerDelay = gpGlobals->curtime + GEIGERDELAY;
game/server/player.cpp:	if ( gpGlobals->curtime >= m_flSuitUpdate && m_flSuitUpdate > 0)
game/server/player.cpp:		m_flSuitUpdate = gpGlobals->curtime + SUITUPDATETIME;
game/server/player.cpp:			if (m_rgflSuitNoRepeatTime[i] < gpGlobals->curtime)
game/server/player.cpp:		m_rgflSuitNoRepeatTime[iempty] = iNoRepeatTime + gpGlobals->curtime;
game/server/player.cpp:	if (m_flSuitUpdate <= gpGlobals->curtime)
game/server/player.cpp:			m_flSuitUpdate = gpGlobals->curtime + SUITFIRSTUPDATETIME;
game/server/player.cpp:			m_flSuitUpdate = gpGlobals->curtime + SUITUPDATETIME; 
game/server/player.cpp:		iVolume -= 250 * gpGlobals->frametime;
game/server/player.cpp:		SetSimulationTime( gpGlobals->curtime );
game/server/player.cpp:	float frametime = gpGlobals->frametime;
game/server/player.cpp:	UpdateVPhysicsPosition( GetAbsOrigin(), vec3_origin, gpGlobals->frametime );
game/server/player.cpp:	UpdateVPhysicsPosition( vecAbsOrigin, vec3_origin, gpGlobals->frametime );
game/server/player.cpp:	if ( !gpGlobals->startspot || !strlen(STRING(gpGlobals->startspot)))
game/server/player.cpp:		pSpot = gEntList.FindEntityByName( NULL, gpGlobals->startspot );
game/server/player.cpp:	m_AirFinished	= gpGlobals->curtime + AIRTIME;
game/server/player.cpp:	m_flgeigerDelay = gpGlobals->curtime + 2.0;	// wait a few seconds until user-defined message registrations
game/server/player.cpp:	CSaveRestoreData *pSaveData = gpGlobals->pSaveData;
game/server/player.cpp:	m_flNextDecalTime = gpGlobals->curtime;
game/server/player.cpp:	if ( m_fNextSuicideTime > gpGlobals->curtime && !bForce )
game/server/player.cpp:	m_fNextSuicideTime = gpGlobals->curtime + 5;
game/server/player.cpp:	if ( m_fNextSuicideTime > gpGlobals->curtime && !bForce )
game/server/player.cpp:	m_fNextSuicideTime = gpGlobals->curtime + 5;  
game/server/player.cpp:	SetNextThink( gpGlobals->curtime );
game/server/player.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/player.cpp:		if ( gpGlobals->curtime < m_flNextDecalTime )
game/server/player.cpp:			m_flNextDecalTime = gpGlobals->curtime + decalfrequency.GetFloat();
game/server/player.cpp:		if ( gpGlobals->curtime < m_flNextDecalTime )
game/server/player.cpp:		m_flNextDecalTime = gpGlobals->curtime + decalfrequency.GetFloat();
game/server/player.cpp:			nRecip = clamp( Q_atoi( args.Arg( 1 ) ), 1, gpGlobals->maxClients );
game/server/player.cpp:	if ((m_flFlashLightTime) && (m_flFlashLightTime <= gpGlobals->curtime))
game/server/player.cpp:				m_flFlashLightTime = FLASH_DRAIN_TIME + gpGlobals->curtime;
game/server/player.cpp:				m_flFlashLightTime = FLASH_CHARGE_TIME + gpGlobals->curtime;
game/server/player.cpp:	if ( gpGlobals->maxClients > 1 )
game/server/player.cpp:	SetNextThink( gpGlobals->curtime + LoadTime() );
game/server/player.cpp:	SetNextThink( gpGlobals->curtime + MessageTime() );
game/server/player.cpp:	SetNextThink( gpGlobals->curtime + LoadTime() );
game/server/player.cpp:		SetNextThink( gpGlobals->curtime + nextThink );
game/server/player.cpp:	if ( !gpGlobals->deathmatch )
game/server/player.cpp:	float deltaTime = (float)( gpGlobals->curtime - m_flFOVTime ) / m_Local.m_flFOVRate;
game/server/player.cpp:	if ( gpGlobals->curtime - m_flFOVTime < m_Local.m_flFOVRate )
game/server/player.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/player.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/player.cpp:		float flOldFrametime = gpGlobals->frametime;
game/server/player.cpp:		float flOldCurtime = gpGlobals->curtime;
game/server/player.cpp:		m_pParent->SetTimeBase( gpGlobals->curtime );
game/server/player.cpp:		gpGlobals->frametime = flOldFrametime;
game/server/player.cpp:		gpGlobals->curtime = flOldCurtime;
game/server/ai_basenpc.h:	void				DelayMoveStart( float delay )	{ m_flMoveWaitFinished = gpGlobals->curtime + delay; }
game/server/ai_basenpc.h:	void				AddSceneLock( float flDuration = 0.2f ) { m_flSceneTime = MAX( gpGlobals->curtime + flDuration, m_flSceneTime ); };
game/server/ai_basenpc.h:	void				ClearSceneLock( float flDuration = 0.2f ) { m_flSceneTime = gpGlobals->curtime + flDuration; };
game/server/ai_basenpc.h:	bool				IsInLockedScene( void ) { return m_flSceneTime > gpGlobals->curtime; };
game/server/ai_basenpc.h:	void				StartPingEffect( void ) { m_flTimePingEffect = gpGlobals->curtime + 2.0f; DispatchUpdateTransmitState(); }
game/server/vote_controller.cpp:	SetNextThink( gpGlobals->curtime );
game/server/vote_controller.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/vote_controller.cpp:			if ( m_VoteCallers[ iIdx ] - gpGlobals->curtime <= 0 )
game/server/vote_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/vote_controller.cpp:		m_VoteCallers[ iIdx ] = gpGlobals->curtime + sv_vote_creation_timer.GetInt();
game/server/vote_controller.cpp:	m_VoteCallers.Insert( steamID.ConvertToUint64(), gpGlobals->curtime + sv_vote_creation_timer.GetInt() );
game/server/vote_controller.cpp:		nCooldown = (int)( m_VoteCallers[ iIdx ] - gpGlobals->curtime );
game/server/vote_controller.cpp:				pFailedVote->flLockoutTime = gpGlobals->curtime + nTime;
game/server/vote_controller.cpp:		m_FailedVotes[iIndex]->flLockoutTime = gpGlobals->curtime + sv_vote_failure_timer.GetFloat();
game/server/vote_controller.cpp:		int nTimeRemaining = pCurrentFailure->flLockoutTime - gpGlobals->curtime;
game/server/h_cycler.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/h_cycler.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/h_cycler.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/h_cycler.cpp:		pOwner->m_flNextAttack = gpGlobals->curtime + 1.0;
game/server/h_cycler.cpp:		pOwner->m_flNextAttack = gpGlobals->curtime + 0.5;
game/server/h_cycler.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.3;
game/server/h_cycler.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3;
game/server/h_cycler.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/h_cycler.cpp:	m_flStartTime		= gpGlobals->curtime;
game/server/h_cycler.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/h_cycler.cpp:		if (m_flDieTime < gpGlobals->curtime)
game/server/h_cycler.cpp:		else if (random->RandomFloat( 0, m_flDieTime - m_flStartTime ) > m_flDieTime - gpGlobals->curtime)
game/server/h_cycler.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/h_cycler.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/point_camera.cpp:	SetNextThink( gpGlobals->curtime );
game/server/point_camera.cpp:	SetNextThink( gpGlobals->curtime + CAM_THINK_INTERVAL );
game/server/wcedit.cpp:	int status = Editor_CheckVersion(STRING(gpGlobals->mapname), gpGlobals->mapversion, false);
game/server/genericmonster.cpp:	SetNextThink( gpGlobals->curtime );
game/server/gameweaponmanager.cpp:	SetNextThink( gpGlobals->curtime );
game/server/gameweaponmanager.cpp:	SetNextThink( gpGlobals->curtime + 2.0 );
game/server/gameweaponmanager.cpp:		if ( gpGlobals->maxClients == 1 )
game/server/player_lagcompensation.cpp:	if ( (gpGlobals->maxClients <= 1) || !sv_unlag.GetBool() )
game/server/player_lagcompensation.cpp:	int flDeadtime = gpGlobals->curtime - sv_maxunlag.GetFloat();
game/server/player_lagcompensation.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/player_lagcompensation.cpp:		 || (gpGlobals->maxClients <= 1)	// no lag compensation in single player
game/server/player_lagcompensation.cpp:	float deltaTime =  correct - TICKS_TO_TIME(gpGlobals->tickcount - targettick);
game/server/player_lagcompensation.cpp:		targettick = gpGlobals->tickcount - TIME_TO_TICKS( correct );
game/server/player_lagcompensation.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/player_lagcompensation.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/genericactor.cpp:		else if (m_flextime < gpGlobals->curtime)
game/server/genericactor.cpp:			m_flextime = gpGlobals->curtime + random->RandomFloat( 0.3, 0.5 ) * (30.0 / GetNumFlexControllers());
game/server/genericactor.cpp:			m_flNextEyeLookTime = gpGlobals->curtime + 1000.0;
game/server/genericactor.cpp:			m_flNextEyeLookTime = gpGlobals->curtime;
game/server/basegrenade_concussion.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat(0.05, 0.1) );
game/server/basegrenade_concussion.cpp:	SetNextThink( gpGlobals->curtime );
game/server/physics_prop_ragdoll.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/physics_prop_ragdoll.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/physics_prop_ragdoll.cpp:			CRagdollBoogie::Create( this, 150, gpGlobals->curtime, 3.0f, SF_RAGDOLL_BOOGIE_ELECTRICAL );
game/server/physics_prop_ragdoll.cpp:			CRagdollBoogie::Create( this, 150, gpGlobals->curtime, 2.0f, 0.0f );
game/server/physics_prop_ragdoll.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/physics_prop_ragdoll.cpp:		CRagdollBoogie::Create( this, 150, gpGlobals->curtime, 3.0f, SF_RAGDOLL_BOOGIE_ELECTRICAL );
game/server/physics_prop_ragdoll.cpp:		SetContextThink( &CRagdollProp::SetDebrisThink, gpGlobals->curtime + 5, s_pDebrisContext );
game/server/physics_prop_ragdoll.cpp:	if (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime)
game/server/physics_prop_ragdoll.cpp:		SetNextThink( gpGlobals->curtime );
game/server/physics_prop_ragdoll.cpp:		SetContextThink( &CRagdollProp::SetDebrisThink, gpGlobals->curtime + 5, s_pDebrisContext );
game/server/physics_prop_ragdoll.cpp:	if ( m_lastUpdateTickCount == (unsigned int)gpGlobals->tickcount )
game/server/physics_prop_ragdoll.cpp:	m_lastUpdateTickCount = gpGlobals->tickcount;
game/server/physics_prop_ragdoll.cpp:		SetContextThink( NULL, gpGlobals->curtime, s_pDebrisContext );
game/server/physics_prop_ragdoll.cpp:	m_flFadeOutStartTime = gpGlobals->curtime + flDelay;
game/server/physics_prop_ragdoll.cpp:	SetContextThink( &CRagdollProp::FadeOutThink, gpGlobals->curtime + flDelay + 0.01f, s_pFadeOutContext );
game/server/physics_prop_ragdoll.cpp:	return ( GetNextThink( s_pFadeOutContext ) >= gpGlobals->curtime );
game/server/physics_prop_ragdoll.cpp:	float dt = gpGlobals->curtime - m_flFadeOutStartTime;
game/server/physics_prop_ragdoll.cpp:		SetContextThink( &CRagdollProp::FadeOutThink, gpGlobals->curtime + 0.1, s_pFadeOutContext );
game/server/physics_prop_ragdoll.cpp:		SetContextThink( &CRagdollProp::FadeOutThink, gpGlobals->curtime + TICK_INTERVAL, s_pFadeOutContext );
game/server/physics_prop_ragdoll.cpp:	CRagdollBoogie::Create( this, 100, gpGlobals->curtime, duration, 0 );
game/server/EnvSpark.cpp:	SetNextThink( gpGlobals->curtime + 0.1 + random->RandomFloat( 0, 1.5 ) );
game/server/EnvSpark.cpp:	SetNextThink( gpGlobals->curtime + 0.1 + random->RandomFloat(0, m_flDelay) );
game/server/EnvSpark.cpp:	SetNextThink( gpGlobals->curtime );
game/server/baseflex.cpp:					if (gpGlobals->frametime > ai_expression_frametime.GetFloat())
game/server/baseflex.cpp:						info->m_flNext = gpGlobals->curtime + RandomFloat( 0.7, 1.2 );
game/server/baseflex.cpp:					else if (info->m_flNext <= gpGlobals->curtime)
game/server/baseflex.cpp:						info->m_flNext = gpGlobals->curtime + RandomFloat( 0.7, 1.2 );
game/server/baseflex.cpp:	if ( gpGlobals->curtime + response_length <= m_flAllowResponsesEndTime )
game/server/baseflex.cpp:		return m_flLastFlexAnimationTime > gpGlobals->curtime - GetAnimTimeInterval() * 1.5;
game/server/baseflex.cpp:	m_flLastFlexAnimationTime = gpGlobals->curtime;
game/server/baseflex.cpp:		float dt = gpGlobals->curtime - GetLastThink();
game/server/baseflex.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/baseflex.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/baseflex.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/baseflex.cpp:				float fFlexTime = i * (1.0f / (float)GetNumFlexControllers()) + gpGlobals->curtime;
game/server/baseflex.cpp:		else if (m_flextime < gpGlobals->curtime)
game/server/baseflex.cpp:			// m_flextime = gpGlobals->curtime + 1.0; // RandomFloat( 0.1, 0.5 );
game/server/baseflex.cpp:			m_flextime = gpGlobals->curtime + random->RandomFloat( 0.3, 0.5 ) * (30.0 / GetNumFlexControllers());
game/server/baseflex.cpp:			if (m_speaktime < gpGlobals->curtime)
game/server/baseflex.cpp:					m_looktime = gpGlobals->curtime - 1.0;
game/server/baseflex.cpp:					m_speaktime = gpGlobals->curtime + random->RandomFloat( 0.5, 2.0 );
game/server/baseflex.cpp:					m_speaktime = gpGlobals->curtime + random->RandomFloat( 1.0, 3.0 );
game/server/baseflex.cpp:				m_flextime = gpGlobals->curtime + random->RandomFloat( 0.0, 0.2 );
game/server/baseflex.cpp:		if (m_blinktime < gpGlobals->curtime)
game/server/baseflex.cpp:			m_blinktime = gpGlobals->curtime + random->RandomFloat( 1.5, 4.5 );
game/server/baseflex.cpp:			m_looktime = gpGlobals->curtime + random->RandomFloat(2.0,4.0);
game/server/baseflex.cpp:		else if (m_looktime < gpGlobals->curtime)
game/server/baseflex.cpp:				m_looktime = gpGlobals->curtime + random->RandomFloat(0.3,1.0);
game/server/baseflex.cpp:				if (m_blinktime - 0.5 < gpGlobals->curtime)
game/server/baseflex.cpp:				m_looktime = gpGlobals->curtime + random->RandomFloat(1.0,4.0);
game/server/globalstate.cpp:	Msg( "Server game time: %f\n", gpGlobals->curtime );
game/server/ai_basenpc_flyer.h:			m_vCurrentVelocity.x += noiseScale*sin(m_vNoiseMod.x * gpGlobals->curtime + m_vNoiseMod.x);
game/server/ai_basenpc_flyer.h:			m_vCurrentVelocity.y += noiseScale*cos(m_vNoiseMod.y * gpGlobals->curtime + m_vNoiseMod.y);
game/server/ai_basenpc_flyer.h:			m_vCurrentVelocity.z -= noiseScale*cos(m_vNoiseMod.z * gpGlobals->curtime + m_vNoiseMod.z);
game/server/colorcorrection.cpp:	m_flTimeStartFadeIn = gpGlobals->curtime;
game/server/colorcorrection.cpp:	SetNextThink ( gpGlobals->curtime + COLOR_CORRECTION_ENT_THINK_RATE, s_pFadeInContextThink );
game/server/colorcorrection.cpp:	m_flTimeStartFadeOut = gpGlobals->curtime;
game/server/colorcorrection.cpp:	SetNextThink ( gpGlobals->curtime + COLOR_CORRECTION_ENT_THINK_RATE, s_pFadeOutContextThink );
game/server/colorcorrection.cpp:	float flFadeRatio = (gpGlobals->curtime - m_flTimeStartFadeIn) / flTimeToFade;
game/server/colorcorrection.cpp:	SetNextThink( gpGlobals->curtime + COLOR_CORRECTION_ENT_THINK_RATE, s_pFadeInContextThink );
game/server/colorcorrection.cpp:	float flFadeRatio = (gpGlobals->curtime - m_flTimeStartFadeOut) / flTimeToFade;
game/server/colorcorrection.cpp:	SetNextThink( gpGlobals->curtime + COLOR_CORRECTION_ENT_THINK_RATE, s_pFadeOutContextThink );
game/server/ai_moveshoot.cpp:	GetOuter()->GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + m_initialDelay );
game/server/ai_moveshoot.cpp:		GetOuter()->GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + 0.3f );
game/server/ai_moveshoot.cpp:	if ( gpGlobals->curtime < m_flSuspendUntilTime )
game/server/ai_moveshoot.cpp:	m_flSuspendUntilTime = gpGlobals->curtime + flDuration;
game/server/game_ui.cpp:	SetNextThink( gpGlobals->curtime );
game/server/game_ui.cpp:	SetNextThink( gpGlobals->curtime );
game/server/sound.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/sound.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/sound.cpp:			if ( V_strcmp( STRING( gpGlobals->mapname ), "testchmb_a_00" ) == 0 || 
game/server/sound.cpp:			    V_strcmp( STRING( gpGlobals->mapname ), "testchmb_a_11" ) == 0 || 
game/server/sound.cpp:			    V_strcmp( STRING( gpGlobals->mapname ), "testchmb_a_14" ) == 0 )
game/server/sound.cpp:		if ( gpGlobals->eLoadType == MapLoad_Transition ||
game/server/sound.cpp:			 gpGlobals->eLoadType == MapLoad_LoadGame || 
game/server/sound.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/sound.cpp:	SetNextThink( gpGlobals->curtime + AMBIENT_GENERIC_THINK_DELAY );
game/server/sound.cpp:				SetNextThink( gpGlobals->curtime + 0.1f );
game/server/sound.cpp:				SetNextThink( gpGlobals->curtime + 0.1f );
game/server/sound.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/team_control_point_master.cpp:		SetContextThink( &CTeamControlPointMaster::CPMThink, gpGlobals->curtime + 0.2, CPM_THINK );
game/server/team_control_point_master.cpp:	SetContextThink( &CTeamControlPointMaster::CPMThink, gpGlobals->curtime + 0.2, CPM_THINK );
game/server/team_control_point_master.cpp:		SetContextThink( &CTeamControlPointMaster::CPMThink, gpGlobals->curtime + 0.1, CPM_THINK );
game/server/ai_squad.cpp:				   gpGlobals->curtime - pMember->GetEnemyLastTimeSeen() > 3.0 ) )
game/server/ai_squad.cpp:	if (gpGlobals->curtime <= m_flSquadSoundWaitTime)
game/server/ai_squad.cpp:	if ( gpGlobals->curtime > m_flEnemyInfoCleanupTime )
game/server/ai_squad.cpp:		m_flEnemyInfoCleanupTime = gpGlobals->curtime + 30;
game/server/basebludgeonweapon.cpp:	if ( (pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime) )
game/server/basebludgeonweapon.cpp:	else if ( (pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime) )
game/server/basebludgeonweapon.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + GetFireRate();
game/server/basebludgeonweapon.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/ai_networkmanager.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/ai_networkmanager.cpp:	Q_snprintf( tempFilename, sizeof( tempFilename ), "%s/%s", szNrpFilename, STRING( gpGlobals->mapname ) );
game/server/ai_networkmanager.cpp:	Q_strncat( szNrpFilename, STRING( gpGlobals->mapname ), sizeof( szNrpFilename ), COPY_ALL_CHARACTERS );
game/server/ai_networkmanager.cpp:	buf.PutInt(gpGlobals->mapversion);
game/server/ai_networkmanager.cpp:	Q_strncat( szNrpFilename, STRING( gpGlobals->mapname ), COPY_ALL_CHARACTERS );
game/server/ai_networkmanager.cpp:	Q_strncat( szNrpFilename, STRING( gpGlobals->mapname ), sizeof( szNrpFilename ), COPY_ALL_CHARACTERS );
game/server/ai_networkmanager.cpp:	if ( mapversion != gpGlobals->mapversion && !g_ai_norebuildgraph.GetBool() )
game/server/ai_networkmanager.cpp:	Q_strncat( szNrpFilename, STRING( gpGlobals->mapname ), COPY_ALL_CHARACTERS );
game/server/ai_networkmanager.cpp:	if ( CAI_NetworkManager::IsAIFileCurrent( STRING( gpGlobals->mapname ) ) )
game/server/ai_networkmanager.cpp:	pNetwork->SetNextThink( gpGlobals->curtime );
game/server/ai_networkmanager.cpp:				int status = Editor_BeginSession(STRING(gpGlobals->mapname), gpGlobals->mapversion, false);
game/server/ai_networkmanager.cpp:					gpGlobals->mapversion++;
game/server/ai_networkmanager.cpp:			g_pAINetworkManager->SetNextThink( gpGlobals->curtime + 1 );
game/server/ai_networkmanager.cpp:		if (m_fNextPerfStatTime < gpGlobals->curtime)
game/server/ai_networkmanager.cpp:			m_fNextPerfStatTime = gpGlobals->curtime + 1;
game/server/hl2/npc_barnacle.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl2/npc_barnacle.cpp: 	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_barnacle.cpp:			if ( m_flDigestFinish > gpGlobals->curtime )
game/server/hl2/npc_barnacle.cpp:			if ( m_flDigestFinish > gpGlobals->curtime )
game/server/hl2/npc_barnacle.cpp:			SetNextThink( gpGlobals->curtime + random->RandomFloat(1,1.5) );	// Stagger a bit to keep barnacles from thinking on the same frame
game/server/hl2/npc_barnacle.cpp:			float dt = gpGlobals->curtime - GetLastThink();
game/server/hl2/npc_barnacle.cpp:	float dt = gpGlobals->curtime - GetLastThink();
game/server/hl2/npc_barnacle.cpp:		m_flDigestFinish = gpGlobals->curtime + 10.0;
game/server/hl2/npc_barnacle.cpp:		m_flDigestFinish = gpGlobals->curtime + 10.0;
game/server/hl2/npc_barnacle.cpp:	if ( gpGlobals->curtime < m_flNextBloodTime )
game/server/hl2/npc_barnacle.cpp:	m_flNextBloodTime = gpGlobals->curtime + 0.2f;
game/server/hl2/npc_barnacle.cpp:		m_flDigestFinish = ( gpGlobals->curtime + m_bSwallowingPoison ) ? 0.48f : 10.0f;
game/server/hl2/npc_barnacle.cpp:		m_flDigestFinish = gpGlobals->curtime + 10.0;
game/server/hl2/npc_barnacle.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_barnacle.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_barnacle.cpp:		float dt = gpGlobals->curtime - GetLastThink();
game/server/hl2/func_tank.cpp:	float flTimeDelay = gpGlobals->curtime - m_lastSightTime;
game/server/hl2/func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.1f ); 
game/server/hl2/func_tank.cpp:	m_fireLast = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	m_flStartLeadFactorTime = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	m_flNextLeadFactorTime = gpGlobals->curtime + 1.0f;
game/server/hl2/func_tank.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/func_tank.cpp:		m_flNextControllerSearch = gpGlobals->curtime + 1.0f;
game/server/hl2/func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/func_tank.cpp:		m_flNextControllerSearch = gpGlobals->curtime + 1.0f;
game/server/hl2/func_tank.cpp:		m_flNextControllerSearch = gpGlobals->curtime + 5.0f;
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl2/func_tank.cpp:	m_fireLast = gpGlobals->curtime - (1/m_fireRate) - 0.01;  // to make sure the gun doesn't fire too many bullets
game/server/hl2/func_tank.cpp:	int bulletCount = (gpGlobals->curtime - m_fireLast) * m_fireRate;
game/server/hl2/func_tank.cpp:	SetNextAttack( gpGlobals->curtime + (1/m_fireRate) );
game/server/hl2/func_tank.cpp:	SetNextAttack( gpGlobals->curtime + m_flPlayerLockTimeBeforeFire );
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl2/func_tank.cpp://		m_fireLast = gpGlobals->curtime - (1/m_fireRate) - 0.01;  // to make sure the gun doesn't fire too many bullets		
game/server/hl2/func_tank.cpp:		SetNextAttack( gpGlobals->curtime + flFireTime );
game/server/hl2/func_tank.cpp:		SetNextAttack( gpGlobals->curtime + m_fireTime );
game/server/hl2/func_tank.cpp:	m_flNextControllerSearch = gpGlobals->curtime + 5.0f;
game/server/hl2/func_tank.cpp:	if ( IsControllable() && !HasController() && (m_flNextControllerSearch <= gpGlobals->curtime) )
game/server/hl2/func_tank.cpp:		if ( m_bShouldFindNPCs && gpGlobals->curtime > 5.0f )
game/server/hl2/func_tank.cpp:				SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/func_tank.cpp:				SetNextThink( gpGlobals->curtime + 2.0f );
game/server/hl2/func_tank.cpp:			m_flNextControllerSearch = gpGlobals->curtime + 0.1f;
game/server/hl2/func_tank.cpp:			m_flNextControllerSearch = gpGlobals->curtime + 2.0f;
game/server/hl2/func_tank.cpp:			SetNextThink( gpGlobals->curtime + 2.0f );
game/server/hl2/func_tank.cpp:		m_flNextControllerSearch = gpGlobals->curtime + 2.0f;
game/server/hl2/func_tank.cpp:	if ( m_flNextLeadFactorTime < gpGlobals->curtime )
game/server/hl2/func_tank.cpp:		m_flStartLeadFactorTime = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:		m_flNextLeadFactorTime = gpGlobals->curtime + random->RandomFloat( 2.0f, 4.0f );
game/server/hl2/func_tank.cpp:	float flFactor = (gpGlobals->curtime - m_flStartLeadFactorTime) / (m_flNextLeadFactorTime - m_flStartLeadFactorTime);
game/server/hl2/func_tank.cpp:		if( (gpGlobals->curtime - m_lastSightTime >= 1.0) && (gpGlobals->curtime > m_flNextAttack) )
game/server/hl2/func_tank.cpp:			m_flNextAttack = gpGlobals->curtime + 0.5;
game/server/hl2/func_tank.cpp:		m_lastSightTime = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	if( !m_bReadyToFire && m_flNextAttack <= gpGlobals->curtime )
game/server/hl2/func_tank.cpp:		SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/func_tank.cpp:		SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/func_tank.cpp:		int bulletCount = (gpGlobals->curtime - m_fireLast) * m_fireRate;
game/server/hl2/func_tank.cpp:			m_fireLast = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:		m_fireLast = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	if ( m_flPlayerGracePeriod && pEntity->IsPlayer() && (gpGlobals->curtime - m_flLastSawNonPlayer) < m_flPlayerGracePeriod )
game/server/hl2/func_tank.cpp:		m_flLastSawNonPlayer = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	if ( m_pLaser && (gpGlobals->curtime > m_laserTime) )
game/server/hl2/func_tank.cpp:			m_laserTime = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:			m_pLaser->SetFireTime( gpGlobals->curtime - 1.0 );
game/server/hl2/func_tank.cpp:	pRocket->SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime >= m_flNextHeavyShotTime )
game/server/hl2/func_tank.cpp:	if ( m_flLastImpactEffectTime == gpGlobals->curtime )
game/server/hl2/func_tank.cpp:	m_flLastImpactEffectTime = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime >= m_flNextHeavyShotTime )
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime >= m_flNextHeavyShotTime )
game/server/hl2/func_tank.cpp:		m_flNextHeavyShotTime = gpGlobals->curtime + AIRBOAT_GUN_HEAVY_SHOT_INTERVAL; 
game/server/hl2/func_tank.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl2/func_tank.cpp:		SetNextAttack( gpGlobals->curtime + (1.0f / m_fireRate ) );
game/server/hl2/func_tank.cpp:	pShell->m_flImpactTime = gpGlobals->curtime + flImpactDelay;
game/server/hl2/func_tank.cpp:	m_flSpawnedTime = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime > m_flNPCWarnTime )
game/server/hl2/func_tank.cpp:	float lifePerc = 1.0f - ( ( m_flImpactTime - gpGlobals->curtime ) / ( m_flImpactTime - m_flSpawnedTime ) );
game/server/hl2/func_tank.cpp:	if( !m_bHasWarned && gpGlobals->curtime > m_flWarnTime )
game/server/hl2/func_tank.cpp:	if( gpGlobals->curtime > m_flImpactTime )
game/server/hl2/func_tank.cpp:	m_flFadeTime = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/func_tank.cpp:	float lifePerc = 1.0f - ( ( gpGlobals->curtime - m_flFadeTime  ) / MORTAR_FADE_LENGTH );
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime > ( m_flFadeTime + MORTAR_FADE_LENGTH ) )
game/server/hl2/func_tank.cpp:	SetNextAttack( gpGlobals->curtime );
game/server/hl2/func_tank.cpp:	if ( gpGlobals->curtime > GetNextAttack() )
game/server/hl2/func_tank.cpp:		m_fireLast = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:		SetNextAttack( gpGlobals->curtime + (1.0 / m_fireRate ) );
game/server/hl2/func_tank.cpp:		m_fireLast = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	m_flTimeBeamOn = gpGlobals->curtime;
game/server/hl2/func_tank.cpp:	if (!m_hBeam && gpGlobals->curtime >= m_flTimeBeamOn )
game/server/hl2/func_tank.cpp:		SetContextThink( &CFuncTankCombineCannon::UpdateBeamThink, gpGlobals->curtime, s_pUpdateBeamThinkContext );
game/server/hl2/func_tank.cpp:			SetNextAttack( gpGlobals->curtime );
game/server/hl2/func_tank.cpp:	SetContextThink( &CFuncTankCombineCannon::UpdateBeamThink, gpGlobals->curtime + 0.025, s_pUpdateBeamThinkContext );
game/server/hl2/func_tank.cpp:		if( gpGlobals->curtime > m_flTimeNextSweep )
game/server/hl2/func_tank.cpp:				m_flTimeNextSweep = gpGlobals->curtime + random->RandomFloat( 0.25f, 0.75f );
game/server/hl2/func_tank.cpp:				m_flTimeNextSweep = gpGlobals->curtime + random->RandomFloat( 1, 3 );
game/server/hl2/func_tank.cpp:	m_flTimeBeamOn = gpGlobals->curtime + 0.2f;
game/server/hl2/func_tank.cpp:	m_flTimeNextSweep = gpGlobals->curtime + random->RandomInt( 1.0f, 2.0f );
game/server/hl2/func_tank.cpp:	m_flTimeBeamOn = gpGlobals->curtime + 1.0f;
game/server/hl2/vehicle_airboat.cpp:	//m_flHandbrakeTime = gpGlobals->curtime + 0.1;
game/server/hl2/vehicle_airboat.cpp:	m_flEngineIdleTime = gpGlobals->curtime + flDuration - 0.1;
game/server/hl2/vehicle_airboat.cpp:	if ( m_flLastImpactEffectTime >= gpGlobals->curtime )
game/server/hl2/vehicle_airboat.cpp:	m_flLastImpactEffectTime = gpGlobals->curtime + 0.05f;
game/server/hl2/vehicle_airboat.cpp:	if ( m_flLastImpactEffectTime == gpGlobals->curtime )
game/server/hl2/vehicle_airboat.cpp:	m_flLastImpactEffectTime = gpGlobals->curtime;
game/server/hl2/vehicle_airboat.cpp:	float flChargeAmount = flRechargeRate * gpGlobals->frametime;
game/server/hl2/vehicle_airboat.cpp://	if ( gpGlobals->curtime < m_flHandbrakeTime )
game/server/hl2/vehicle_airboat.cpp://		SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_airboat.cpp:		AimGunAt( vecAimPoint, gpGlobals->frametime );
game/server/hl2/vehicle_airboat.cpp:			m_flSpinRate += gpGlobals->frametime * 1.0;
game/server/hl2/vehicle_airboat.cpp:			m_flSpinRate += gpGlobals->frametime * 0.4;
game/server/hl2/vehicle_airboat.cpp:		m_flSpinRate -= gpGlobals->frametime * 0.4;
game/server/hl2/vehicle_airboat.cpp:		if ( gpGlobals->curtime > m_flEngineIdleTime )
game/server/hl2/vehicle_airboat.cpp:			m_flEngineDuckTime = gpGlobals->curtime + ENGINE_DUCK_TIME;
game/server/hl2/vehicle_airboat.cpp:	else if ( gpGlobals->curtime > m_flEngineDuckTime )
game/server/hl2/vehicle_airboat.cpp:				m_flWaterStoppedPitchTime = gpGlobals->curtime + random->RandomFloat(1.0, 3.0);
game/server/hl2/vehicle_airboat.cpp:			else if (gpGlobals->curtime > m_flWaterStoppedPitchTime)
game/server/hl2/vehicle_airboat.cpp:				m_flWaterStoppedPitchTime = gpGlobals->curtime + random->RandomFloat(2.0, 4.0);
game/server/hl2/vehicle_airboat.cpp:	if ( gpGlobals->curtime >= m_flNextHeavyShotTime )
game/server/hl2/vehicle_airboat.cpp:	if ( gpGlobals->curtime >= m_flNextHeavyShotTime )
game/server/hl2/vehicle_airboat.cpp:	if ( gpGlobals->curtime >= m_flNextHeavyShotTime )
game/server/hl2/vehicle_airboat.cpp:		m_flNextHeavyShotTime = gpGlobals->curtime + CANNON_HEAVY_SHOT_INTERVAL; 
game/server/hl2/vehicle_airboat.cpp:	if ( gpGlobals->curtime >= m_flNextGunShakeTime )
game/server/hl2/vehicle_airboat.cpp:		m_flNextGunShakeTime = gpGlobals->curtime + 0.5 * CANNON_SHAKE_INTERVAL; 
game/server/hl2/vehicle_airboat.cpp:	if ( gpGlobals->frametime != 0 )
game/server/hl2/vehicle_airboat.cpp:	float flFrameTime = gpGlobals->frametime;
game/server/hl2/vehicle_airboat.cpp:		dmgInfo.SetDamageForce( Vector( 0, 0, -stressOut.receivedStress * GetCurrentGravity() * gpGlobals->frametime ) );
game/server/hl2/npc_attackchopper.cpp:	m_flInputDropBombTime = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:		SetContextThink( &CNPC_AttackHelicopter::BlinkLightsThink, gpGlobals->curtime + CHOPPER_LIGHT_BLINK_TIME_SHORT, s_pBlinkLightThinkContext );
game/server/hl2/npc_attackchopper.cpp:	SetContextThink( &CNPC_AttackHelicopter::BlinkLightsThink, gpGlobals->curtime + flTime, s_pBlinkLightThinkContext );
game/server/hl2/npc_attackchopper.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pSpotlightThinkContext );
game/server/hl2/npc_attackchopper.cpp:	SetContextThink( &CNPC_AttackHelicopter::SpotlightThink, gpGlobals->curtime + TICK_INTERVAL, s_pSpotlightThinkContext );
game/server/hl2/npc_attackchopper.cpp:		m_flNextAttack = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:		m_flChargeTime = gpGlobals->curtime + CHOPPER_GUN_CHARGE_TIME;
game/server/hl2/npc_attackchopper.cpp:	if (m_flNextAttack > gpGlobals->curtime)
game/server/hl2/npc_attackchopper.cpp:		m_flChargeTime = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:		m_flChargeTime = gpGlobals->curtime + random->RandomFloat(flChargeTime - flVariance, flChargeTime + flVariance);
game/server/hl2/npc_attackchopper.cpp:	if ( m_flChargeTime > gpGlobals->curtime )
game/server/hl2/npc_attackchopper.cpp:	if ( m_flNextAttack > gpGlobals->curtime )
game/server/hl2/npc_attackchopper.cpp:	m_flNextAttack = gpGlobals->curtime + random->RandomFloat( 0.3f, 1.0f );
game/server/hl2/npc_attackchopper.cpp:	m_flNextAttack = gpGlobals->curtime + m_flIdleTimeDelay + random->RandomFloat(flIdleTime - flVariance, flIdleTime + flVariance);
game/server/hl2/npc_attackchopper.cpp:	if ( m_flInputDropBombTime > gpGlobals->curtime )
game/server/hl2/npc_attackchopper.cpp:	m_flInputDropBombTime = gpGlobals->curtime + 0.01f;
game/server/hl2/npc_attackchopper.cpp:		m_flNextAttack = gpGlobals->curtime + 0.5f + random->RandomFloat( 0.3f, 0.6f );
game/server/hl2/npc_attackchopper.cpp:	if ( m_flInputDropBombTime > gpGlobals->curtime )
game/server/hl2/npc_attackchopper.cpp:	m_flInputDropBombTime = gpGlobals->curtime + 0.01f;
game/server/hl2/npc_attackchopper.cpp:		m_flNextAttack = gpGlobals->curtime + 0.5f + random->RandomFloat( 0.3f, 0.6f );
game/server/hl2/npc_attackchopper.cpp:	if ( m_flInputDropBombTime > gpGlobals->curtime )
game/server/hl2/npc_attackchopper.cpp:	m_flInputDropBombTime = gpGlobals->curtime + 0.01f;
game/server/hl2/npc_attackchopper.cpp:		m_flNextAttack = gpGlobals->curtime + 1.5f + random->RandomFloat( 0.1f, 0.2f );
game/server/hl2/npc_attackchopper.cpp:	m_flInputDropBombTime = gpGlobals->curtime + inputdata.value.Float();
game/server/hl2/npc_attackchopper.cpp:	if (m_flNextAttack > gpGlobals->curtime)
game/server/hl2/npc_attackchopper.cpp:	m_flNextAttack = gpGlobals->curtime + 0.5f + random->RandomFloat( 0.3f, 0.6f );
game/server/hl2/npc_attackchopper.cpp:		m_flLastFastTime = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:		if ( ( gpGlobals->curtime - m_flLastFastTime ) < BOMB_GRACE_PERIOD )
game/server/hl2/npc_attackchopper.cpp:	if ( gpGlobals->curtime < m_flNextBullrushBombTime )
game/server/hl2/npc_attackchopper.cpp:	m_flNextBullrushBombTime = gpGlobals->curtime + 0.2f;
game/server/hl2/npc_attackchopper.cpp:		if ( (m_flLastSeen + 1 <= gpGlobals->curtime) || (m_flPrevSeen + m_flGracePeriod > gpGlobals->curtime) )
game/server/hl2/npc_attackchopper.cpp:	if ( m_flLastCorpseFall > gpGlobals->curtime )
game/server/hl2/npc_attackchopper.cpp:	m_flLastCorpseFall = gpGlobals->curtime + 3.0;
game/server/hl2/npc_attackchopper.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_attackchopper.cpp:	SetStartupTime( gpGlobals->curtime + 99.0f );
game/server/hl2/npc_attackchopper.cpp:		flNewPathOffset += flSinHeight * sin( 2.0f * M_PI * (gpGlobals->curtime / 6.0f) );
game/server/hl2/npc_attackchopper.cpp:	float flMaxChange = 1000.0f * (gpGlobals->curtime - GetLastThink());
game/server/hl2/npc_attackchopper.cpp:	bool bSeenTargetRecently = HasSpawnFlags( SF_HELICOPTER_AGGRESSIVE ) || ( m_flLastSeen + 5 > gpGlobals->curtime ); 
game/server/hl2/npc_attackchopper.cpp:	float dt = gpGlobals->curtime - GetLastThink();
game/server/hl2/npc_attackchopper.cpp:		m_flSecondaryModeStartTime = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:	return gpGlobals->curtime - m_flSecondaryModeStartTime;
game/server/hl2/npc_attackchopper.cpp:	m_flNextAttack = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:	m_flNextAttack = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:				m_flSecondaryModeStartTime = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:				m_flNextBullrushBombTime = gpGlobals->curtime;
game/server/hl2/npc_attackchopper.cpp:		SetContextThink( &CGrenadeHelicopter::AnimateThink, gpGlobals->curtime, s_pAnimateThinkContext );
game/server/hl2/npc_attackchopper.cpp:			SetNextThink( gpGlobals->curtime + GetBombLifetime() );
game/server/hl2/npc_attackchopper.cpp:		SetNextThink( gpGlobals->curtime + GetBombLifetime() );
game/server/hl2/npc_attackchopper.cpp:		SetContextThink( &CGrenadeHelicopter::RampSoundThink, gpGlobals->curtime + GetBombLifetime() - BOMB_RAMP_SOUND_TIME, s_pRampSoundContext );
game/server/hl2/npc_attackchopper.cpp:	SetContextThink( &CGrenadeHelicopter::WarningBlinkerThink, gpGlobals->curtime + (GetBombLifetime() - 2.0f), s_pWarningBlinkerContext );
game/server/hl2/npc_attackchopper.cpp:	m_flBlinkFastTime = gpGlobals->curtime + GetBombLifetime() - 1.0f;
game/server/hl2/npc_attackchopper.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pRampSoundContext );
game/server/hl2/npc_attackchopper.cpp:	if( gpGlobals->curtime >= m_flBlinkFastTime )
game/server/hl2/npc_attackchopper.cpp:		SetContextThink( &CGrenadeHelicopter::WarningBlinkerThink, gpGlobals->curtime + 0.1f, s_pWarningBlinkerContext );
game/server/hl2/npc_attackchopper.cpp:		SetContextThink( &CGrenadeHelicopter::WarningBlinkerThink, gpGlobals->curtime + 0.2f, s_pWarningBlinkerContext );
game/server/hl2/npc_attackchopper.cpp:	SetContextThink( &CGrenadeHelicopter::AnimateThink, gpGlobals->curtime + 0.1f, s_pAnimateThinkContext );
game/server/hl2/npc_attackchopper.cpp:			SetContextThink( &CGrenadeHelicopter::RampSoundThink, gpGlobals->curtime + GetBombLifetime() - BOMB_RAMP_SOUND_TIME, s_pRampSoundContext );
game/server/hl2/npc_attackchopper.cpp:			SetNextThink( gpGlobals->curtime + GetBombLifetime() );
game/server/hl2/npc_attackchopper.cpp:			SetContextThink( &CGrenadeHelicopter::WarningBlinkerThink, gpGlobals->curtime + GetBombLifetime() - 2.0f, s_pWarningBlinkerContext );
game/server/hl2/npc_attackchopper.cpp:			m_flBlinkFastTime = gpGlobals->curtime + GetBombLifetime() - 1.0f;
game/server/hl2/npc_attackchopper.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_attackchopper.cpp:	pChunk->SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_vortigaunt_episodic.cpp:				 m_flAimDelay < gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( m_flDispelTestTime > gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:	m_flDispelTestTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_vortigaunt_episodic.cpp:			m_flDispelTestTime = gpGlobals->curtime + 15.0f;
game/server/hl2/npc_vortigaunt_episodic.cpp:		if ( m_fGlowChangeTime > gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:		m_flAimDelay = gpGlobals->curtime + 0.75f;
game/server/hl2/npc_vortigaunt_episodic.cpp:		m_flNextAttack = gpGlobals->curtime + random->RandomFloat( 2.0f, 3.0f );
game/server/hl2/npc_vortigaunt_episodic.cpp:		if ( m_fGlowChangeTime > gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:		m_flBlueEndFadeTime = gpGlobals->curtime + VORTIGAUNT_BLUE_FADE_TIME;
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( gpGlobals->curtime < m_flPainTime )
game/server/hl2/npc_vortigaunt_episodic.cpp:	m_flPainTime = gpGlobals->curtime + random->RandomFloat(0.5, 0.75);
game/server/hl2/npc_vortigaunt_episodic.cpp:		if ( ( GetNextAttack() > gpGlobals->curtime ) && HasCondition( COND_ENEMY_TOO_FAR ) == false )
game/server/hl2/npc_vortigaunt_episodic.cpp:	m_fGlowChangeTime = gpGlobals->curtime + 0.1f;	// No more glows for this amount of time!
game/server/hl2/npc_vortigaunt_episodic.cpp:		m_flNextHealTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_vortigaunt_episodic.cpp:		m_flNextHealTime = gpGlobals->curtime + VORTIGAUNT_HEAL_RECHARGE;
game/server/hl2/npc_vortigaunt_episodic.cpp:	SetNextAttack( gpGlobals->curtime + 2.0f );
game/server/hl2/npc_vortigaunt_episodic.cpp:	GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + 0.5f );
game/server/hl2/npc_vortigaunt_episodic.cpp:			if ( m_flNextHealTokenTime < gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:				m_flNextHealTokenTime = gpGlobals->curtime + random->RandomFloat( 0.5f, 1.0f );
game/server/hl2/npc_vortigaunt_episodic.cpp:					m_flNextHealTokenTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_vortigaunt_episodic.cpp:			m_flHealHinderedTime += gpGlobals->curtime - GetLastThink();
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( m_fGlowChangeTime > gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( GetEnemy() == NULL && m_flAimDelay > gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:			CRagdollBoogie::Create( pTest, 200, gpGlobals->curtime, 1.0f );
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( HealBehaviorAvailable() && ( m_flNextHealTime < gpGlobals->curtime ) )
game/server/hl2/npc_vortigaunt_episodic.cpp:		m_flNextHealTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( m_flAimDelay >= gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:	m_fGlowChangeTime = gpGlobals->curtime + 0.1f;	// No more glows for this amount of time!
game/server/hl2/npc_vortigaunt_episodic.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_vortigaunt_episodic.cpp:	m_flLifetime = gpGlobals->curtime + VORTIGAUNT_CURE_LIFESPAN;
game/server/hl2/npc_vortigaunt_episodic.cpp:	if ( m_hTarget == NULL || m_flLifetime < gpGlobals->curtime )
game/server/hl2/npc_vortigaunt_episodic.cpp:	float flDelta = gpGlobals->curtime - GetLastThink();
game/server/hl2/npc_vortigaunt_episodic.cpp:	vecOffset += vecUp * cos( gpGlobals->curtime * 20.0f ) * 200.0f * gpGlobals->frametime;
game/server/hl2/npc_vortigaunt_episodic.cpp:	vecOffset += vecRight * sin( gpGlobals->curtime * 15.0f ) * 200.0f * gpGlobals->frametime;
game/server/hl2/npc_vortigaunt_episodic.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_vortigaunt_episodic.cpp:	SetNextThink( gpGlobals->curtime + 2.0f );
game/server/hl2/npc_vortigaunt_episodic.cpp:	SetNextThink( gpGlobals->curtime + 2.0f );
game/server/hl2/grenade_homer.cpp:	m_flHomingLaunchTime	= gpGlobals->curtime;
game/server/hl2/grenade_homer.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/grenade_homer.cpp:	if (gpGlobals->curtime > m_flNextFlySoundTime)
game/server/hl2/grenade_homer.cpp:		m_flNextFlySoundTime	= gpGlobals->curtime + 1.0;
game/server/hl2/grenade_homer.cpp:		gpGlobals->curtime > m_flDetonateTime)
game/server/hl2/grenade_homer.cpp:		if		(gpGlobals->curtime < flHomingRampUpStartTime)
game/server/hl2/grenade_homer.cpp:		else if (gpGlobals->curtime < flHomingSustainStartTime)
game/server/hl2/grenade_homer.cpp:			float flAge			= gpGlobals->curtime - flHomingRampUpStartTime;
game/server/hl2/grenade_homer.cpp:		else if (gpGlobals->curtime < flHomingRampDownStartTime)
game/server/hl2/grenade_homer.cpp:		else if (gpGlobals->curtime < flHomingEndHomingTime)
game/server/hl2/grenade_homer.cpp:			float flAge			= gpGlobals->curtime - flHomingRampDownStartTime;
game/server/hl2/grenade_homer.cpp:			float flTimeToUse = gpGlobals->frametime;
game/server/hl2/grenade_homer.cpp:		vecImpulse.x += m_flSpinMagnitude*sin(m_flSpinSpeed * gpGlobals->curtime + m_flSpinOffset);
game/server/hl2/grenade_homer.cpp:		vecImpulse.y += m_flSpinMagnitude*cos(m_flSpinSpeed * gpGlobals->curtime + m_flSpinOffset);
game/server/hl2/grenade_homer.cpp:		vecImpulse.z -= m_flSpinMagnitude*cos(m_flSpinSpeed * gpGlobals->curtime + m_flSpinOffset);
game/server/hl2/grenade_homer.cpp:	vecImpulse.z -= GetGravity() * GetCurrentGravity() * gpGlobals->frametime;
game/server/hl2/grenade_homer.cpp:	if( gpGlobals->curtime > m_flNextWarnTime )
game/server/hl2/grenade_homer.cpp:		m_flNextWarnTime = gpGlobals->curtime + WARN_INTERVAL;
game/server/hl2/grenade_homer.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_satchel.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_satchel.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/grenade_satchel.cpp:				m_pMyWeaponSLAM->SetWeaponIdleTime( gpGlobals->curtime );
game/server/hl2/grenade_satchel.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_satchel.cpp:	if (gpGlobals->curtime > m_flNextBounceSoundTime)
game/server/hl2/grenade_satchel.cpp:		m_flNextBounceSoundTime = gpGlobals->curtime + 0.1;
game/server/hl2/npc_antlionguard.cpp:	if ( !bIgnoreTime && m_flNextSummonTime > gpGlobals->curtime )
game/server/hl2/npc_antlionguard.cpp:		if ( m_flNextRoarTime < gpGlobals->curtime )
game/server/hl2/npc_antlionguard.cpp:			m_flNextRoarTime = gpGlobals->curtime + RandomFloat( 20,40 );
game/server/hl2/npc_antlionguard.cpp:		if ( useTime && ( m_flChargeTime > gpGlobals->curtime ) )
game/server/hl2/npc_antlionguard.cpp:		m_flChargeTime = gpGlobals->curtime + 4.0f;
game/server/hl2/npc_antlionguard.cpp:	if ( !m_bInCavern && HasCondition( COND_HEAVY_DAMAGE ) && m_flNextHeavyFlinchTime < gpGlobals->curtime )
game/server/hl2/npc_antlionguard.cpp:		m_flNextHeavyFlinchTime = gpGlobals->curtime + 8.0f;
game/server/hl2/npc_antlionguard.cpp:	if ( GetNextAttack() > gpGlobals->curtime )
game/server/hl2/npc_antlionguard.cpp:	if ( GetNextAttack() > gpGlobals->curtime )
game/server/hl2/npc_antlionguard.cpp:		m_flAngerNoiseTime = gpGlobals->curtime + duration + random->RandomFloat( 2.0f, 4.0f );
game/server/hl2/npc_antlionguard.cpp:		m_flBreathTime = gpGlobals->curtime + duration - 0.2f;
game/server/hl2/npc_antlionguard.cpp:		m_flAngerNoiseTime = gpGlobals->curtime + duration + random->RandomFloat( 2.0f, 4.0f );
game/server/hl2/npc_antlionguard.cpp:		m_flBreathTime = gpGlobals->curtime + duration - 0.2f;
game/server/hl2/npc_antlionguard.cpp:		m_flAngerNoiseTime = gpGlobals->curtime + duration + random->RandomFloat( 2.0f, 4.0f );
game/server/hl2/npc_antlionguard.cpp:		m_flBreathTime = gpGlobals->curtime + duration - 0.2f;
game/server/hl2/npc_antlionguard.cpp:		m_flBreathTime = gpGlobals->curtime + duration - 0.2f;
game/server/hl2/npc_antlionguard.cpp:		m_flBreathTime = gpGlobals->curtime + ( duration * 0.5f );
game/server/hl2/npc_antlionguard.cpp:		m_flBreathTime = gpGlobals->curtime + duration;
game/server/hl2/npc_antlionguard.cpp:		m_flBreathTime = gpGlobals->curtime + duration;
game/server/hl2/npc_antlionguard.cpp:				if ( gpGlobals->curtime > 0.5f )
game/server/hl2/npc_antlionguard.cpp:				pParticle->SetNextThink( gpGlobals->curtime + random->RandomFloat( 2.0f, 3.0f ) );
game/server/hl2/npc_antlionguard.cpp:			m_flWaitFinished = gpGlobals->curtime + 30.0f;
game/server/hl2/npc_antlionguard.cpp:	if ( IRelationType( pEntity ) == D_HT && ( GetNextAttack() < gpGlobals->curtime ) )
game/server/hl2/npc_antlionguard.cpp:		SetNextAttack( gpGlobals->curtime + 2.0f );
game/server/hl2/npc_antlionguard.cpp:					SetNextAttack( gpGlobals->curtime + 2.0f );
game/server/hl2/npc_antlionguard.cpp:		m_flNextSummonTime = gpGlobals->curtime + RandomFloat( 15,20 );
game/server/hl2/npc_antlionguard.cpp:		m_flNextSummonTime = gpGlobals->curtime + RandomFloat( 10,15 );
game/server/hl2/npc_antlionguard.cpp:	m_flAngerNoiseTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_antlionguard.cpp:	m_flSearchNoiseTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_antlionguard.cpp:	if ( m_flPhysicsCheckTime > gpGlobals->curtime )
game/server/hl2/npc_antlionguard.cpp:	m_flPhysicsCheckTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_antlionguard.cpp:			m_flBreathTime = gpGlobals->curtime + duration - (duration*0.75f);
game/server/hl2/npc_antlionguard.cpp:		if ( m_flBreathTime < gpGlobals->curtime )
game/server/hl2/npc_antlionguard.cpp:			m_flBreathTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 8.0f );
game/server/hl2/npc_antlionguard.cpp:		if( gpGlobals->curtime > m_flWaitFinished )
game/server/hl2/npc_antlionguard.cpp:			if ( gpGlobals->curtime > m_UnreachableEnts[i].fExpireTime ||
game/server/hl2/npc_fastzombie.cpp:	if ( m_flNextMeleeAttack > gpGlobals->curtime + 1 )
game/server/hl2/npc_fastzombie.cpp:		m_flNextMeleeAttack = gpGlobals->curtime + 0.5;
game/server/hl2/npc_fastzombie.cpp: 	if( m_pMoanSound && gpGlobals->curtime > m_flTimeUpdateSound )
game/server/hl2/npc_fastzombie.cpp:		m_flTimeUpdateSound = gpGlobals->curtime + FASTZOMBIE_SOUND_UPDATE_FREQ;
game/server/hl2/npc_fastzombie.cpp:		SetNextThink(gpGlobals->curtime);
game/server/hl2/npc_fastzombie.cpp:	m_flNextAttack = gpGlobals->curtime;
game/server/hl2/npc_fastzombie.cpp:	m_flTimeUpdateSound = gpGlobals->curtime;
game/server/hl2/npc_fastzombie.cpp:	if( gpGlobals->curtime < m_flNextMeleeAttack )
game/server/hl2/npc_fastzombie.cpp:	if( gpGlobals->curtime < m_flNextAttack )
game/server/hl2/npc_fastzombie.cpp:		m_flNextAttack = gpGlobals->curtime + 2;
game/server/hl2/npc_fastzombie.cpp:		m_flNextMeleeAttack = gpGlobals->curtime + 60;
game/server/hl2/npc_fastzombie.cpp:			m_flNextMeleeAttack = gpGlobals->curtime + 0.5;
game/server/hl2/npc_fastzombie.cpp:		m_flNextAttack = gpGlobals->curtime + 1.0;
game/server/hl2/npc_fastzombie.cpp:	m_flNextAttack = gpGlobals->curtime + 2.0f;
game/server/hl2/grenade_spit.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_spit.cpp:		if ( gpGlobals->curtime > 0.5f )
game/server/hl2/grenade_spit.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/grenade_pathfollower.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_pathfollower.cpp:	if (gpGlobals->curtime > m_flNextFlySoundTime)
game/server/hl2/grenade_pathfollower.cpp:		m_flNextFlySoundTime	= gpGlobals->curtime + 1.0;
game/server/hl2/grenade_pathfollower.cpp:		float flTimeToUse = gpGlobals->frametime;
game/server/hl2/grenade_pathfollower.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/weapon_bugbait2.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/hl2/weapon_bugbait2.cpp:	SetNextThink(gpGlobals->curtime + 3.0);
game/server/hl2/weapon_bugbait2.cpp:	//m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_bugbait2.cpp:	if ((m_bRedraw) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_bugbait2.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_bugbait2.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_bugbait2.cpp:		if ((pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack < gpGlobals->curtime))
game/server/hl2/weapon_bugbait2.cpp:		else if ((pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack < gpGlobals->curtime))
game/server/hl2/env_headcrabcanister.cpp:			m_Shared.InitInWorld( gpGlobals->curtime, pLaunchPos->GetAbsOrigin(), GetAbsAngles(), 
game/server/hl2/env_headcrabcanister.cpp:			SetNextThink( gpGlobals->curtime );
game/server/hl2/env_headcrabcanister.cpp:		m_Shared.InitInSkybox( gpGlobals->curtime, m_vecImpactPosition, GetAbsAngles(), vecForward, 
game/server/hl2/env_headcrabcanister.cpp:		SetNextThink( gpGlobals->curtime + m_Shared.GetEnterWorldTime() + TICK_INTERVAL );
game/server/hl2/env_headcrabcanister.cpp:			m_Shared.InitInSkybox( gpGlobals->curtime, vecStartPosition, vecStartAngles, vecDirection, 
game/server/hl2/env_headcrabcanister.cpp:				SetNextThink( gpGlobals->curtime + m_Shared.GetEnterWorldTime() );
game/server/hl2/env_headcrabcanister.cpp:				SetNextThink( gpGlobals->curtime );
game/server/hl2/env_headcrabcanister.cpp:			m_Shared.InitInWorld( gpGlobals->curtime, vecStartPosition, vecStartAngles, 
game/server/hl2/env_headcrabcanister.cpp:			SetNextThink( gpGlobals->curtime );
game/server/hl2/env_headcrabcanister.cpp:	m_Shared.GetPositionAtTime( gpGlobals->curtime, vecEndPosition, vecEndAngles );
game/server/hl2/env_headcrabcanister.cpp:		SetContextThink( &CEnvHeadcrabCanister::HeadcrabCanisterSpawnHeadcrabThink, gpGlobals->curtime + flWaitTime, s_pHeadcrabThinkContext );
game/server/hl2/env_headcrabcanister.cpp:		SetContextThink( NULL, gpGlobals->curtime, s_pHeadcrabThinkContext );
game/server/hl2/env_headcrabcanister.cpp:		SetContextThink( &CEnvHeadcrabCanister::HeadcrabCanisterSpawnHeadcrabThink, gpGlobals->curtime + flDelay, s_pHeadcrabThinkContext );
game/server/hl2/env_headcrabcanister.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pOpenThinkContext );
game/server/hl2/env_headcrabcanister.cpp:		SetContextThink( &CEnvHeadcrabCanister::WaitForOpenSequenceThink, gpGlobals->curtime + 0.01f, s_pOpenThinkContext );
game/server/hl2/env_headcrabcanister.cpp:		SetContextThink( &CEnvHeadcrabCanister::WaitForOpenSequenceThink, gpGlobals->curtime + 0.01f, s_pOpenThinkContext );
game/server/hl2/env_headcrabcanister.cpp:		SetNextThink( gpGlobals->curtime + ENV_HEADCRABCANISTER_TRAIL_TIME );
game/server/hl2/env_headcrabcanister.cpp:	float flTime = gpGlobals->curtime;
game/server/hl2/env_headcrabcanister.cpp:	SetNextThink( gpGlobals->curtime + 0.2f );
game/server/hl2/env_headcrabcanister.cpp:	m_Shared.GetPositionAtTime( gpGlobals->curtime, vecEndPosition, vecEndAngles );
game/server/hl2/env_headcrabcanister.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/hl2/env_headcrabcanister.cpp:	m_Shared.GetPositionAtTime( gpGlobals->curtime, vecEndPosition, vecEndAngles );
game/server/hl2/env_headcrabcanister.cpp:	SetNextThink( gpGlobals->curtime + flRefireTime );
game/server/hl2/cbasehelicopter.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/cbasehelicopter.cpp:	SetNextThink( gpGlobals->curtime + HELICOPTER_THINK_INTERVAL );
game/server/hl2/cbasehelicopter.cpp:		SetNextThink( gpGlobals->curtime + HELICOPTER_THINK_INTERVAL );
game/server/hl2/cbasehelicopter.cpp:		SetContextThink( &CBaseHelicopter::RotorWashThink, gpGlobals->curtime + HELICOPTER_ROTORWASH_THINK_INTERVAL, s_pRotorWashThinkContext );
game/server/hl2/cbasehelicopter.cpp:		SetContextThink( NULL, gpGlobals->curtime, s_pRotorWashThinkContext );
game/server/hl2/cbasehelicopter.cpp:	if ( m_flRotorWashEntitySearchTime > gpGlobals->curtime )
game/server/hl2/cbasehelicopter.cpp:	m_flRotorWashEntitySearchTime = gpGlobals->curtime + 0.5f;
game/server/hl2/cbasehelicopter.cpp:	float flPushTime = (gpGlobals->curtime - pWash->flWashStartTime);
game/server/hl2/cbasehelicopter.cpp:			BASECHOPPER_WASH_PUSH_MIN * flMass, BASECHOPPER_WASH_PUSH_MAX * flMass, gpGlobals->curtime );
game/server/hl2/cbasehelicopter.cpp:	if ( m_flRotorWashEntitySearchTime > gpGlobals->curtime )
game/server/hl2/cbasehelicopter.cpp:			Wash.flWashStartTime = gpGlobals->curtime;
game/server/hl2/cbasehelicopter.cpp:				if (m_flLastSeen < gpGlobals->curtime - 2)
game/server/hl2/cbasehelicopter.cpp:					m_flPrevSeen = gpGlobals->curtime;
game/server/hl2/cbasehelicopter.cpp:				m_flLastSeen = gpGlobals->curtime;
game/server/hl2/cbasehelicopter.cpp:		if ( !IsCrashing() && m_flLastSeen + 5 > gpGlobals->curtime ) //&& DotProduct( targetDir, desiredDir) > 0.25)
game/server/hl2/cbasehelicopter.cpp:	// ALERT( at_console, "%.0f %.0f %.0f\n", gpGlobals->curtime, m_flLastSeen, m_flPrevSeen );
game/server/hl2/cbasehelicopter.cpp:		//if ( (m_flLastSeen + 1 > gpGlobals->curtime) && (m_flPrevSeen + 2 < gpGlobals->curtime) )
game/server/hl2/cbasehelicopter.cpp:	if ( bApplyNoise && m_flRandomOffsetTime <= gpGlobals->curtime )
game/server/hl2/cbasehelicopter.cpp:		m_flRandomOffsetTime = gpGlobals->curtime + 1.0f;
game/server/hl2/cbasehelicopter.cpp:	SetContextThink( &CBaseHelicopter::DelayedKillThink, gpGlobals->curtime + 3.0f, s_pDelayedKillThinkContext );
game/server/hl2/cbasehelicopter.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl2/cbasehelicopter.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/cbasehelicopter.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl2/cbasehelicopter.cpp:	m_flStartupTime = gpGlobals->curtime;
game/server/hl2/cbasehelicopter.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/cbasehelicopter.cpp:	m_flRotorWashEntitySearchTime = gpGlobals->curtime;
game/server/hl2/cbasehelicopter.cpp:	SetContextThink( &CBaseHelicopter::RotorWashThink, gpGlobals->curtime, s_pRotorWashThinkContext );
game/server/hl2/cbasehelicopter.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/cbasehelicopter.cpp:		m_flNextRocket = gpGlobals->curtime + 4.0;
game/server/hl2/cbasehelicopter.cpp:		m_flNextRocket = gpGlobals->curtime + 15.0;
game/server/hl2/cbasehelicopter.cpp:			m_flLastSeen = m_flPrevSeen = gpGlobals->curtime;
game/server/hl2/npc_combinedropship.cpp:		if ( (info.GetInflictor() != m_hLastInflictor) || (gpGlobals->curtime != m_flLastHitTime) )
game/server/hl2/npc_combinedropship.cpp:			m_flLastHitTime = gpGlobals->curtime; 
game/server/hl2/npc_combinedropship.cpp:		if ( !IsCrashing() && m_flLastSeen + 5 > gpGlobals->curtime )
game/server/hl2/npc_combinedropship.cpp:	float dt = gpGlobals->curtime - m_flLastTime;
game/server/hl2/npc_combinedropship.cpp:	m_flLastTime = gpGlobals->curtime;
game/server/hl2/npc_combinedropship.cpp:				angles.x = m_existPitch + ( sin( gpGlobals->curtime * 3.5f ) * DROPSHIP_MAX_LAND_TILT );
game/server/hl2/npc_combinedropship.cpp:				angles.z = m_existRoll + ( sin( gpGlobals->curtime * 3.75f ) * DROPSHIP_MAX_LAND_TILT );
game/server/hl2/npc_combinedropship.cpp:				m_flTimeTakeOff = gpGlobals->curtime + flHoverTime;
game/server/hl2/npc_combinedropship.cpp:						m_flTimeTakeOff = gpGlobals->curtime + 0.5;
game/server/hl2/npc_combinedropship.cpp:				if( gpGlobals->curtime > m_flTimeTakeOff )
game/server/hl2/npc_combinedropship.cpp:				else if ( (m_flTimeTakeOff - gpGlobals->curtime) < 0.5f )
game/server/hl2/npc_combinedropship.cpp:		m_flTimeTakeOff = gpGlobals->curtime + 0.5;
game/server/hl2/npc_combinedropship.cpp:		m_flTimeTakeOff = gpGlobals->curtime + 0.5;
game/server/hl2/npc_combinedropship.cpp:	if ( m_flNextTroopSpawnAttempt > gpGlobals->curtime )
game/server/hl2/npc_combinedropship.cpp:		m_flNextTroopSpawnAttempt = gpGlobals->curtime + 1;
game/server/hl2/npc_combinedropship.cpp:		if ( gpGlobals->curtime - GetEnemyLastTimeSeen() >= 3.0f )
game/server/hl2/npc_combinedropship.cpp:				m_flDropDelay = gpGlobals->curtime + DROPSHIP_TIME_BETWEEN_MINES;
game/server/hl2/npc_combinedropship.cpp:				if ( gpGlobals->curtime > m_flDropDelay )		// time to drop next mine?
game/server/hl2/npc_combinedropship.cpp:					m_flDropDelay = gpGlobals->curtime + DROPSHIP_TIME_BETWEEN_MINES;
game/server/hl2/npc_combinedropship.cpp:		m_flTimeNextAttack = gpGlobals->curtime + 0.1;
game/server/hl2/npc_combinedropship.cpp:		m_flTimeNextAttack = gpGlobals->curtime + (m_iBurstRounds * 0.1);
game/server/hl2/npc_combinedropship.cpp:	if ( m_flTimeNextAttack > gpGlobals->curtime )
game/server/hl2/npc_combinedropship.cpp:	m_flTimeNextAttack = gpGlobals->curtime + 0.05;
game/server/hl2/weapon_sniperrifle.cpp:	m_fNextZoom = gpGlobals->curtime;
game/server/hl2/weapon_sniperrifle.cpp:	if ((m_bInReload) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_sniperrifle.cpp:		if (m_fNextZoom <= gpGlobals->curtime)
game/server/hl2/weapon_sniperrifle.cpp:	else if ((pPlayer->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_sniperrifle.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/server/hl2/weapon_sniperrifle.cpp:				 m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_sniperrifle.cpp:		if ( !HasAnyAmmo() && m_flNextPrimaryAttack < gpGlobals->curtime ) 
game/server/hl2/weapon_sniperrifle.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 0.3;
game/server/hl2/weapon_sniperrifle.cpp:			if ( m_iClip1 == 0 && !(GetWeaponFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < gpGlobals->curtime )
game/server/hl2/weapon_sniperrifle.cpp:			m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_sniperrifle.cpp:	if ( gpGlobals->curtime >= m_flNextPrimaryAttack )
game/server/hl2/weapon_sniperrifle.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_sniperrifle.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/hl2/weapon_sniperrifle.cpp:	m_fNextZoom = gpGlobals->curtime + SNIPER_ZOOM_RATE;
game/server/hl2/hl2_triggers.cpp:	SetContextThink( &CTriggerWeaponDissolve::DissolveThink, gpGlobals->curtime + 0.1f, s_pDissolveThinkContext );
game/server/hl2/hl2_triggers.cpp:		pWeapon->Dissolve( NULL, gpGlobals->curtime + ( 3.0f - flLifetime ), false );
game/server/hl2/hl2_triggers.cpp:		SetContextThink( &CTriggerWeaponDissolve::DissolveThink, gpGlobals->curtime + random->RandomFloat( 0.5f, 1.5f ), s_pDissolveThinkContext );
game/server/hl2/hl2_triggers.cpp:	SetContextThink( &CTriggerWeaponDissolve::DissolveThink, gpGlobals->curtime + 0.1f, s_pDissolveThinkContext );
game/server/hl2/hl2_triggers.cpp:	pAnim->Dissolve( NULL, gpGlobals->curtime, false, m_nDissolveType );
game/server/hl2/hl2_triggers.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/hl2_triggers.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/hl2_triggers.cpp:		float dt = gpGlobals->frametime;
game/server/hl2/hl2_triggers.cpp:			SetNextThink( gpGlobals->curtime );
game/server/hl2/hl2_triggers.cpp:	if ( gpGlobals->curtime > flKillTime )
game/server/hl2/hl2_triggers.cpp:		m_flEntityKillTimes[iIndex] = gpGlobals->curtime + WD_KILLTIME_NEXT_BITE;
game/server/hl2/hl2_triggers.cpp:			m_flEntityKillTimes.AddToTail( gpGlobals->curtime + WD_KILLTIME_NEXT_BITE );
game/server/hl2/hl2_triggers.cpp:			m_flEntityKillTimes.AddToTail( gpGlobals->curtime + WD_KILLTIME_NEXT_BITE );
game/server/hl2/info_darknessmode_lightsource.cpp:				SetNextThink( gpGlobals->curtime );
game/server/hl2/info_darknessmode_lightsource.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/info_darknessmode_lightsource.cpp:				pLightSource->SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_viewcontroller.cpp:	SetSimulationTime( gpGlobals->curtime );
game/server/hl2/vehicle_viewcontroller.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_viewcontroller.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_viewcontroller.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/hl2/env_alyxemp.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/env_alyxemp.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/hl2/env_alyxemp.cpp:		SetNextThink( gpGlobals->curtime + m_flDuration );
game/server/hl2/env_alyxemp.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/hl2/env_alyxemp.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl2/env_alyxemp.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/hl2/env_alyxemp.cpp:		SetNextThink( gpGlobals->curtime + flDuration + 1.0f );
game/server/hl2/npc_combinecamera.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat(0.1f, 0.3f) );
game/server/hl2/npc_combinecamera.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_combinecamera.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_combinecamera.cpp:	if (bMoved && (m_flMoveSoundTime < gpGlobals->curtime))
game/server/hl2/npc_combinecamera.cpp:		m_flMoveSoundTime = gpGlobals->curtime + CAMERA_MOVE_INTERVAL;
game/server/hl2/npc_combinecamera.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_combinecamera.cpp:				m_flEyeHappyTime = gpGlobals->curtime + 2.0;
game/server/hl2/npc_combinecamera.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_combinecamera.cpp:		if ((m_flClickTime != 0) && (m_flClickTime < gpGlobals->curtime))
game/server/hl2/npc_combinecamera.cpp:			m_flTurnOffEyeFlashTime = gpGlobals->curtime + 0.1;
game/server/hl2/npc_combinecamera.cpp:			m_flClickTime = gpGlobals->curtime + CAMERA_CLICK_INTERVAL;
game/server/hl2/npc_combinecamera.cpp:		else if ((m_flTurnOffEyeFlashTime != 0) && (m_flTurnOffEyeFlashTime < gpGlobals->curtime))
game/server/hl2/npc_combinecamera.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_combinecamera.cpp:	m_vecGoalAngles.y = GetAbsAngles().y + (sin(gpGlobals->curtime * 2.0f) * 45.0f);
game/server/hl2/npc_combinecamera.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_combinecamera.cpp:	if ( state == CAMERA_EYE_IDLE && m_flEyeHappyTime > gpGlobals->curtime )
game/server/hl2/npc_combinecamera.cpp:	if (m_flPingTime > gpGlobals->curtime)
game/server/hl2/npc_combinecamera.cpp:	m_flPingTime = gpGlobals->curtime + COMBINE_CAMERA_PING_TIME;
game/server/hl2/npc_combinecamera.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_combinecamera.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_combinecamera.cpp:		m_flClickTime = gpGlobals->curtime + 0.4;
game/server/hl2/npc_combinecamera.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_bullseye.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_bullseye.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_bullseye.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_tripwire.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_tripwire.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_tripwire.cpp://	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/server/hl2/weapon_tripwire.cpp:	if ((pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_tripwire.cpp:	else if (!m_bNeedReload && (pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/citadel_effects.cpp:		m_flStartTime = gpGlobals->curtime;
game/server/hl2/citadel_effects.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/hl2/citadel_effects.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/hl2/citadel_effects.cpp:	m_flStartTime = gpGlobals->curtime;
game/server/hl2/grenade_ar2.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_ar2.cpp:	m_fSpawnTime = gpGlobals->curtime;
game/server/hl2/grenade_ar2.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/grenade_ar2.cpp:		if (m_fSpawnTime + MAX_AR2_NO_COLLIDE_TIME < gpGlobals->curtime)
game/server/hl2/vehicle_jetski.cpp:	m_flHandbrakeTime = gpGlobals->curtime + 0.1;
game/server/hl2/vehicle_jetski.cpp:	if ( gpGlobals->curtime < m_flHandbrakeTime )
game/server/hl2/vehicle_jetski.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_jetski.cpp:			m_flAnimTime = gpGlobals->curtime;
game/server/hl2/weapon_irifle.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime + 1;
game/server/hl2/npc_combinegunship.cpp:	m_flTimeNextAttack = gpGlobals->curtime;
game/server/hl2/npc_combinegunship.cpp:	m_flNextSeeEnemySound = gpGlobals->curtime;
game/server/hl2/npc_combinegunship.cpp:	m_flTimeNextPing = gpGlobals->curtime + 2;
game/server/hl2/npc_combinegunship.cpp:		if( !HasCondition(COND_SEE_ENEMY) && gpGlobals->curtime > m_flTimeNextPing )
game/server/hl2/npc_combinegunship.cpp:			m_flTimeNextPing = gpGlobals->curtime + 3;
game/server/hl2/npc_combinegunship.cpp:		if( gpGlobals->curtime > m_flTimeNextPing )
game/server/hl2/npc_combinegunship.cpp:			m_flTimeNextPing = gpGlobals->curtime + 3;
game/server/hl2/npc_combinegunship.cpp:	if ( m_flNextGroundAttack > gpGlobals->curtime )
game/server/hl2/npc_combinegunship.cpp:	m_flGroundAttackTime = gpGlobals->curtime + 3.0f;
game/server/hl2/npc_combinegunship.cpp:				if ( (m_flGroundAttackTime - gpGlobals->curtime) <= 2.0f )
game/server/hl2/npc_combinegunship.cpp:				g_pEffects->Sparks( tr2.endpos, 3.0f - (m_flGroundAttackTime-gpGlobals->curtime), 3.5f - (m_flGroundAttackTime-gpGlobals->curtime), &tr2.plane.normal );
game/server/hl2/npc_combinegunship.cpp:				pEntity->GetBaseAnimating()->Dissolve( NULL, gpGlobals->curtime );
game/server/hl2/npc_combinegunship.cpp:	m_flNextGroundAttack = gpGlobals->curtime + 4.0f;
game/server/hl2/npc_combinegunship.cpp:	m_flTimeNextAttack	 = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_combinegunship.cpp:			if ( GetEnemy() && GetEnemy()->IsPlayer() && m_flNextSeeEnemySound < gpGlobals->curtime )
game/server/hl2/npc_combinegunship.cpp:				m_flNextSeeEnemySound = gpGlobals->curtime + 5.0;
game/server/hl2/npc_combinegunship.cpp:				if ( ( m_flTimeNextAttack > gpGlobals->curtime ) && ( ( m_flTimeNextAttack - gpGlobals->curtime ) > GUNSHIP_MISSILE_MAX_RESPONSE_TIME ) )
game/server/hl2/npc_combinegunship.cpp:					m_flTimeNextAttack = gpGlobals->curtime + GUNSHIP_MISSILE_MAX_RESPONSE_TIME;
game/server/hl2/npc_combinegunship.cpp:		if ( ( m_iBurstSize > 0 ) && ( gpGlobals->curtime > m_flTimeNextAttack ) )
game/server/hl2/npc_combinegunship.cpp:				m_flTimeNextAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_combinegunship.cpp:			if ( m_flGroundAttackTime < gpGlobals->curtime )
game/server/hl2/npc_combinegunship.cpp:	m_flDeltaT = gpGlobals->curtime - GetLastThink();
game/server/hl2/npc_combinegunship.cpp:	if ( m_flEndDestructTime && gpGlobals->curtime > m_flEndDestructTime )
game/server/hl2/npc_combinegunship.cpp:		float flTimeLeft = m_flEndDestructTime - gpGlobals->curtime;
game/server/hl2/npc_combinegunship.cpp:			if ( m_flNextGunshipCrashFind < gpGlobals->curtime )
game/server/hl2/npc_combinegunship.cpp:	if ( GetEnemy() && !m_bIsFiring && gpGlobals->curtime > m_flTimeNextAttack )
game/server/hl2/npc_combinegunship.cpp:			m_flTimeNextAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_combinegunship.cpp:	m_flTimeNextAttack = gpGlobals->curtime + 0.05f;
game/server/hl2/npc_combinegunship.cpp:			m_flNextGunshipCrashFind = gpGlobals->curtime + 0.5;
game/server/hl2/npc_combinegunship.cpp:			m_flEndDestructTime = gpGlobals->curtime + 3.0;
game/server/hl2/npc_combinegunship.cpp:	m_flNextGunshipCrashFind = gpGlobals->curtime + 0.5;
game/server/hl2/npc_combinegunship.cpp:	m_flEndDestructTime = gpGlobals->curtime + 3.0;
game/server/hl2/npc_combinegunship.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_combinegunship.cpp:		if ( !IsCrashing() && m_flLastSeen + 5 > gpGlobals->curtime )
game/server/hl2/npc_combinegunship.cpp:	m_flTimeNextAttack = gpGlobals->curtime;
game/server/hl2/npc_combinegunship.cpp:	m_flTimeNextAttack = gpGlobals->curtime + flDelay;
game/server/hl2/npc_combinegunship.cpp:		if ( gpGlobals->curtime - GetEnemyLastTimeSeen() >= 3.0f )
game/server/hl2/trigger_super_armor.cpp:		SetContextThink( RechargeThink, gpGlobals->curtime + 0.01f, s_pRechargeThinkContext );
game/server/hl2/trigger_super_armor.cpp:		m_flLoopingSoundTime = 0.56f + gpGlobals->curtime;
game/server/hl2/trigger_super_armor.cpp:		SetContextThink( NULL, gpGlobals->curtime + 0.01f, s_pRechargeThinkContext );
game/server/hl2/trigger_super_armor.cpp:				if ( m_flLoopingSoundTime < gpGlobals->curtime )
game/server/hl2/trigger_super_armor.cpp:	SetContextThink( RechargeThink, gpGlobals->curtime + 0.1f, s_pRechargeThinkContext );
game/server/hl2/npc_manhack.cpp:	if( m_flWaterSuspendTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:			if( gpGlobals->curtime - m_flWaterSuspendTime > 2.0 )
game/server/hl2/npc_manhack.cpp:				m_flWaterSuspendTime = gpGlobals->curtime + 1.0;
game/server/hl2/npc_manhack.cpp:		m_flEngineStallTime = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_manhack.cpp:		m_flEngineStallTime = gpGlobals->curtime + 0.25f;
game/server/hl2/npc_manhack.cpp:		m_flNextBurstTime = gpGlobals->curtime + FLT_MAX;
game/server/hl2/npc_manhack.cpp:		m_flNextBurstTime = gpGlobals->curtime + 2.0;
game/server/hl2/npc_manhack.cpp:			if ( m_flNextBurstTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:			if( gpGlobals->curtime > m_fTimeNextLoiterPulse )
game/server/hl2/npc_manhack.cpp:				m_fTimeNextLoiterPulse = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_manhack.cpp:	if (m_fForceMoveTime > gpGlobals->curtime)
game/server/hl2/npc_manhack.cpp:	else if (m_fSwarmMoveTime > gpGlobals->curtime)
game/server/hl2/npc_manhack.cpp:	if ( gpGlobals->curtime < m_flEngineStallTime || m_iHealth <= 0 )
game/server/hl2/npc_manhack.cpp:	if ( m_flBurstDuration > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:	m_flLastDamageTime = gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	if ( m_flBumpSuppressTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:			m_flBumpSuppressTime = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_manhack.cpp:			 gpGlobals->curtime > m_flWaterSuspendTime )
game/server/hl2/npc_manhack.cpp:	if( m_flWaterSuspendTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:			m_flEnginePitch1Time = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_manhack.cpp:			m_flEnginePitch2Time = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_manhack.cpp:			m_flEnginePitch1Time = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_manhack.cpp:			m_flEnginePitch2Time = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_manhack.cpp:			m_flEnginePitch1Time = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_manhack.cpp:			m_flEnginePitch2Time = gpGlobals->curtime + 0.2f;
game/server/hl2/npc_manhack.cpp:		m_flEnginePitch1Time = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_manhack.cpp:		m_flEnginePitch2Time = gpGlobals->curtime + 0.2f;
game/server/hl2/npc_manhack.cpp:	if (gpGlobals->curtime > m_flNextEngineSoundTime && flEnemyDist < 48)
game/server/hl2/npc_manhack.cpp:		m_flNextEngineSoundTime	= gpGlobals->curtime + random->RandomFloat( 3.0, 10.0 );
game/server/hl2/npc_manhack.cpp:	if( m_fEnginePowerScale < GetMaxEnginePower() && gpGlobals->curtime > m_flWaterSuspendTime )
game/server/hl2/npc_manhack.cpp:		if ( IsInEffectiveTargetZone( GetEnemy() ) && flDist < MANHACK_CHARGE_MIN_DIST && gpGlobals->curtime > m_flNextBurstTime )
game/server/hl2/npc_manhack.cpp:		if ( gpGlobals->curtime > m_flBurstDuration )
game/server/hl2/npc_manhack.cpp:	if( m_flWaterSuspendTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:		float flLerpFactor = (gpGlobals->curtime - m_flLastPhysicsInfluenceTime) / MANHACK_SMASH_TIME;
game/server/hl2/npc_manhack.cpp:	if (gpGlobals->curtime < m_flEngineStallTime)
game/server/hl2/npc_manhack.cpp:		if ( m_flEngineStallTime < gpGlobals->curtime && m_flBurstDuration < gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:		if ( m_flEngineStallTime < gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:	if (gpGlobals->curtime > m_fSmokeTime && GetWaterLevel() == 0)
game/server/hl2/npc_manhack.cpp:		m_fSmokeTime = gpGlobals->curtime + random->RandomFloat( 0.1, 0.3);
game/server/hl2/npc_manhack.cpp:	if (gpGlobals->curtime > m_fSparkTime)
game/server/hl2/npc_manhack.cpp:		m_fSparkTime = gpGlobals->curtime + random->RandomFloat(0.1, 0.3);
game/server/hl2/npc_manhack.cpp:	if ( m_flNextBurstTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:			float t = m_fSwarmMoveTime - gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flNextBurstTime	= gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flNextEngineSoundTime		= gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flWaterSuspendTime		= gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flEngineStallTime			= gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_fForceMoveTime			= gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_fSwarmMoveTime			= gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flEnginePitch1Time = gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flEnginePitch2Time = gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flEnginePitch1Time = gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:	m_flEnginePitch2Time = gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:				m_fSwarmMoveTime = gpGlobals->curtime + RandomFloat( pTask->flTaskData * 0.8, pTask->flTaskData * 1.2 );
game/server/hl2/npc_manhack.cpp:		m_fForceMoveTime   = gpGlobals->curtime + 2.0;
game/server/hl2/npc_manhack.cpp:	if( m_flWaterSuspendTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:	if ( m_flEngineStallTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:		SetNextThink( gpGlobals->curtime + 0.01f );
game/server/hl2/npc_manhack.cpp:		m_flEngineStallTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_manhack.cpp:		m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/npc_manhack.cpp:		SetNextThink( gpGlobals->curtime + 0.01f );
game/server/hl2/npc_manhack.cpp:		m_flEngineStallTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_manhack.cpp:	if ( IsHeldByPhyscannon() || (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime) )
game/server/hl2/npc_manhack.cpp:	if ( m_flEngineStallTime > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:	if ( m_flBurstDuration > gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:	m_flNextBurstTime = gpGlobals->curtime + 2.0;
game/server/hl2/npc_manhack.cpp:	m_flBurstDuration = gpGlobals->curtime + 1.0;
game/server/hl2/npc_manhack.cpp:	if ( m_flBurstDuration < gpGlobals->curtime )
game/server/hl2/npc_manhack.cpp:	m_flNextBurstTime = gpGlobals->curtime + 2.0f; //FIXME: Skill level based
game/server/hl2/npc_manhack.cpp:	m_flBurstDuration = gpGlobals->curtime - 0.1f;
game/server/hl2/weapon_extinguisher.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/weapon_extinguisher.cpp:		if ( m_flNextPrimaryAttack < gpGlobals->curtime  )
game/server/hl2/weapon_extinguisher.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + EXTINGUISHER_AMMO_RATE;
game/server/hl2/weapon_extinguisher.cpp:	SetNextThink( gpGlobals->curtime + 0.25 );
game/server/hl2/item_ammo.cpp:	m_flCloseTime = gpGlobals->curtime;
game/server/hl2/item_ammo.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/hl2/item_ammo.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/item_ammo.cpp:	m_flCloseTime = gpGlobals->curtime + AMMO_CRATE_CLOSE_DELAY;
game/server/hl2/item_ammo.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/item_ammo.cpp:		if ( m_flCloseTime <= gpGlobals->curtime )
game/server/hl2/weapon_pistol_m1.cpp:	m_flSoonestPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_pistol_m1.cpp:	m_flSoonestPrimaryAttack = gpGlobals->curtime + PISTOL_FASTEST_DRY_REFIRE_TIME;
game/server/hl2/weapon_pistol_m1.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_pistol_m1.cpp:	if ((gpGlobals->curtime - m_flLastAttackTime) > 0.05f)
game/server/hl2/weapon_pistol_m1.cpp:	m_flLastAttackTime = gpGlobals->curtime;
game/server/hl2/weapon_pistol_m1.cpp:	m_flSoonestPrimaryAttack = gpGlobals->curtime + PISTOL_FASTEST_REFIRE_TIME;
game/server/hl2/weapon_pistol_m1.cpp:	if (((pOwner->m_nButtons & IN_ATTACK) == false) && (m_flSoonestPrimaryAttack < gpGlobals->curtime))
game/server/hl2/weapon_pistol_m1.cpp:		m_flAccuracyPenalty -= gpGlobals->frametime;
game/server/hl2/weapon_pistol_m1.cpp:	if (((pOwner->m_nButtons & IN_ATTACK) == false) && (m_flSoonestPrimaryAttack < gpGlobals->curtime))
game/server/hl2/weapon_pistol_m1.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime - 0.01f;
game/server/hl2/weapon_pistol_m1.cpp:	else if ((pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack < gpGlobals->curtime) && (m_iClip1 <= 0))
game/server/hl2/weapon_bugbait.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/hl2/weapon_bugbait.cpp:	SetNextThink(gpGlobals->curtime + 3.0);
game/server/hl2/weapon_bugbait.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_bugbait.cpp:	//m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f;
game/server/hl2/weapon_bugbait.cpp:	if ((m_bRedraw) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_bugbait.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_bugbait.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_bugbait.cpp:		if ((pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack < gpGlobals->curtime))
game/server/hl2/weapon_bugbait.cpp:		else if ((pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack < gpGlobals->curtime))
game/server/hl2/npc_crow.cpp:	m_flGroundIdleMoveTime = gpGlobals->curtime + random->RandomFloat( 0.0f, 5.0f );
game/server/hl2/npc_crow.cpp:	m_flSoarTime = gpGlobals->curtime;
game/server/hl2/npc_crow.cpp:	m_flLastStuckCheck = gpGlobals->curtime;
game/server/hl2/npc_crow.cpp:	m_flDangerSoundTime = gpGlobals->curtime;
game/server/hl2/npc_crow.cpp:		m_flSoarTime = gpGlobals->curtime + random->RandomFloat( 3, 5 );
game/server/hl2/npc_crow.cpp:			if ( m_flLastStuckCheck <= gpGlobals->curtime )
game/server/hl2/npc_crow.cpp:				m_flLastStuckCheck = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_crow.cpp:		if ( m_flSoarTime < gpGlobals->curtime )
game/server/hl2/npc_crow.cpp:				m_flSoarTime = gpGlobals->curtime + random->RandomFloat( 1, 4 );
game/server/hl2/npc_crow.cpp:				m_flSoarTime = gpGlobals->curtime + random->RandomFloat( 3, 5 );
game/server/hl2/npc_crow.cpp:	m_flDangerSoundTime = gpGlobals->curtime + 5.0f;
game/server/hl2/npc_crow.cpp:		m_flLastStuckCheck = gpGlobals->curtime + 3.0f;
game/server/hl2/npc_crow.cpp:		m_flGroundIdleMoveTime = gpGlobals->curtime + random->RandomFloat( 5.0f, 10.0f );
game/server/hl2/npc_crow.cpp:		m_flGroundIdleMoveTime = gpGlobals->curtime + random->RandomFloat( 5.0f, 10.0f );
game/server/hl2/npc_crow.cpp:		m_flGroundIdleMoveTime = gpGlobals->curtime + random->RandomFloat( 5.0f, 10.0f );
game/server/hl2/npc_crow.cpp:			m_flSoarTime = gpGlobals->curtime + random->RandomFloat( 2, 5 );
game/server/hl2/npc_crow.cpp:				m_flSoarTime = gpGlobals->curtime + random->RandomFloat( 2, 5 );
game/server/hl2/npc_crow.cpp:			if ( m_flNextFlinchTime < gpGlobals->curtime )
game/server/hl2/npc_crow.cpp:				m_flNextFlinchTime = gpGlobals->curtime + random->RandomFloat( 0.5f, 2.0f );
game/server/hl2/npc_crow.cpp:	if ( !( GetFlags() & FL_ONGROUND ) && ( gpGlobals->curtime > 2.0 ) && m_bOnJeep == false )
game/server/hl2/npc_crow.cpp:	if ( m_flDangerSoundTime <= gpGlobals->curtime )
game/server/hl2/npc_crow.cpp:			m_flDangerSoundTime = gpGlobals->curtime + 10.0f;
game/server/hl2/npc_crow.cpp:	if ( HasCondition( COND_CROW_ENEMY_TOO_CLOSE ) && m_flDangerSoundTime <= gpGlobals->curtime )
game/server/hl2/npc_crow.cpp:				if ( gpGlobals->curtime > m_flGroundIdleMoveTime )
game/server/hl2/npc_crow.cpp:					m_flGroundIdleMoveTime = gpGlobals->curtime + random->RandomFloat( 10.0f, 20.0f );
game/server/hl2/ai_behavior_actbusy.cpp:	m_flNextBusySearchTime = gpGlobals->curtime + ai_actbusy_search_time.GetFloat();
game/server/hl2/ai_behavior_actbusy.cpp:		m_flNextBusySearchTime = gpGlobals->curtime;
game/server/hl2/ai_behavior_actbusy.cpp:	m_flEndBusyAt = gpGlobals->curtime;
game/server/hl2/ai_behavior_actbusy.cpp:	if ( m_flDeferUntil > gpGlobals->curtime )
game/server/hl2/ai_behavior_actbusy.cpp:	return (m_flNextBusySearchTime < gpGlobals->curtime);
game/server/hl2/ai_behavior_actbusy.cpp:		m_flDeferUntil = gpGlobals->curtime + 4.0f;	// Stop actbusying and go deal with that enemy!!
game/server/hl2/ai_behavior_actbusy.cpp:		m_flDeferUntil = gpGlobals->curtime + 4.0f;	// Stop actbusying and go deal with that enemy!!
game/server/hl2/ai_behavior_actbusy.cpp:			m_fTimeLastSawSeeEntity = gpGlobals->curtime;
game/server/hl2/ai_behavior_actbusy.cpp:			float fDelta = gpGlobals->curtime - m_fTimeLastSawSeeEntity;
game/server/hl2/ai_behavior_actbusy.cpp:					m_flDeferUntil = gpGlobals->curtime + 4.0f;
game/server/hl2/ai_behavior_actbusy.cpp:					GetOuter()->SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/ai_behavior_actbusy.cpp:	if ( m_bForceActBusy || m_flNextBusySearchTime < gpGlobals->curtime )
game/server/hl2/ai_behavior_actbusy.cpp:			m_flNextBusySearchTime = gpGlobals->curtime + 2.0;
game/server/hl2/ai_behavior_actbusy.cpp:			m_flNextBusySearchTime = gpGlobals->curtime + RandomFloat(ai_actbusy_search_time.GetFloat(), ai_actbusy_search_time.GetFloat()*2);
game/server/hl2/ai_behavior_actbusy.cpp:				m_flNextBusySearchTime = gpGlobals->curtime + 10.0;
game/server/hl2/ai_behavior_actbusy.cpp:	if ( !ActBusyNodeStillActive() || (m_flEndBusyAt && gpGlobals->curtime >= m_flEndBusyAt) )
game/server/hl2/ai_behavior_actbusy.cpp:					m_flEndBusyAt = gpGlobals->curtime;
game/server/hl2/ai_behavior_actbusy.cpp:						m_flEndBusyAt = gpGlobals->curtime + flTime;
game/server/hl2/ai_behavior_actbusy.cpp:						m_flEndBusyAt = gpGlobals->curtime;
game/server/hl2/ai_behavior_actbusy.cpp:		m_flNextBusySearchTime = gpGlobals->curtime;
game/server/hl2/ai_behavior_actbusy.cpp:		m_flNextBusySearchTime = gpGlobals->curtime + (RandomFloat(ai_actbusy_search_time.GetFloat(), ai_actbusy_search_time.GetFloat()*2));
game/server/hl2/ai_behavior_actbusy.cpp:		SetContextThink( &CAI_ActBusyQueueGoal::QueueThink, gpGlobals->curtime + 5, QUEUE_THINK_CONTEXT );
game/server/hl2/ai_behavior_actbusy.cpp:	if ( GetNextThink( QUEUE_MOVEUP_THINK_CONTEXT ) < gpGlobals->curtime )
game/server/hl2/ai_behavior_actbusy.cpp:		float flTime = gpGlobals->curtime + RandomFloat( 0.3, 0.5 );
game/server/hl2/ai_behavior_actbusy.cpp:	SetContextThink( &CAI_ActBusyQueueGoal::QueueThink, gpGlobals->curtime + 5, QUEUE_THINK_CONTEXT );
game/server/hl2/item_dynamic_resupply.cpp:		SetNextThink( gpGlobals->curtime + RandomFloat(0.2f, 0.4f) );
game/server/hl2/item_dynamic_resupply.cpp:	if ( !HasSpawnFlags( SF_DYNAMICRESUPPLY_ALTERNATE_MASTER ) && HasSpawnFlags( SF_DYNAMICRESUPPLY_USE_MASTER ) && gpGlobals->curtime < 1.0 )
game/server/hl2/item_dynamic_resupply.cpp:	SetNextThink( gpGlobals->curtime + DYNAMIC_ITEM_THINK );
game/server/hl2/npc_assassin.cpp:	if ( m_flNextLungeTime > gpGlobals->curtime )
game/server/hl2/npc_assassin.cpp:	if ( m_flNextShotTime > gpGlobals->curtime )
game/server/hl2/npc_assassin.cpp:	m_flNextShotTime = gpGlobals->curtime + random->RandomFloat( 0.05f, 0.15f );
game/server/hl2/npc_assassin.cpp:			if ( /*(	HasCondition( COND_SEE_ENEMY ) && HasCondition( COND_ASSASSIN_ENEMY_TARGETTING_ME ) && random->RandomInt( 0, 32 ) == 0 && m_flNextFlipTime < gpGlobals->curtime ) )*/
game/server/hl2/npc_assassin.cpp:				m_flNextLungeTime	= gpGlobals->curtime + 2.0f;
game/server/hl2/npc_assassin.cpp:					m_flNextFlipTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_assassin.cpp:				m_flNextFlipTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_assassin.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/basehlcombatweapon.cpp:	while ( m_flNextPrimaryAttack <= gpGlobals->curtime )
game/server/hl2/basehlcombatweapon.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/hl2/basehlcombatweapon.cpp:	if (m_flNextSoundTime < gpGlobals->curtime)
game/server/hl2/basehlcombatweapon.cpp:		m_flNextSoundTime = gpGlobals->curtime;
game/server/hl2/basehlcombatweapon.cpp:	if (m_flNextSoundTime < gpGlobals->curtime + dt)
game/server/hl2/basehlcombatweapon.cpp:	if (m_flNextSoundTime < gpGlobals->curtime + dt)
game/server/hl2/basehlcombatweapon.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 3.0f );
game/server/hl2/basehlcombatweapon.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + GetBurstCycleRate();
game/server/hl2/basehlcombatweapon.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + GetBurstCycleRate();
game/server/hl2/basehlcombatweapon.cpp:		SetNextThink( gpGlobals->curtime + GetFireRate() );
game/server/hl2/basehlcombatweapon.cpp://	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3;
game/server/hl2/basehlcombatweapon.cpp:	//	SetWeaponIdleTime( gpGlobals->curtime );
game/server/hl2/basehlcombatweapon.cpp:	//SetNextThink( gpGlobals->curtime + GetFireRate() );
game/server/hl2/weapon_frag.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/server/hl2/weapon_frag.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/server/hl2/weapon_frag.cpp:	if ( ( m_bRedraw ) && ( m_flNextPrimaryAttack <= gpGlobals->curtime ) && ( m_flNextSecondaryAttack <= gpGlobals->curtime ) )
game/server/hl2/weapon_frag.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_frag.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_frag.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/server/hl2/point_apc_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.1f ); 
game/server/hl2/point_apc_controller.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/point_apc_controller.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/point_apc_controller.cpp:			SetNextThink( gpGlobals->curtime + 2 );	// Wait 2 sec s
game/server/hl2/point_apc_controller.cpp:					m_flFiringDelay = gpGlobals->curtime + 1.5;	// setup delay time before we start firing
game/server/hl2/point_apc_controller.cpp:				if ( gpGlobals->curtime > m_flFiringDelay )
game/server/hl2/prop_combine_ball.cpp:			m_flLastCaptureTime = gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:	m_flNextDamageTime = gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::AnimThink, gpGlobals->curtime + random->RandomFloat( 0.0f, 0.1f), s_pAnimThinkContext );
game/server/hl2/prop_combine_ball.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pAnimThinkContext );
game/server/hl2/prop_combine_ball.cpp:		SetContextThink( &CPropCombineBall::CaptureBySpawner, gpGlobals->curtime + 0.01f,	s_pCaptureContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( NULL, gpGlobals->curtime,	s_pCaptureContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pWhizThinkContext );
game/server/hl2/prop_combine_ball.cpp:		return gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::ExplodeThink, gpGlobals->curtime + flDuration, s_pExplodeTimerContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pExplodeTimerContext );
game/server/hl2/prop_combine_ball.cpp:	SetNextThink( gpGlobals->curtime + flDuration );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::WhizSoundThink, gpGlobals->curtime + 2.0f * TICK_INTERVAL, s_pWhizThinkContext );
game/server/hl2/prop_combine_ball.cpp:		SetContextThink( &CPropCombineBall::WhizSoundThink, gpGlobals->curtime + 2.0f * TICK_INTERVAL, s_pWhizThinkContext );
game/server/hl2/prop_combine_ball.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/hl2/prop_combine_ball.cpp:					SetContextThink( &CPropCombineBall::WhizSoundThink, gpGlobals->curtime + 0.5f, s_pWhizThinkContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::WhizSoundThink, gpGlobals->curtime + 2.0f * TICK_INTERVAL, s_pWhizThinkContext );
game/server/hl2/prop_combine_ball.cpp:		SetContextThink( &CPropCombineBall::DissolveRampSoundThink, gpGlobals->curtime + GetBallHoldSoundRampTime(), s_pHoldDissolveContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pHoldDissolveContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::DissolveThink, gpGlobals->curtime + dt, s_pHoldDissolveContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::SUB_Remove, gpGlobals->curtime + 0.5f, s_pRemoveContext );
game/server/hl2/prop_combine_ball.cpp:	pEntity->GetBaseAnimating()->Dissolve( "", gpGlobals->curtime, false, ENTITY_DISSOLVE_NORMAL );
game/server/hl2/prop_combine_ball.cpp:				if( gpGlobals->curtime >= m_flNextDamageTime )
game/server/hl2/prop_combine_ball.cpp:						m_flNextDamageTime = gpGlobals->curtime + 0.1f;
game/server/hl2/prop_combine_ball.cpp:	if ( gpGlobals->curtime - m_flLastBounceTime < 0.25f )
game/server/hl2/prop_combine_ball.cpp:	m_flLastBounceTime = gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::WhizSoundThink, gpGlobals->curtime + 0.01, s_pWhizThinkContext );
game/server/hl2/prop_combine_ball.cpp:	SetContextThink( &CPropCombineBall::AnimThink, gpGlobals->curtime + 0.1f, s_pAnimThinkContext );
game/server/hl2/prop_combine_ball.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/prop_combine_ball.cpp:		m_BallRespawnTime[i] += gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/prop_combine_ball.cpp:	m_flDisableTime = gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:		m_BallRespawnTime[i] -= gpGlobals->curtime;
game/server/hl2/prop_combine_ball.cpp:		pCombineBall->SetContextThink( NULL, gpGlobals->curtime, s_pCaptureContext );
game/server/hl2/prop_combine_ball.cpp:	if ( gpGlobals->curtime - pBall->LastCaptureTime() < 0.5f )
game/server/hl2/prop_combine_ball.cpp:	m_BallRespawnTime.AddToTail( gpGlobals->curtime + flRespawnTime - m_flDisableTime );
game/server/hl2/prop_combine_ball.cpp:		m_BallRespawnTime.AddToTail( gpGlobals->curtime + 4.0f - m_flDisableTime );
game/server/hl2/prop_combine_ball.cpp:		m_BallRespawnTime.AddToTail( gpGlobals->curtime + m_flBallRespawnTime - m_flDisableTime );
game/server/hl2/prop_combine_ball.cpp:		if ( m_BallRespawnTime[i] < gpGlobals->curtime )
game/server/hl2/prop_combine_ball.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/vehicle_crane.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_crane.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/vehicle_crane.cpp:	RunCraneMovement( gpGlobals->frametime );
game/server/hl2/vehicle_crane.cpp:			m_flTurn = UTIL_Approach( m_flMaxTurnSpeed, m_flTurn, flTurnAdd * gpGlobals->frametime );
game/server/hl2/vehicle_crane.cpp:			m_flTurn = UTIL_Approach( -m_flMaxTurnSpeed, m_flTurn, flTurnAdd * gpGlobals->frametime );
game/server/hl2/vehicle_crane.cpp:		m_flTurn = UTIL_Approach( 0, m_flTurn, m_flTurnDecel * gpGlobals->frametime );
game/server/hl2/vehicle_crane.cpp:		m_flExtensionRate = UTIL_Approach( m_flMaxExtensionSpeed, m_flExtensionRate, m_flExtensionAccel * gpGlobals->frametime );
game/server/hl2/vehicle_crane.cpp:		m_flExtensionRate = UTIL_Approach( -m_flMaxExtensionSpeed, m_flExtensionRate, m_flExtensionAccel * gpGlobals->frametime );
game/server/hl2/vehicle_crane.cpp:		m_flExtensionRate = UTIL_Approach( 0, m_flExtensionRate, m_flExtensionDecel * gpGlobals->frametime );
game/server/hl2/vehicle_crane.cpp:		else if ( !m_bDropping && m_flNextDropAllowedTime < gpGlobals->curtime )
game/server/hl2/vehicle_crane.cpp:			m_flNextDropAllowedTime = gpGlobals->curtime + 3.0;
game/server/hl2/vehicle_crane.cpp:			m_flSlowRaiseTime = gpGlobals->curtime;
game/server/hl2/vehicle_crane.cpp:	else if ( (m_flSlowRaiseTime + CRANE_SLOWRAISE_TIME) > gpGlobals->curtime )
game/server/hl2/vehicle_crane.cpp:		float flDelta = (gpGlobals->curtime - m_flSlowRaiseTime);
game/server/hl2/vehicle_crane.cpp:	if ( (m_flNextDangerSoundTime < gpGlobals->curtime) && (m_hCraneMagnet->GetTotalMassAttachedObjects() > 0) )
game/server/hl2/vehicle_crane.cpp:		m_flNextDangerSoundTime = gpGlobals->curtime + 0.3;
game/server/hl2/vehicle_crane.cpp:	if ( (m_flNextCreakSound < gpGlobals->curtime) && (m_hCraneMagnet->GetTotalMassAttachedObjects() > 100) )
game/server/hl2/vehicle_crane.cpp:			m_flNextCreakSound = gpGlobals->curtime + 5.0;
game/server/hl2/script_intro.cpp:	m_flBlendStartTime = m_flNextBlendTime = gpGlobals->curtime;
game/server/hl2/script_intro.cpp:	SetContextThink( NULL, gpGlobals->curtime, "BlendComplete" );
game/server/hl2/script_intro.cpp:		DevMsg( 1, "%.2f INPUT: Blend mode set to %d\n", gpGlobals->curtime, m_iBlendMode.Get() );
game/server/hl2/script_intro.cpp:		DevMsg( 1, "%.2f INPUT: Next Blend mode set to %d\n", gpGlobals->curtime, m_iQueuedNextBlendMode );
game/server/hl2/script_intro.cpp:	if ( m_flNextFOVBlendTime >= gpGlobals->curtime )
game/server/hl2/script_intro.cpp:	m_flNextFOVBlendTime = gpGlobals->curtime + inputdata.value.Float();
game/server/hl2/script_intro.cpp:	m_flFOVBlendStartTime = gpGlobals->curtime;
game/server/hl2/script_intro.cpp:	m_flNextBlendTime = gpGlobals->curtime + inputdata.value.Float();
game/server/hl2/script_intro.cpp:	m_flBlendStartTime = gpGlobals->curtime;
game/server/hl2/script_intro.cpp:		DevMsg( 1, "%.2f BLEND STARTED: %d to %d, end at %.2f\n", gpGlobals->curtime, m_iBlendMode.Get(), m_iNextBlendMode.Get(), m_flNextBlendTime.Get() );
game/server/hl2/script_intro.cpp:	m_flBlendStartTime = m_flNextBlendTime = gpGlobals->curtime;
game/server/hl2/script_intro.cpp:	SetContextThink( NULL, gpGlobals->curtime, "BlendComplete" );
game/server/hl2/script_intro.cpp:	//Msg("%.2f INPUT FADE: Fade to %.2f. End at %.2f\n", gpGlobals->curtime, m_flFadeAlpha.Get(), gpGlobals->curtime + m_flFadeDuration.Get() );
game/server/hl2/weapon_357.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/server/hl2/weapon_357.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.4f;
game/server/hl2/weapon_357.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.4f;
game/server/hl2/weapon_357.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/hl2/weapon_357.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_357.cpp:		if ((pOwner->m_afButtonPressed & IN_ATTACK) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_357.cpp:		if ((pOwner->m_afButtonPressed & IN_ATTACK2) && gpGlobals->curtime >= m_flNextSecondaryAttack)
game/server/hl2/weapon_357.cpp:		if ((pOwner->m_afButtonPressed & IN_RELOAD) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_smg1.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_smg1.cpp:	if (gpGlobals->curtime >= m_flSecondaryReloadActivationTime)
game/server/hl2/weapon_smg1.cpp:	if (gpGlobals->curtime >= m_flSecondaryReloadDeactivationTime)
game/server/hl2/weapon_smg1.cpp:	if (m_bSecondaryEjectPending && gpGlobals->curtime > m_flSecondaryEjectTime) //new
game/server/hl2/weapon_smg1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
game/server/hl2/weapon_smg1.cpp:	//m_flNextPrimaryAttack = gpGlobals->curtime + 2.2f;
game/server/hl2/weapon_smg1.cpp:	//m_flNextSecondaryAttack = gpGlobals->curtime + 2.2f;
game/server/hl2/weapon_smg1.cpp:	m_flSecondaryReloadActivationTime = gpGlobals->curtime; // signal the secondary reload to ItemPostFrame() immediately to forbid ironsight
game/server/hl2/weapon_smg1.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flSecondaryReloadDeactivationTime = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_smg1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_smg1.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 2.2f;
game/server/hl2/weapon_smg1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 2.2f;
game/server/hl2/weapon_smg1.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_smg1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_smg1.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );	
game/server/hl2/weapon_smg1.cpp:		m_flSecondaryEjectTime = gpGlobals->curtime + 0.5f; //new
game/server/hl2/weapon_smg1.cpp:		//m_flNextPrimaryAttack = gpGlobals->curtime + 2.2f;
game/server/hl2/weapon_smg1.cpp:		//m_flNextSecondaryAttack = gpGlobals->curtime + 2.2f;
game/server/hl2/weapon_smg1.cpp:		m_flSecondaryReloadActivationTime = gpGlobals->curtime; // signal the secondary reload to ItemPostFrame() immediately to forbid ironsight
game/server/hl2/weapon_smg1.cpp:		m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flSecondaryReloadDeactivationTime = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_smg1.cpp:	if (gpGlobals->curtime < m_flNextGrenadeCheck )
game/server/hl2/weapon_smg1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/weapon_smg1.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/weapon_smg1.cpp:		//m_flNextGrenadeCheck = gpGlobals->curtime;
game/server/hl2/weapon_smg1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 0.3; // 1/3 second.
game/server/hl2/weapon_smg1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/weapon_smg1.cpp:		SetWeaponIdleTime(gpGlobals->curtime + 3.0f);
game/server/hl2/weapon_smg1.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + GetBurstCycleRate();
game/server/hl2/weapon_smg1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + GetBurstCycleRate();
game/server/hl2/weapon_smg1.cpp:		SetNextThink(gpGlobals->curtime + GetFireRate());
game/server/hl2/npc_citizen17.cpp:	m_flNextHealthSearchTime = gpGlobals->curtime;
game/server/hl2/npc_citizen17.cpp:		Q_strncpy(szMapName, STRING(gpGlobals->mapname), sizeof(szMapName) );
game/server/hl2/npc_citizen17.cpp:		m_flNextHealthSearchTime = gpGlobals->curtime + 4.0;
game/server/hl2/npc_citizen17.cpp:				m_flTimePlayerStare = gpGlobals->curtime;
game/server/hl2/npc_citizen17.cpp:			if( gpGlobals->curtime - m_flTimePlayerStare >= sk_citizen_player_stare_time.GetFloat() && gpGlobals->curtime > m_flTimeNextHealStare && !IsCurSchedule( SCHED_CITIZEN_HEAL ) )
game/server/hl2/npc_citizen17.cpp:					m_flTimeNextHealStare = gpGlobals->curtime + sk_citizen_stare_heal_time.GetFloat() * .5f;
game/server/hl2/npc_citizen17.cpp:		float timeInSquad = gpGlobals->curtime - m_flTimeJoinedPlayerSquad;
game/server/hl2/npc_citizen17.cpp:		m_flNextWeaponSearchTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_citizen17.cpp:			m_flNextWeaponSearchTime = gpGlobals->curtime + 10.0;
game/server/hl2/npc_citizen17.cpp:				float imprecision = 18*sin(gpGlobals->curtime);
game/server/hl2/npc_citizen17.cpp:		m_flPlayerHealTime 	= gpGlobals->curtime + sk_citizen_heal_ally_delay.GetFloat();
game/server/hl2/npc_citizen17.cpp:				m_flPlayerHealTime 	= gpGlobals->curtime + sk_citizen_heal_toss_player_delay.GetFloat();;
game/server/hl2/npc_citizen17.cpp:						m_flNextWeaponSearchTime = gpGlobals->curtime + SHOTGUN_DEFER_SEARCH_TIME;
game/server/hl2/npc_citizen17.cpp:						m_flNextWeaponSearchTime = gpGlobals->curtime + SHOTGUN_DEFER_SEARCH_TIME + 10.0f;
game/server/hl2/npc_citizen17.cpp:		if ( gpGlobals->curtime - m_AutoSummonTimer.GetNext() > player_squad_autosummon_time.GetFloat() * 2 )
game/server/hl2/npc_citizen17.cpp:				DevMsg( "Auto summoning squad: long time (%f)\n", ( gpGlobals->curtime - m_AutoSummonTimer.GetNext() ) + player_squad_autosummon_time.GetFloat() );
game/server/hl2/npc_citizen17.cpp:					if ( gpGlobals->curtime - pNpc->GetLastAttackTime() > timeSinceCombatTolerance || 
game/server/hl2/npc_citizen17.cpp:						 gpGlobals->curtime - pNpc->GetLastDamageTime() > timeSinceCombatTolerance )
game/server/hl2/npc_citizen17.cpp:					if ( !IsSniper( pNpc ) && ( gpGlobals->curtime - pNpc->GetEnemyLastTimeSeen() ) > timeSinceCombatTolerance )
game/server/hl2/npc_citizen17.cpp:						g_EventQueue.AddEvent( pRespondant, "SpeakIdleResponse", ( GetTimeSpeechComplete() - gpGlobals->curtime ) + .2, this, this );
game/server/hl2/npc_citizen17.cpp:		m_flTimeLastCloseToPlayer = gpGlobals->curtime;
game/server/hl2/npc_citizen17.cpp:				 gpGlobals->curtime - pCitizen->m_FollowBehavior.GetTimeFailFollowStarted() > 20 &&
game/server/hl2/npc_citizen17.cpp:						 gpGlobals->curtime - pCitizen->m_FollowBehavior.GetTimeFailFollowStarted(), 
game/server/hl2/npc_citizen17.cpp:					( pCitizen->m_flTimeJoinedPlayerSquad == 0 || gpGlobals->curtime - pCitizen->m_flTimeJoinedPlayerSquad > 60.0 ) && 
game/server/hl2/npc_citizen17.cpp:					( pCitizen->m_flTimeLastCloseToPlayer == 0 || gpGlobals->curtime - pCitizen->m_flTimeLastCloseToPlayer > 15.0 ) )
game/server/hl2/npc_citizen17.cpp:	m_flTimeJoinedPlayerSquad = gpGlobals->curtime;
game/server/hl2/npc_citizen17.cpp:		if ( gpGlobals->curtime - lastTime > 2.0 || !hCurrent || !hCurrent->IsInPlayerSquad() ) // hCurrent will be NULL after level change
game/server/hl2/npc_citizen17.cpp:			lastTime = gpGlobals->curtime;
game/server/hl2/npc_citizen17.cpp:		if ( gpGlobals->curtime > m_fNextInspectTime )
game/server/hl2/npc_citizen17.cpp:			SetNextScannerInspectTime( gpGlobals->curtime + 5.0 );
game/server/hl2/npc_citizen17.cpp:		SetNextScannerInspectTime( gpGlobals->curtime + CIT_INSPECTED_DELAY_TIME );
game/server/hl2/npc_citizen17.cpp:					float healAmt = ( maximumHealAmount * ( 1.0 - ( timeFullHeal - gpGlobals->curtime ) / timeRecharge ) );
game/server/hl2/npc_citizen17.cpp:				bool bReadyToHeal = ( ( bTargetIsPlayer && m_flPlayerHealTime <= gpGlobals->curtime ) || 
game/server/hl2/npc_citizen17.cpp:									  ( !bTargetIsPlayer && m_flAllyHealTime <= gpGlobals->curtime ) );
game/server/hl2/npc_citizen17.cpp:		if ( m_flPlayerGiveAmmoTime <= gpGlobals->curtime )
game/server/hl2/npc_citizen17.cpp:				float healAmt = ( maximumHealAmount * ( 1.0 - ( timeFullHeal - gpGlobals->curtime ) / timeRecharge ) );
game/server/hl2/npc_citizen17.cpp:			bool bReadyToHeal = ( ( bTargetIsPlayer && m_flPlayerHealTime <= gpGlobals->curtime ) || 
game/server/hl2/npc_citizen17.cpp:				( !bTargetIsPlayer && m_flAllyHealTime <= gpGlobals->curtime ) );
game/server/hl2/npc_citizen17.cpp:	m_flTimeNextHealStare = gpGlobals->curtime + sk_citizen_stare_heal_time.GetFloat();
game/server/hl2/npc_citizen17.cpp:			m_flPlayerHealTime 	= gpGlobals->curtime + timeRecharge;
game/server/hl2/npc_citizen17.cpp:			m_flAllyHealTime 	= gpGlobals->curtime + timeRecharge;
game/server/hl2/npc_citizen17.cpp:		float healAmt = ( maximumHealAmount * ( 1.0 - ( timeFullHeal - gpGlobals->curtime ) / timeRecharge ) );
game/server/hl2/npc_citizen17.cpp:			m_flPlayerGiveAmmoTime = gpGlobals->curtime + sk_citizen_giveammo_player_delay.GetFloat();
game/server/hl2/npc_citizen17.cpp:	if( gpGlobals->curtime < m_flNextHealthSearchTime )
game/server/hl2/npc_citizen17.cpp:	m_flResponseAddedTime[ iTrigger ] = gpGlobals->curtime;
game/server/hl2/npc_citizen17.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/npc_citizen17.cpp:				if ( (m_flResponseAddedTime[i] + CITIZEN_RESPONSE_GIVEUP_TIME) < gpGlobals->curtime )
game/server/hl2/npc_citizen17.cpp:				else if ( m_flNextResponseTime < gpGlobals->curtime )
game/server/hl2/npc_citizen17.cpp:						m_flNextResponseTime = gpGlobals->curtime + CITIZEN_RESPONSE_REFIRE_TIME;
game/server/hl2/npc_citizen17.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/npc_metropolice.cpp:				m_flBatonDebounceTime = gpGlobals->curtime + random->RandomFloat( 2.5f, 4.0f );
game/server/hl2/npc_metropolice.cpp:			if ( m_PolicingBehavior.IsEnabled() == false && gpGlobals->curtime > m_flBatonDebounceTime )
game/server/hl2/npc_metropolice.cpp:	if (gpGlobals->curtime > m_flRecentDamageTime + RECENT_DAMAGE_INTERVAL)
game/server/hl2/npc_metropolice.cpp:		if ( gm_flTimeLastSpokePeek != 0 && gpGlobals->curtime - gm_flTimeLastSpokePeek > 20 )
game/server/hl2/npc_metropolice.cpp:			gm_flTimeLastSpokePeek = gpGlobals->curtime;
game/server/hl2/npc_metropolice.cpp:	m_flBurstPredictTime = gpGlobals->curtime - 1.0f;
game/server/hl2/npc_metropolice.cpp:			if ( m_flBurstPredictTime <= gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:			float flPredictTime = m_flBurstPredictTime - gpGlobals->curtime;
game/server/hl2/npc_metropolice.cpp:		if ( m_flBurstPredictTime >= gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:	if ( gpGlobals->curtime <= m_flNextLostSoundTime )
game/server/hl2/npc_metropolice.cpp:	if (!(CBaseEntity*)GetEnemy() || gpGlobals->curtime - GetEnemyLastTimeSeen() > 10)
game/server/hl2/npc_metropolice.cpp:		m_flNextLostSoundTime = gpGlobals->curtime + random->RandomFloat(5.0,15.0);
game/server/hl2/npc_metropolice.cpp:	if ( gpGlobals->curtime < m_flNextPainSoundTime )
game/server/hl2/npc_metropolice.cpp:		m_flNextPainSoundTime = gpGlobals->curtime + 1;
game/server/hl2/npc_metropolice.cpp:			if ( m_flChasePlayerTime && m_flChasePlayerTime > gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:		m_flValidStitchTime = gpGlobals->curtime + random->RandomFloat( METROPOLICE_SQUAD_STITCH_MIN_INTERVAL, METROPOLICE_SQUAD_STITCH_MAX_INTERVAL );
game/server/hl2/npc_metropolice.cpp:		m_flNextLedgeCheckTime = gpGlobals->curtime;
game/server/hl2/npc_metropolice.cpp:		m_flBatonDebounceTime = gpGlobals->curtime + random->RandomFloat( 2.5f, 4.0f );
game/server/hl2/npc_metropolice.cpp:	if ( m_flValidStitchTime > gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:	if ( m_flValidStitchTime > gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:	if ( m_flNextLedgeCheckTime > gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:		m_flNextLedgeCheckTime = gpGlobals->curtime + 3.0f;
game/server/hl2/npc_metropolice.cpp:	GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + 0.5 );
game/server/hl2/npc_metropolice.cpp:	m_flBatonDebounceTime = gpGlobals->curtime + random->RandomFloat( 2.0f, 4.0f );
game/server/hl2/npc_metropolice.cpp:		m_flChasePlayerTime = gpGlobals->curtime + RandomFloat( 3, 7 );
game/server/hl2/npc_metropolice.cpp:				 ( m_flChasePlayerTime < gpGlobals->curtime ) )
game/server/hl2/npc_metropolice.cpp:		if ( m_flLastPhysicsFlinchTime + 4.0f <= gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:			m_flLastPhysicsFlinchTime = gpGlobals->curtime;
game/server/hl2/npc_metropolice.cpp:	if ( m_NPCState == NPC_STATE_COMBAT && m_flChasePlayerTime > gpGlobals->curtime )
game/server/hl2/npc_metropolice.cpp:		 ( m_flChasePlayerTime < gpGlobals->curtime ) )
game/server/hl2/npc_metropolice.cpp:		m_flNextLedgeCheckTime = gpGlobals->curtime;
game/server/hl2/npc_metropolice.cpp:		m_flTaskCompletionTime = gpGlobals->curtime + pTask->flTaskData;
game/server/hl2/npc_metropolice.cpp:			if ( gpGlobals->curtime >= m_flTaskCompletionTime )
game/server/hl2/npc_metropolice.cpp:		m_flRecentDamageTime = gpGlobals->curtime;
game/server/hl2/npc_metropolice.cpp:		if ( gpGlobals->curtime - m_flLastDamageFlinchTime < 10.0 )
game/server/hl2/npc_metropolice.cpp:		if ( (gpGlobals->curtime - GetLastAttackTime()) > 3 )
game/server/hl2/npc_metropolice.cpp:	SetLastAttackTime( gpGlobals->curtime );
game/server/hl2/weapon_brickbat.cpp:	if (gpGlobals->curtime < m_fNextThrowCheck )
game/server/hl2/weapon_brickbat.cpp:	m_fNextThrowCheck = gpGlobals->curtime + 0.33; // 1/3 second.
game/server/hl2/weapon_brickbat.cpp:	float flSequenceEndTime = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_brickbat.cpp:	float flSequenceEndTime = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_brickbat.cpp:	float flSequenceEndTime = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_brickbat.cpp:	else if ((pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_brickbat.cpp:	else if ((pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_brickbat.cpp:		//pOwner->m_flNextAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/npc_scanner.cpp:	Q_strncpy(szMapName, STRING(gpGlobals->mapname), sizeof(szMapName) );
game/server/hl2/npc_scanner.cpp:	m_fCheckCitizenTime		= gpGlobals->curtime + SCANNER_CIT_INSPECT_DELAY;
game/server/hl2/npc_scanner.cpp:	m_fCheckHintTime		= gpGlobals->curtime + SCANNER_HINT_INSPECT_DELAY;
game/server/hl2/npc_scanner.cpp:	m_fNextSpotlightTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_scanner.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_scanner.cpp:		if (((CNPC_Citizen*)pEntity)->GetNextScannerInspectTime() > gpGlobals->curtime)
game/server/hl2/npc_scanner.cpp:		for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/hl2/npc_scanner.cpp:	m_fInspectEndTime = gpGlobals->curtime + fInspectDuration;
game/server/hl2/npc_scanner.cpp:		m_fInspectEndTime = gpGlobals->curtime + fInspectDuration;
game/server/hl2/npc_scanner.cpp:	m_fInspectEndTime	= gpGlobals->curtime + fInspectDuration;
game/server/hl2/npc_scanner.cpp:		m_fInspectEndTime = gpGlobals->curtime + SCANNER_CIT_INSPECT_LENGTH;
game/server/hl2/npc_scanner.cpp:	if ( HaveInspectTarget() && gpGlobals->curtime > m_fInspectEndTime && m_nFlyMode != SCANNER_FLY_FOLLOW )
game/server/hl2/npc_scanner.cpp:		m_fCheckCitizenTime	= gpGlobals->curtime + SCANNER_CIT_INSPECT_DELAY;
game/server/hl2/npc_scanner.cpp:		m_fCheckHintTime	= gpGlobals->curtime + SCANNER_HINT_INSPECT_DELAY;
game/server/hl2/npc_scanner.cpp:	if ( gpGlobals->curtime	> m_fCheckCitizenTime && HaveInspectTarget() == false )
game/server/hl2/npc_scanner.cpp:	if ( gpGlobals->curtime > m_fCheckHintTime && HaveInspectTarget() == false )
game/server/hl2/npc_scanner.cpp:			m_fCheckHintTime = gpGlobals->curtime + SCANNER_HINT_INSPECT_DELAY;
game/server/hl2/npc_scanner.cpp:		if ( gpGlobals->curtime > m_fNextPhotographTime && HaveInspectTarget() && GetCurrentVelocity().LengthSqr() < (64*64) )
game/server/hl2/npc_scanner.cpp:					if ( gpGlobals->curtime > m_fInspectEndTime )
game/server/hl2/npc_scanner.cpp:		if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl2/npc_scanner.cpp:	if ( gpGlobals->curtime < m_fNextSpotlightTime )
game/server/hl2/npc_scanner.cpp:		m_vSpotlightTargetPos.x += noiseScale*sin(noiseMod.x * gpGlobals->curtime + noiseMod.x);
game/server/hl2/npc_scanner.cpp:		m_vSpotlightTargetPos.y += noiseScale*cos(noiseMod.y* gpGlobals->curtime + noiseMod.y);
game/server/hl2/npc_scanner.cpp:		m_vSpotlightTargetPos.z -= fabs(noiseScale*cos(noiseMod.z* gpGlobals->curtime + noiseMod.z) );
game/server/hl2/npc_scanner.cpp:		m_fNextSpotlightTime = gpGlobals->curtime + 3.0f;
game/server/hl2/npc_scanner.cpp:	m_flNextAttack	= gpGlobals->curtime + fAttackDelay;
game/server/hl2/npc_scanner.cpp:	m_fNextSpotlightTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_scanner.cpp:				pCitizen->SetNextScannerInspectTime( gpGlobals->curtime + 5.0 );
game/server/hl2/npc_scanner.cpp:				m_fInspectEndTime = gpGlobals->curtime + SCANNER_CIT_INSPECT_LENGTH;
game/server/hl2/npc_scanner.cpp:				m_fCheckCitizenTime = gpGlobals->curtime + SCANNER_CIT_INSPECT_DELAY;
game/server/hl2/npc_scanner.cpp:		m_fNextSpotlightTime = gpGlobals->curtime + 2.0;
game/server/hl2/npc_scanner.cpp:		m_vCurrentVelocity *= ( 1 + sin( ( gpGlobals->curtime + m_flFlyNoiseBase ) * 2.5f ) * .1 );
game/server/hl2/npc_scanner.cpp:	if ( m_flEngineStallTime > gpGlobals->curtime )
game/server/hl2/npc_scanner.cpp:		gpGlobals->curtime > m_fInspectEndTime)
game/server/hl2/npc_scanner.cpp:	if ((m_flLastDamageTime + SCANNER_EVADE_TIME) > gpGlobals->curtime)
game/server/hl2/npc_scanner.cpp:		gpGlobals->curtime > m_fInspectEndTime)
game/server/hl2/npc_scanner.cpp:				float fInspectTime = (((CNPC_CScanner*)pSourceEnt)->m_fInspectEndTime - gpGlobals->curtime);
game/server/hl2/npc_scanner.cpp:				float fInspectTime = (((CNPC_CScanner*)pSourceEnt)->m_fInspectEndTime - gpGlobals->curtime);
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 1 );
game/server/hl2/npc_turret.cpp:		m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl2/npc_turret.cpp:		SetNextThink( gpGlobals->curtime + .1 );
game/server/hl2/npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1f ); // turn on delay
game/server/hl2/npc_turret.cpp:		m_flPingTime = gpGlobals->curtime + 1;
game/server/hl2/npc_turret.cpp:	else if (m_flPingTime <= gpGlobals->curtime)
game/server/hl2/npc_turret.cpp:		m_flPingTime = gpGlobals->curtime + 1;
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:		m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl2/npc_turret.cpp:			m_flLastSight = gpGlobals->curtime + 0.5; // continue-shooting timeout
game/server/hl2/npc_turret.cpp:			if (gpGlobals->curtime > m_flLastSight)
game/server/hl2/npc_turret.cpp:				m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl2/npc_turret.cpp:			m_flLastSight = gpGlobals->curtime + 0.5;
game/server/hl2/npc_turret.cpp:			if (gpGlobals->curtime > m_flLastSight)
game/server/hl2/npc_turret.cpp:				m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:	m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:			SetNextThink( gpGlobals->curtime + .1 );
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp: 		if (gpGlobals->curtime > m_flLastSight)
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.2, 0.3 ) );
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:	if (m_flDamageTime + random->RandomFloat( 0, 2 ) > gpGlobals->curtime)
game/server/hl2/npc_turret.cpp:	if (m_flDamageTime + random->RandomFloat( 0, 5 ) > gpGlobals->curtime)
game/server/hl2/npc_turret.cpp:	if (m_fSequenceFinished && !MoveTurret( ) && m_flDamageTime + 5 < gpGlobals->curtime)
game/server/hl2/npc_turret.cpp:		if ( m_flDamageTime != gpGlobals->curtime || (random->RandomInt(0,10) < 1) )
game/server/hl2/npc_turret.cpp:			m_flDamageTime = gpGlobals->curtime;
game/server/hl2/npc_turret.cpp:		m_flDamageTime = gpGlobals->curtime;
game/server/hl2/npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.3; );
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.3; );
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.3; );
game/server/hl2/npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:		m_flDamageTime = gpGlobals->curtime;
game/server/hl2/npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret.cpp:	if (m_flDamageTime + random->RandomFloat( 0, 2 ) > gpGlobals->curtime)
game/server/hl2/npc_turret.cpp:	if (m_flDamageTime + random->RandomFloat( 0, 8 ) > gpGlobals->curtime)
game/server/hl2/npc_turret.cpp:	if (m_fSequenceFinished && m_flDamageTime + 5 < gpGlobals->curtime)
game/server/hl2/npc_cranedriver.cpp:					m_flReleaseAt = gpGlobals->curtime + m_flReleasePause;
game/server/hl2/npc_cranedriver.cpp:			m_flDropWait = gpGlobals->curtime + 0.5;
game/server/hl2/npc_cranedriver.cpp:			if ( m_flDropWait < gpGlobals->curtime && !m_hCrane->IsDropping() )
game/server/hl2/npc_cranedriver.cpp:			if ( gpGlobals->curtime > m_flReleaseAt )
game/server/hl2/npc_houndeye.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl2/npc_houndeye.cpp:			m_flNextAttack = gpGlobals->curtime + random->RandomFloat( 5.0, 8.0 );
game/server/hl2/npc_houndeye.cpp:				m_flNextAttack = gpGlobals->curtime + 2;
game/server/hl2/npc_houndeye.cpp:	if (gpGlobals->curtime > m_flSoundWaitTime)
game/server/hl2/npc_houndeye.cpp:		m_flSoundWaitTime = gpGlobals->curtime + 1.0;
game/server/hl2/npc_houndeye.cpp:		if (gpGlobals->curtime > m_flEndEnergyWaveTime)
game/server/hl2/npc_houndeye.cpp:		m_flSoundWaitTime = gpGlobals->curtime + 1.0;
game/server/hl2/npc_houndeye.cpp:	m_flSoundWaitTime = gpGlobals->curtime + 1.0;
game/server/hl2/npc_houndeye.cpp:	m_flEndEnergyWaveTime = gpGlobals->curtime + 1; //<> magic 
game/server/hl2/npc_houndeye.cpp:					m_flNextAttack = gpGlobals->curtime;
game/server/hl2/npc_houndeye.cpp:						m_flSoundWaitTime = gpGlobals->curtime + 1.0;
game/server/hl2/npc_houndeye.cpp:						m_flSoundWaitTime = gpGlobals->curtime + 1.0;
game/server/hl2/npc_alyx_episodic.cpp:	m_fTimeNextSearchForInteractTargets = gpGlobals->curtime;
game/server/hl2/npc_alyx_episodic.cpp:	if( !Q_strnicmp( STRING(gpGlobals->mapname), "ep2_outland_10", 14) )
game/server/hl2/npc_alyx_episodic.cpp:		GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + 0.5 );
game/server/hl2/npc_alyx_episodic.cpp:		if ( m_fStayBlindUntil < gpGlobals->curtime )
game/server/hl2/npc_alyx_episodic.cpp:				ADD_DEBUG_HISTORY( HISTORY_ALYX_BLIND, UTIL_VarArgs( "(%0.2f) Alyx: end blind scene '%s'\n", gpGlobals->curtime, STRING(m_iszCurrentBlindScene) ) );
game/server/hl2/npc_alyx_episodic.cpp:				GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + 1.0 );
game/server/hl2/npc_alyx_episodic.cpp:				m_flDontBlindUntil = gpGlobals->curtime + RandomFloat( 1, 3 );
game/server/hl2/npc_alyx_episodic.cpp:	if( m_fTimeNextSearchForInteractTargets > gpGlobals->curtime )
game/server/hl2/npc_alyx_episodic.cpp:	m_fTimeNextSearchForInteractTargets = gpGlobals->curtime + ALYX_INTERACT_SEARCH_FREQUENCY;
game/server/hl2/npc_alyx_episodic.cpp:						GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + SequenceDuration( ACT_GESTURE_FLINCH_BLAST_SHOTGUN ) + 0.5f ); // Allow another second for Alyx to bring her weapon to bear after the flinch.
game/server/hl2/npc_alyx_episodic.cpp:						GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + SequenceDuration( ACT_GESTURE_FLINCH_BLAST ) + 0.5f ); // Allow another second for Alyx to bring her weapon to bear after the flinch.
game/server/hl2/npc_alyx_episodic.cpp:		Warning( "Removed FL_FLY from Alyx, who wasn't running a script or actbusy. Time %.2f, map %s.\n", gpGlobals->curtime, STRING(gpGlobals->mapname) );
game/server/hl2/npc_alyx_episodic.cpp:			pMemory->timeFirstSeen = gpGlobals->curtime - 10.0f;
game/server/hl2/npc_alyx_episodic.cpp:			if( pEMemory->hEnemy && pEMemory->hEnemy->IsAlive() && gpGlobals->curtime - pEMemory->timeLastSeen <= 0.5f && pEMemory->hEnemy->Classify() != CLASS_BULLSEYE )
game/server/hl2/npc_alyx_episodic.cpp:				if( pEMemory->hEnemy && pEMemory->hEnemy->IsAlive() && gpGlobals->curtime - pEMemory->timeLastSeen <= 0.5f && pEMemory->hEnemy->Classify() != CLASS_BULLSEYE )
game/server/hl2/npc_alyx_episodic.cpp:			if ( ( GetEnemy()->GetEnemy() == this ) && pHC->IsJumping() && gpGlobals->curtime - GetEnemies()->FirstTimeSeen(GetEnemy()) < 0.5 )
game/server/hl2/npc_alyx_episodic.cpp:			if ( gpGlobals->curtime - GetEnemies()->FirstTimeSeen(GetEnemy()) < 0.5 )
game/server/hl2/npc_alyx_episodic.cpp:				if ( ( m_fTimeUntilNextDarknessFoundPlayer == AI_INVALID_TIME ) || ( gpGlobals->curtime < m_fTimeUntilNextDarknessFoundPlayer ) )
game/server/hl2/npc_alyx_episodic.cpp:			float flDelay = (GetTimeSpeechComplete() - gpGlobals->curtime);
game/server/hl2/npc_alyx_episodic.cpp:				m_flNextWeaponSearchTime = gpGlobals->curtime + 10.0;
game/server/hl2/npc_alyx_episodic.cpp:			m_fCombatStartTime = gpGlobals->curtime;
game/server/hl2/npc_alyx_episodic.cpp:			m_fCombatEndTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_alyx_episodic.cpp:			if ( flLastTimeSeen == AI_INVALID_TIME || gpGlobals->curtime - flLastTimeSeen > 3.0 )
game/server/hl2/npc_alyx_episodic.cpp:				m_fTimeUntilNextDarknessFoundPlayer = gpGlobals->curtime + RandomFloat( 3, 5 );
game/server/hl2/npc_alyx_episodic.cpp:				GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + SequenceDuration( ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN ) + 0.5f );
game/server/hl2/npc_alyx_episodic.cpp:				GetShotRegulator()->FireNoEarlierThan( gpGlobals->curtime + SequenceDuration( ACT_GESTURE_FLINCH_BLAST_DAMAGED ) + 0.5f );
game/server/hl2/npc_alyx_episodic.cpp:			ADD_DEBUG_HISTORY( HISTORY_ALYX_BLIND, UTIL_VarArgs( "(%0.2f) Alyx: start flashlight blind scene '%s'\n", gpGlobals->curtime, STRING(m_iszCurrentBlindScene) ) );
game/server/hl2/npc_alyx_episodic.cpp:			m_fStayBlindUntil = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_alyx_episodic.cpp:			ADD_DEBUG_HISTORY( HISTORY_ALYX_BLIND, UTIL_VarArgs( "(%0.2f) Alyx: start flare blind scene '%s'\n", gpGlobals->curtime, 
game/server/hl2/npc_alyx_episodic.cpp:			m_fStayBlindUntil = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_alyx_episodic.cpp:		if ( (gpGlobals->curtime - GetLastEnemyTime()) < 2 )
game/server/hl2/npc_alyx_episodic.cpp:	if ( gpGlobals->curtime < m_flDontBlindUntil )
game/server/hl2/npc_alyx_episodic.cpp:		m_flNextCrouchTime = gpGlobals->curtime + ALYX_CROUCH_DELAY;
game/server/hl2/npc_alyx_episodic.cpp:	if ( m_flNextCrouchTime > gpGlobals->curtime )
game/server/hl2/npc_alyx_episodic.cpp:		fLengthOfLastCombat = gpGlobals->curtime - m_fCombatStartTime;
game/server/hl2/npc_alyx_episodic.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/hl2/ai_behavior_operator.cpp:	if ( GetOuter()->GetLastEnemyTime() && (gpGlobals->curtime - GetOuter()->GetLastEnemyTime()) < 3.0 )
game/server/hl2/info_teleporter_countdown.cpp:		m_flStartTime = gpGlobals->curtime;
game/server/hl2/info_teleporter_countdown.cpp:			m_flTimeRemaining -= gpGlobals->curtime - m_flStartTime;
game/server/hl2/info_teleporter_countdown.cpp:			m_flStartTime = gpGlobals->curtime;
game/server/hl2/prop_thumper.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/prop_thumper.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/vehicle_prisoner_pod.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_prisoner_pod.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/vehicle_prisoner_pod.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/hl2/vehicle_prisoner_pod.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/hl2/weapon_lopata.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/server/hl2/weapon_lopata.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/server/hl2/weapon_lopata.cpp:	if ( ( m_bRedraw ) && ( m_flNextPrimaryAttack <= gpGlobals->curtime ) && ( m_flNextSecondaryAttack <= gpGlobals->curtime ) )
game/server/hl2/weapon_lopata.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_lopata.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_lopata.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/server/hl2/vehicle_apc.cpp:	m_flHandbrakeTime = gpGlobals->curtime + 0.1;
game/server/hl2/vehicle_apc.cpp:	m_flRocketTime = gpGlobals->curtime;
game/server/hl2/vehicle_apc.cpp:	if ( m_flDangerSoundTime > gpGlobals->curtime )
game/server/hl2/vehicle_apc.cpp:	m_flDangerSoundTime = gpGlobals->curtime + 0.3;
game/server/hl2/vehicle_apc.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_apc.cpp:			m_flAnimTime = gpGlobals->curtime;
game/server/hl2/vehicle_apc.cpp:	if ( m_flMachineGunTime > gpGlobals->curtime )
game/server/hl2/vehicle_apc.cpp:		m_flMachineGunTime = gpGlobals->curtime + MACHINE_GUN_BURST_TIME;
game/server/hl2/vehicle_apc.cpp:		m_flMachineGunTime = gpGlobals->curtime + MACHINE_GUN_BURST_PAUSE_TIME;
game/server/hl2/vehicle_apc.cpp:	if ( m_flRocketTime > gpGlobals->curtime )
game/server/hl2/vehicle_apc.cpp:	m_flRocketTime = gpGlobals->curtime + random->RandomFloat( DEATH_VOLLEY_MIN_FIRE_TIME, DEATH_VOLLEY_MAX_FIRE_TIME );
game/server/hl2/vehicle_apc.cpp:	if ( m_flRocketTime > gpGlobals->curtime )
game/server/hl2/vehicle_apc.cpp:		m_flRocketTime = gpGlobals->curtime + ROCKET_DELAY_TIME;
game/server/hl2/vehicle_apc.cpp:		m_flRocketTime = gpGlobals->curtime + random->RandomFloat( ROCKET_MIN_BURST_PAUSE_TIME, ROCKET_MAX_BURST_PAUSE_TIME );
game/server/hl2/npc_antliongrub.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_antliongrub.cpp:		m_flFlinchTime = gpGlobals->curtime + random->RandomFloat( 0.5f, 1.0f );
game/server/hl2/npc_antliongrub.cpp:		SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_antliongrub.cpp:		SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.5f, 3.0f ) );
game/server/hl2/npc_antliongrub.cpp:	SetNextThink( gpGlobals->curtime + ( time * scale ) );
game/server/hl2/npc_antliongrub.cpp:	m_flNextIdleSoundTime = gpGlobals->curtime + random->RandomFloat( 4.0f, 8.0f );
game/server/hl2/npc_antliongrub.cpp:		if ( m_flNextSquealSoundTime < gpGlobals->curtime )
game/server/hl2/npc_antliongrub.cpp:			m_flNextSquealSoundTime = gpGlobals->curtime + random->RandomFloat( 1.5f, 3.0f );
game/server/hl2/npc_antliongrub.cpp:			m_flNextIdleSoundTime = gpGlobals->curtime + random->RandomFloat( 4.0f, 8.0f );
game/server/hl2/npc_antliongrub.cpp:		if ( m_flNextIdleSoundTime < gpGlobals->curtime )
game/server/hl2/npc_antliongrub.cpp:			m_flNextIdleSoundTime = gpGlobals->curtime + random->RandomFloat( 8.0f, 12.0f );
game/server/hl2/npc_antliongrub.cpp:	if ( gpGlobals->framecount != nFrame )
game/server/hl2/npc_antliongrub.cpp:		nFrame = gpGlobals->framecount;
game/server/hl2/npc_antliongrub.cpp:		m_flNextIdleSoundTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 4.0f );
game/server/hl2/npc_antliongrub.cpp:	bool bFlinching = ( m_flFlinchTime > gpGlobals->curtime );
game/server/hl2/npc_antliongrub.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_antliongrub.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_antliongrub.cpp:	if ( m_flFlinchTime < gpGlobals->curtime )
game/server/hl2/npc_antliongrub.cpp:	m_flNextSquealSoundTime = gpGlobals->curtime;
game/server/hl2/npc_antliongrub.cpp:	m_flFlinchTime = gpGlobals->curtime + inputdata.value.Float();
game/server/hl2/npc_antliongrub.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_immolator.cpp:	m_flTimeLastUpdatedRadius = gpGlobals->curtime;
game/server/hl2/weapon_immolator.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_immolator.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 5.0;
game/server/hl2/weapon_immolator.cpp:	if( m_flNextPrimaryAttack > gpGlobals->curtime )
game/server/hl2/weapon_immolator.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/weapon_immolator.cpp:	float flDuration = gpGlobals->curtime - m_flTimeLastUpdatedRadius;
game/server/hl2/weapon_immolator.cpp:	m_flTimeLastUpdatedRadius = gpGlobals->curtime;
game/server/hl2/ai_spotlight.cpp:	if ( fabs(flAngle) > flBeamTurnRate * gpGlobals->frametime )
game/server/hl2/ai_spotlight.cpp:		flAngle = flBeamTurnRate * gpGlobals->frametime;
game/server/hl2/grenade_tripwire.cpp:	m_flPowerUp = gpGlobals->curtime + 1.2;//<<CHECK>>get rid of this
game/server/hl2/grenade_tripwire.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/grenade_tripwire.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/grenade_tripwire.cpp:	if (gpGlobals->curtime > m_flPowerUp)
game/server/hl2/grenade_tripwire.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_tripwire.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/grenade_tripwire.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_tripwire.cpp:	pGrenade->m_flDetonateTime = gpGlobals->curtime + flTargetDist/TGRENADE_LAUNCH_VEL;
game/server/hl2/grenade_tripwire.cpp:	SetNextThink( gpGlobals->curtime + 0.16f );
game/server/hl2/weapon_physcannon.cpp:	m_timeToArrive = gpGlobals->frametime;
game/server/hl2/weapon_physcannon.cpp:	m_flTimeNextObjectPurge = gpGlobals->curtime;
game/server/hl2/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/hl2/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/hl2/weapon_physcannon.cpp:	m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/hl2/weapon_physcannon.cpp:	m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	if( m_flNextPrimaryAttack > gpGlobals->curtime )
game/server/hl2/weapon_physcannon.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	if ( m_flNextSecondaryAttack > gpGlobals->curtime )
game/server/hl2/weapon_physcannon.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/hl2/weapon_physcannon.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/server/hl2/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.1f;
game/server/hl2/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.01f;
game/server/hl2/weapon_physcannon.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.4f;
game/server/hl2/weapon_physcannon.cpp:			m_flTimeForceView = gpGlobals->curtime + 1.0f;
game/server/hl2/weapon_physcannon.cpp:	if( gpGlobals->curtime >= m_flTimeNextObjectPurge )
game/server/hl2/weapon_physcannon.cpp:		m_flTimeNextObjectPurge = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	if ( m_flCheckSuppressTime > gpGlobals->curtime )
game/server/hl2/weapon_physcannon.cpp:	if ( ( m_flElementDebounce < gpGlobals->curtime ) && ( m_nChangeState == ELEMENT_STATE_NONE ) )
game/server/hl2/weapon_physcannon.cpp:		m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_physcannon.cpp:	SetContextThink( &CWeaponPhysCannon::WaitForUpgradeThink, gpGlobals->curtime + 6.0f, s_pWaitForUpgradeContext );
game/server/hl2/weapon_physcannon.cpp:		SetContextThink( &CWeaponPhysCannon::WaitForUpgradeThink, gpGlobals->curtime + 0.1f, s_pWaitForUpgradeContext );
game/server/hl2/weapon_physcannon.cpp:		GlobalEntity_Add( MAKE_STRING("super_phys_gun"), gpGlobals->mapname, GLOBAL_ON );
game/server/hl2/weapon_physcannon.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pWaitForUpgradeContext );
game/server/hl2/weapon_physcannon.cpp:				pCore->SetNextThink( gpGlobals->curtime + 10.0f );
game/server/hl2/weapon_physcannon.cpp:				m_flEndSpritesOverride[sprite] = gpGlobals->curtime + lifetime;
game/server/hl2/weapon_physcannon.cpp:		if ( ( m_flElementDebounce < gpGlobals->curtime ) && ( m_nChangeState != ELEMENT_STATE_NONE ) )
game/server/hl2/weapon_physcannon.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_physcannon.cpp:		m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/hl2/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.1f;
game/server/hl2/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/server/hl2/weapon_physcannon.cpp:			if ( m_flEndSpritesOverride[i] < gpGlobals->curtime )
game/server/hl2/weapon_physcannon.cpp:	thrown.fTimeThrown = gpGlobals->curtime;
game/server/hl2/weapon_physcannon.cpp:			else if( gpGlobals->curtime > (m_ThrownEntities[i].fTimeThrown + PHYSCANNON_THROWN_LIST_TIMEOUT) )
game/server/hl2/item_itemcrate.cpp:			pSpawn->SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_combine.cpp:	m_flNextGrenadeCheck	= gpGlobals->curtime + 1;
game/server/hl2/npc_combine.cpp:	m_flNextAltFireTime = gpGlobals->curtime;
game/server/hl2/npc_combine.cpp:	if( gpGlobals->curtime >= m_flStopMoveShootTime )
game/server/hl2/npc_combine.cpp:	float flNextAltFire = gpGlobals->curtime + flDelay;
game/server/hl2/npc_combine.cpp:	// Set this timer so that gpGlobals->curtime can't catch up to it. 
game/server/hl2/npc_combine.cpp:	// "It's OK to move and shoot until gpGlobals->curtime == m_flStopMoveShootTime"
game/server/hl2/npc_combine.cpp:		m_flStopMoveShootTime = gpGlobals->curtime + random->RandomFloat( 0.4f, 0.6f );
game/server/hl2/npc_combine.cpp:		m_flStopMoveShootTime = gpGlobals->curtime + random->RandomFloat( 0.4f, 0.6f );
game/server/hl2/npc_combine.cpp:		m_flStopMoveShootTime = gpGlobals->curtime + random->RandomFloat( 0.4f, 0.6f );
game/server/hl2/npc_combine.cpp:					(gpGlobals->curtime - m_flLastAttackTime > 3.0) )
game/server/hl2/npc_combine.cpp:					m_flLastAttackTime = gpGlobals->curtime;
game/server/hl2/npc_combine.cpp:				m_flNextAttack	= gpGlobals->curtime + pTask->flTaskData;
game/server/hl2/npc_combine.cpp:						pCombine->m_flNextGrenadeCheck = gpGlobals->curtime + 5;
game/server/hl2/npc_combine.cpp:			m_flNextAttack = gpGlobals->curtime + m_flShotDelay - 0.1;
game/server/hl2/npc_combine.cpp:			m_flLastAttackTime = gpGlobals->curtime;
game/server/hl2/npc_combine.cpp:			if ( gpGlobals->curtime >= m_flNextAttack )
game/server/hl2/npc_combine.cpp:						m_flLastAttackTime = gpGlobals->curtime;
game/server/hl2/npc_combine.cpp:						m_flNextAttack = gpGlobals->curtime + m_flShotDelay - 0.1;
game/server/hl2/npc_combine.cpp:					pWeapon->Dissolve( NULL, gpGlobals->curtime, false, ENTITY_DISSOLVE_NORMAL );
game/server/hl2/npc_combine.cpp:	if (gpGlobals->curtime < m_flNextAttack)
game/server/hl2/npc_combine.cpp:		float flTimeSinceFirstSeen = gpGlobals->curtime - GetEnemies()->FirstTimeSeen( pEnemy );
game/server/hl2/npc_combine.cpp:		if ( (pMemory && pMemory->bUnforgettable) || (GetEnemyLastTimeSeen() > (gpGlobals->curtime - 5.0)) )
game/server/hl2/npc_combine.cpp:		if ( m_flNextGrenadeCheck < gpGlobals->curtime )
game/server/hl2/npc_combine.cpp:			float flTimeEnemySeen = gpGlobals->curtime - flTimeAtFirstHand;
game/server/hl2/npc_combine.cpp:		flTime = gpGlobals->curtime - GetEnemies()->LastTimeSeen( GetEnemy() );
game/server/hl2/npc_combine.cpp:				m_flNextGrenadeCheck = gpGlobals->curtime + 6;
game/server/hl2/npc_combine.cpp:					m_flNextGrenadeCheck = gpGlobals->curtime + random->RandomFloat( 2, 5 );// wait a random amount of time before shooting again
game/server/hl2/npc_combine.cpp:					m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
game/server/hl2/npc_combine.cpp:	if ( gpGlobals->curtime > m_flNextPainSoundTime )
game/server/hl2/npc_combine.cpp:		m_flNextPainSoundTime = gpGlobals->curtime + 1;
game/server/hl2/npc_combine.cpp:	if ( gpGlobals->curtime <= m_flNextLostSoundTime )
game/server/hl2/npc_combine.cpp:	if (!(CBaseEntity*)GetEnemy() || gpGlobals->curtime - GetEnemyLastTimeSeen() > 10)
game/server/hl2/npc_combine.cpp:		m_flNextLostSoundTime = gpGlobals->curtime + random->RandomFloat(5.0,15.0);
game/server/hl2/npc_combine.cpp:	if ( gpGlobals->curtime > m_flNextAlertSoundTime )
game/server/hl2/npc_combine.cpp:		m_flNextAlertSoundTime = gpGlobals->curtime + 10.0f;
game/server/hl2/npc_combine.cpp:	if (gpGlobals->curtime < m_flNextGrenadeCheck )
game/server/hl2/npc_combine.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/npc_combine.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/npc_combine.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // 1/3 second.
game/server/hl2/npc_combine.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/npc_combine.cpp:	if( gpGlobals->curtime < m_flNextAltFireTime )
game/server/hl2/npc_combine.cpp:	if (gpGlobals->curtime < m_flNextGrenadeCheck )
game/server/hl2/npc_combine.cpp:	m_flNextGrenadeCheck = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_manhack.h:	void StopLoitering() { m_vecLoiterPosition = vec3_invalid; m_fTimeNextLoiterPulse = gpGlobals->curtime; }
game/server/hl2/npc_ichthyosaur.cpp:	m_flNextBiteTime		= gpGlobals->curtime;
game/server/hl2/npc_ichthyosaur.cpp:	m_flHoldTime			= gpGlobals->curtime;
game/server/hl2/npc_ichthyosaur.cpp:	m_flNextPingTime		= gpGlobals->curtime;
game/server/hl2/npc_ichthyosaur.cpp:	m_flNextGrowlTime		= gpGlobals->curtime;
game/server/hl2/npc_ichthyosaur.cpp:		if ( m_flHoldTime > gpGlobals->curtime )
game/server/hl2/npc_ichthyosaur.cpp:		if ( m_flNextBiteTime > gpGlobals->curtime )
game/server/hl2/npc_ichthyosaur.cpp:	lNoise = LATERAL_NOISE_MAX * sin( gpGlobals->curtime * LATERAL_NOISE_FREQ );
game/server/hl2/npc_ichthyosaur.cpp:	vNoise = VERTICAL_NOISE_MAX * sin( gpGlobals->curtime * VERTICAL_NOISE_FREQ );
game/server/hl2/npc_ichthyosaur.cpp:	if ( m_flNextBiteTime > gpGlobals->curtime )
game/server/hl2/npc_ichthyosaur.cpp:				if ( ( ( m_flHoldTime < gpGlobals->curtime ) && ( pPlayer->m_iHealth < (pPlayer->m_iMaxHealth*0.5f)) ) || ( pPlayer->GetWaterLevel() < 1 ) )
game/server/hl2/npc_ichthyosaur.cpp:		m_flNextBiteTime = gpGlobals->curtime + random->RandomFloat( 2.0f, 4.0f );
game/server/hl2/npc_ichthyosaur.cpp:	if ( m_flNextPingTime < gpGlobals->curtime )
game/server/hl2/npc_ichthyosaur.cpp:		m_flNextPingTime = gpGlobals->curtime + random->RandomFloat( 3.0f, 8.0f );
game/server/hl2/npc_ichthyosaur.cpp:	if ( ( m_NPCState == NPC_STATE_COMBAT || m_NPCState == NPC_STATE_ALERT ) && ( m_flNextGrowlTime < gpGlobals->curtime ) )
game/server/hl2/npc_ichthyosaur.cpp:		m_flNextGrowlTime = gpGlobals->curtime + random->RandomFloat( 2.0f, 6.0f );
game/server/hl2/npc_ichthyosaur.cpp:		if ( m_flHoldTime < gpGlobals->curtime )
game/server/hl2/npc_ichthyosaur.cpp:	if ( m_flHoldTime > gpGlobals->curtime )
game/server/hl2/npc_ichthyosaur.cpp:		m_flNextBiteTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_ichthyosaur.cpp:				m_flHoldTime = MAX( gpGlobals->curtime+3.0f, pPlayer->PlayerDrownTime() - 2.0f );
game/server/hl2/npc_ichthyosaur.cpp:			m_flHoldTime	= gpGlobals->curtime + 4.0f;
game/server/hl2/npc_ichthyosaur.cpp:	m_flNextBiteTime	= gpGlobals->curtime + 8.0f;
game/server/hl2/npc_ichthyosaur.cpp:	m_flHoldTime		= gpGlobals->curtime - 0.1f;
game/server/hl2/npc_ichthyosaur.cpp:	if ( m_flHoldTime > gpGlobals->curtime )
game/server/hl2/ai_behavior_police.cpp:	if ( ( m_flTargetHostileTime < gpGlobals->curtime ) && ( !m_bTargetIsHostile ) )
game/server/hl2/ai_behavior_police.cpp:		if ( m_flNextHarassTime < gpGlobals->curtime )
game/server/hl2/ai_behavior_police.cpp:	if ( m_bTargetIsHostile && m_flAggressiveTime < gpGlobals->curtime && IsCurSchedule(SCHED_CHASE_ENEMY) )
game/server/hl2/ai_behavior_police.cpp:	m_flTargetHostileTime = gpGlobals->curtime + time;
game/server/hl2/ai_behavior_police.cpp:			m_flNextHarassTime = gpGlobals->curtime + random->RandomInt( 4, 6 );
game/server/hl2/ai_behavior_police.cpp:	m_flAggressiveTime = gpGlobals->curtime + 4.0f;
game/server/hl2/ai_behavior_police.cpp:		if ( m_flNextHarassTime < gpGlobals->curtime )
game/server/hl2/ai_behavior_police.cpp:	m_flAggressiveTime = gpGlobals->curtime + 4.0f;
game/server/hl2/ai_behavior_police.cpp:	if ( m_flNextHarassTime < gpGlobals->curtime )
game/server/hl2/ai_behavior_police.cpp:	if ( ( m_flAggressiveTime >= gpGlobals->curtime ) && HasCondition( COND_CAN_MELEE_ATTACK1 ) )
game/server/hl2/ai_behavior_police.cpp:	if ( m_flAggressiveTime < gpGlobals->curtime )
game/server/hl2/npc_stalker.cpp:	if (gpGlobals->curtime > m_flNextBreatheSoundTime)
game/server/hl2/npc_stalker.cpp:		m_flNextBreatheSoundTime = gpGlobals->curtime + 3.0 + random->RandomFloat( 0.0, 5.0 );
game/server/hl2/npc_stalker.cpp:	m_flNextBreatheSoundTime	= gpGlobals->curtime + random->RandomFloat( 0.0, 10.0 );
game/server/hl2/npc_stalker.cpp:	m_flNextScrambleSoundTime	= gpGlobals->curtime + 1.5;
game/server/hl2/npc_stalker.cpp:	m_flNextBreatheSoundTime	= gpGlobals->curtime + 1.5;
game/server/hl2/npc_stalker.cpp:	m_flNextAttackSoundTime		= gpGlobals->curtime + 1.5;
game/server/hl2/npc_stalker.cpp:		if (gpGlobals->curtime > m_fBeamEndTime)
game/server/hl2/npc_stalker.cpp:		if( gpGlobals->curtime > m_flNextScreamTime )
game/server/hl2/npc_stalker.cpp:			m_flNextScreamTime = gpGlobals->curtime + random->RandomFloat( 10.0, 15.0 );
game/server/hl2/npc_stalker.cpp:			 (gpGlobals->curtime - m_flLastAttackTime > 1.0) )
game/server/hl2/npc_stalker.cpp:				m_flLastAttackTime = gpGlobals->curtime;
game/server/hl2/npc_stalker.cpp:				m_flNextScrambleSoundTime = gpGlobals->curtime + 2;
game/server/hl2/npc_stalker.cpp:				m_flNextBreatheSoundTime = gpGlobals->curtime + 2;
game/server/hl2/npc_stalker.cpp:		m_vLaserDir.x += 5*noiseScale*sin(m_fNoiseModX * gpGlobals->curtime + m_fNoiseModX);
game/server/hl2/npc_stalker.cpp:		m_vLaserDir.y += 5*noiseScale*sin(m_fNoiseModY * gpGlobals->curtime + m_fNoiseModY);
game/server/hl2/npc_stalker.cpp:		m_vLaserDir.z += 5*noiseScale*sin(m_fNoiseModZ * gpGlobals->curtime + m_fNoiseModZ);
game/server/hl2/npc_stalker.cpp:	if ( m_fBeamEndTime > gpGlobals->curtime || m_fBeamRechargeTime > gpGlobals->curtime )
game/server/hl2/npc_stalker.cpp:		m_fBeamRechargeTime = gpGlobals->curtime;
game/server/hl2/npc_stalker.cpp:	SetNextThink( gpGlobals->curtime + g_StalkerBeamThinkTime );
game/server/hl2/npc_stalker.cpp:	m_fBeamEndTime = gpGlobals->curtime + STALKER_LASER_DURATION;
game/server/hl2/npc_stalker.cpp:	if (gpGlobals->curtime >= m_flNextNPCThink)
game/server/hl2/npc_stalker.cpp:		SetNextThink( gpGlobals->curtime + g_StalkerBeamThinkTime );
game/server/hl2/npc_stalker.cpp:	if ( gpGlobals->curtime > m_nextSmokeTime )
game/server/hl2/npc_stalker.cpp:		m_nextSmokeTime = gpGlobals->curtime + 0.5;
game/server/hl2/npc_stalker.cpp:		if (gpGlobals->curtime > m_fNextDamageTime)
game/server/hl2/npc_stalker.cpp:			m_fNextDamageTime = gpGlobals->curtime + 0.1;
game/server/hl2/npc_stalker.cpp:	if ( m_flNextNPCThink > gpGlobals->curtime )
game/server/hl2/npc_stalker.cpp:	m_fBeamRechargeTime = gpGlobals->curtime + STALKER_LASER_RECHARGE;
game/server/hl2/npc_stalker.cpp:	if (gpGlobals->curtime < m_fBeamRechargeTime )
game/server/hl2/weapon_358.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.6f;
game/server/hl2/weapon_358.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.6f;
game/server/hl2/weapon_358.cpp:	pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/hl2/npc_hydra.cpp:		// m_vecHeadGoal = GetAbsOrigin( ) + Vector( sin( gpGlobals->curtime * 0.3 ) * 15, cos( gpGlobals->curtime * 0.4 ) * 150, sin( gpGlobals->curtime * 0.2 ) * 50 + dt );
game/server/hl2/npc_hydra.cpp:		else if (gpGlobals->curtime - m_flLastAdjustmentTime > 1.0)
game/server/hl2/npc_hydra.cpp:		m_flLastAdjustmentTime = gpGlobals->curtime;
game/server/hl2/npc_hydra.cpp:			m_flTaskEndTime = gpGlobals->curtime + pTask->flTaskData;
game/server/hl2/npc_hydra.cpp:			m_flTaskEndTime = gpGlobals->curtime + 0.5;
game/server/hl2/npc_hydra.cpp:			float influence = 1.0 - (m_flTaskEndTime - gpGlobals->curtime) / pTask->flTaskData;
game/server/hl2/npc_hydra.cpp:					if ( gpGlobals->curtime - m_flLastAttackTime > 4.0)
game/server/hl2/npc_hydra.cpp:			if ( gpGlobals->curtime >= m_flTaskEndTime )
game/server/hl2/npc_hydra.cpp:			if (m_flTaskEndTime <= gpGlobals->curtime)
game/server/hl2/npc_hydra.cpp:				SetLastAttackTime( gpGlobals->curtime );
game/server/hl2/npc_hydra.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_hydra.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_shotgun.cpp:		m_flReloadEnd = gpGlobals->curtime + SequenceDuration() + 0.1f; // a little past deploy animation as reloading will follow
game/server/hl2/weapon_shotgun.cpp:		m_flReloadEnd = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:		m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flReloadEnd = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:		pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_shotgun.cpp:		m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flReloadEnd = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	pOwner->m_flNextAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:		m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flReloadEnd = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 ); //suda posmitret pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
game/server/hl2/weapon_shotgun.cpp:	//m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_shotgun.cpp:	//pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
game/server/hl2/weapon_shotgun.cpp:		if (m_flReloadEnd <= gpGlobals->curtime)
game/server/hl2/weapon_shotgun.cpp:		else if (!(m_bDelayedFire1 || m_bDelayedFire2) && m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/hl2/weapon_shotgun.cpp:	if ((m_bNeedPump) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_shotgun.cpp:	if ((m_bDelayedFire2 || pOwner->m_nButtons & IN_ATTACK2) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_shotgun.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/server/hl2/weapon_shotgun.cpp:				 m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_shotgun.cpp:	else if ( (m_bDelayedFire1 || pOwner->m_nButtons & IN_ATTACK) && m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/hl2/weapon_shotgun.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/server/hl2/weapon_shotgun.cpp:				 m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_shotgun.cpp:		if ( !HasAnyAmmo() && m_flNextPrimaryAttack < gpGlobals->curtime ) 
game/server/hl2/weapon_shotgun.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 0.3;
game/server/hl2/weapon_shotgun.cpp:			if ( m_iClip1 <= 0 && !(GetWeaponFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < gpGlobals->curtime )
game/server/hl2/weapon_shotgun.cpp:	if ( ( gpGlobals->curtime - m_flHolsterTime ) > sk_auto_reload_time.GetFloat() )
game/server/hl2/weapon_shotgun.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/server/hl2/npc_playercompanion.cpp:	if ( gpGlobals->eLoadType == MapLoad_Transition )
game/server/hl2/npc_playercompanion.cpp:			 ( GetLastEnemyTime() == 0.0 || gpGlobals->curtime - GetLastEnemyTime() > 20 ) )
game/server/hl2/npc_playercompanion.cpp:		if ( (m_NPCState == NPC_STATE_COMBAT || m_NPCState == NPC_STATE_ALERT) && gpGlobals->curtime - m_flLastAttackTime < 3)
game/server/hl2/npc_playercompanion.cpp:			if ( gpGlobals->curtime - pInfo->timeLastSeen > 10 )
game/server/hl2/npc_playercompanion.cpp:							if ( pEnemyInfo->timeAtFirstHand == AI_INVALID_TIME || gpGlobals->curtime - pEnemyInfo->timeLastSeen > 10.0 )
game/server/hl2/npc_playercompanion.cpp:				if ( !pInfo || ( gpGlobals->curtime - pInfo->timeLastSeen ) > 15.0 )
game/server/hl2/npc_playercompanion.cpp:		m_flReadinessLockedUntil = gpGlobals->curtime + duration;
game/server/hl2/npc_playercompanion.cpp:	m_flReadinessLockedUntil = gpGlobals->curtime - 0.1f;
game/server/hl2/npc_playercompanion.cpp:		if ( gpGlobals->curtime - m_fLastBarrelExploded >= MAX_TIME_BETWEEN_BARRELS_EXPLODING )
game/server/hl2/npc_playercompanion.cpp:		m_fLastBarrelExploded = gpGlobals->curtime;
game/server/hl2/npc_playercompanion.cpp:		if ( gpGlobals->curtime - m_fLastPlayerKill >= MAX_TIME_BETWEEN_CONSECUTIVE_PLAYER_KILLS )
game/server/hl2/npc_playercompanion.cpp:		m_fLastPlayerKill = gpGlobals->curtime;
game/server/hl2/weapon_molotov.cpp:	if (gpGlobals->curtime < m_fNextThrowCheck )
game/server/hl2/weapon_molotov.cpp:	m_fNextThrowCheck = gpGlobals->curtime + 0.33; // 1/3 second.
game/server/hl2/weapon_molotov.cpp:	//m_flNextPrimaryAttack = gpGlobals->curtime + CurSequenceDuration();
game/server/hl2/weapon_molotov.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/server/hl2/weapon_molotov.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0;
game/server/hl2/weapon_molotov.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + 2.0;
game/server/hl2/weapon_molotov.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 2.0;
game/server/hl2/weapon_molotov.cpp:	if ((pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_molotov.cpp:	else if ((pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.3f );
game/server/hl2/weapon_rpg.cpp:	m_flGracePeriodEndsAt = gpGlobals->curtime + flGracePeriod;
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/weapon_rpg.cpp:	if ( m_flAugerTime < gpGlobals->curtime )
game/server/hl2/weapon_rpg.cpp:	if ( m_flMarkDeadTime < gpGlobals->curtime )
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_rpg.cpp:	m_flAugerTime = gpGlobals->curtime + 1.5f;
game/server/hl2/weapon_rpg.cpp:	m_flMarkDeadTime = gpGlobals->curtime + 0.75;
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_rpg.cpp:		if ( m_flGracePeriodEndsAt < gpGlobals->curtime )
game/server/hl2/weapon_rpg.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_rpg.cpp:	if ( gpGlobals->frametime > 0.0f )
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_rpg.cpp:	m_flIgnitionTime = gpGlobals->curtime + 0.3f;
game/server/hl2/weapon_rpg.cpp:	m_flIgnitionTime = gpGlobals->curtime;
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + flDelay );
game/server/hl2/weapon_rpg.cpp:	m_flAugerTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 2.0f );
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_rpg.cpp:	m_flIgnitionTime = gpGlobals->curtime;
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + flDelay );
game/server/hl2/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/weapon_rpg.cpp:	float flBlendTime = gpGlobals->curtime - m_flIgnitionTime;
game/server/hl2/weapon_rpg.cpp:			float flDeltaTime = clamp( gpGlobals->curtime - m_flReachedTargetTime, 0.0f, CORRECTION_TIME );
game/server/hl2/weapon_rpg.cpp:				m_flReachedTargetTime = gpGlobals->curtime;
game/server/hl2/weapon_rpg.cpp:	// m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_rpg.cpp:	pOwner->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/hl2/weapon_rpg.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_rpg.cpp:	if (m_bAmmoHasBeenDepleted && pPlayer->GetAmmoCount(m_iPrimaryAmmoType) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_rpg.cpp:	if (m_bJustFiredWaitForReload && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_rpg.cpp:	if (m_bInReload && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_rpg.cpp:		if ((pPlayer->m_afButtonPressed & IN_ATTACK2) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_rpg.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_rpg.cpp:	if ( m_flNextPrimaryAttack > gpGlobals->curtime )
game/server/hl2/weapon_rpg.cpp:	pLaserDot->SetContextThink( &CLaserDot::LaserThink, gpGlobals->curtime + 0.1f, g_pLaserDotThink );
game/server/hl2/weapon_rpg.cpp://	SetNextThink( gpGlobals->curtime + 0.05f, g_pLaserDotThink );
game/server/hl2/weapon_glauncher.cpp:	if (gpGlobals->curtime < m_flNextGrenadeCheck )
game/server/hl2/weapon_glauncher.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/weapon_glauncher.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/weapon_glauncher.cpp:		//m_flNextGrenadeCheck = gpGlobals->curtime;
game/server/hl2/weapon_glauncher.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 0.3; // 1/3 second.
game/server/hl2/weapon_glauncher.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl2/weapon_glauncher.cpp:	SetWeaponIdleTime(gpGlobals->curtime + 3.0f);
game/server/hl2/weapon_glauncher.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + GetBurstCycleRate();
game/server/hl2/weapon_glauncher.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + GetBurstCycleRate();
game/server/hl2/weapon_glauncher.cpp:	SetNextThink(gpGlobals->curtime + GetFireRate());
game/server/hl2/item_healthkit.cpp:		if (m_flSoundTime <= gpGlobals->curtime)
game/server/hl2/item_healthkit.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl2/item_healthkit.cpp:	SetNextThink( gpGlobals->curtime + 0.25f );
game/server/hl2/item_healthkit.cpp:	if (m_flNextCharge >= gpGlobals->curtime)
game/server/hl2/item_healthkit.cpp:		m_flSoundTime = 0.56 + gpGlobals->curtime;
game/server/hl2/item_healthkit.cpp:	if ((m_iOn == 1) && (m_flSoundTime <= gpGlobals->curtime))
game/server/hl2/item_healthkit.cpp:	m_flNextCharge = gpGlobals->curtime + 0.1;
game/server/hl2/item_healthkit.cpp:		SetNextThink( gpGlobals->curtime + m_iReactivate );
game/server/hl2/item_healthkit.cpp:		m_flPrevAnimTime = gpGlobals->curtime;
game/server/hl2/item_healthkit.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/hl2/item_healthkit.cpp:		if (m_flSoundTime <= gpGlobals->curtime)
game/server/hl2/item_healthkit.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl2/item_healthkit.cpp:	SetNextThink( gpGlobals->curtime + CHARGE_RATE );
game/server/hl2/item_healthkit.cpp:	if (m_flNextCharge >= gpGlobals->curtime)
game/server/hl2/item_healthkit.cpp:		m_flSoundTime = 0.56 + gpGlobals->curtime;
game/server/hl2/item_healthkit.cpp:	if ((m_iOn == 1) && (m_flSoundTime <= gpGlobals->curtime))
game/server/hl2/item_healthkit.cpp:	m_flNextCharge = gpGlobals->curtime + 0.1;
game/server/hl2/item_healthkit.cpp:			SetNextThink( gpGlobals->curtime + m_iReactivate );
game/server/hl2/combine_mine.cpp:	if ( gpGlobals->eLoadType == MapLoad_Transition && !m_hSprite && m_LastSpriteColor.GetRawColor() != 0 )
game/server/hl2/combine_mine.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/combine_mine.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/combine_mine.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/combine_mine.cpp:			m_flIgnoreWorldTime = gpGlobals->curtime + 1.0;
game/server/hl2/combine_mine.cpp:				SetNextThink( gpGlobals->curtime + 0.15 );
game/server/hl2/combine_mine.cpp:				SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl2/combine_mine.cpp:			SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl2/combine_mine.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/combine_mine.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/combine_mine.cpp:		SetNextThink( gpGlobals->curtime + 0.33f );
game/server/hl2/combine_mine.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/combine_mine.cpp:	float phase = fabs( sin( gpGlobals->curtime * 4.0f ) );
game/server/hl2/combine_mine.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/combine_mine.cpp:		SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl2/combine_mine.cpp:		SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl2/combine_mine.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/combine_mine.cpp:	if( m_pConstraint && gpGlobals->curtime - m_flTimeGrabbed >= 1.0f )
game/server/hl2/combine_mine.cpp:			SetNextThink( gpGlobals->curtime + m_flExplosionDelay );
game/server/hl2/combine_mine.cpp:	if( m_flIgnoreWorldTime > gpGlobals->curtime && !pOther->MyCombatCharacterPointer() )
game/server/hl2/combine_mine.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/combine_mine.cpp:	if (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime)
game/server/hl2/combine_mine.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/combine_mine.cpp:			m_flTimeGrabbed = gpGlobals->curtime;
game/server/hl2/combine_mine.cpp:		SetNextThink( gpGlobals->curtime + 0.1);
game/server/hl2/combine_mine.cpp:		m_flIgnoreWorldTime = gpGlobals->curtime + 0.1;
game/server/hl2/ai_behavior_functank.cpp:	SetBusy( gpGlobals->curtime + AI_FUNCTANK_BEHAVIOR_BUSYTIME );
game/server/hl2/ai_behavior_functank.cpp:				SetBusy( gpGlobals->curtime + AI_FUNCTANK_BEHAVIOR_BUSYTIME );
game/server/hl2/ai_behavior_functank.cpp:			GetOuter()->m_flWaitFinished = gpGlobals->curtime + FUNCTANK_FIRE_TIME;
game/server/hl2/ai_behavior_functank.cpp:			if( GetOuter()->m_flWaitFinished < gpGlobals->curtime )
game/server/hl2/ai_behavior_functank.cpp:				GetOuter()->SetLastAttackTime( gpGlobals->curtime );
game/server/hl2/ai_behavior_functank.cpp:			SetBusy( gpGlobals->curtime + AI_FUNCTANK_BEHAVIOR_BUSYTIME );
game/server/hl2/ai_behavior_functank.cpp:		SetBusy( gpGlobals->curtime + AI_FUNCTANK_BEHAVIOR_BUSYTIME );
game/server/hl2/ai_behavior_functank.cpp:		if ( gpGlobals->curtime - GetOuter()->GetEnemyLastTimeSeen() >= 3.0f )
game/server/hl2/ai_behavior_functank.cpp:		if ( pEMemory->timeValidEnemy > gpGlobals->curtime )
game/server/hl2/hl_playermove.cpp:	if ( gpGlobals->frametime != 0 )
game/server/hl2/hl_playermove.cpp:	if ( gpGlobals->frametime != 0 )
game/server/hl2/weapon_slam.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:	//	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/server/hl2/weapon_slam.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:	SetWeaponIdleTime(gpGlobals->curtime);
game/server/hl2/weapon_slam.cpp:	if (m_flWallSwitchTime > gpGlobals->curtime)
game/server/hl2/weapon_slam.cpp:				m_flWallSwitchTime = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:				m_flWallSwitchTime = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_slam.cpp:	if ((pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_slam.cpp:	else if (!m_bNeedReload && (pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_slam.cpp:		m_flWallSwitchTime = gpGlobals->curtime + 50;
game/server/hl2/weapon_slam.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/hl2/npc_strider.h:	void			NewTarget() { m_flTargetAcquiredTime = gpGlobals->curtime; }
game/server/hl2/npc_strider.h:	float 		GetBurstTimeRemaining() { return m_burstTime - gpGlobals->curtime; }
game/server/hl2/npc_PoisonZombie.cpp:		m_flNextCrabThrowTime = gpGlobals->curtime;
game/server/hl2/npc_PoisonZombie.cpp:	if ( m_flNextCrabThrowTime > gpGlobals->curtime )
game/server/hl2/npc_PoisonZombie.cpp:	if ( m_flNextCrabThrowTime > gpGlobals->curtime )
game/server/hl2/npc_PoisonZombie.cpp:		pCrab->SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_PoisonZombie.cpp:		m_flNextCrabThrowTime = gpGlobals->curtime + random->RandomInt( ZOMBIE_THROW_MIN_DELAY, ZOMBIE_THROW_MAX_DELAY );
game/server/hl2/npc_PoisonZombie.cpp:		m_flNextCrabThrowTime = gpGlobals->curtime + random->RandomInt( ZOMBIE_THROW_FIRST_MIN_DELAY, ZOMBIE_THROW_FIRST_MAX_DELAY );
game/server/hl2/npc_PoisonZombie.cpp:		 m_flNextFlinchTime = gpGlobals->curtime + random->RandomFloat( 1, 3 );
game/server/hl2/npc_PoisonZombie.cpp:	if ( m_flNextPainSoundTime <= gpGlobals->curtime )
game/server/hl2/npc_PoisonZombie.cpp:		m_flNextPainSoundTime = gpGlobals->curtime + random->RandomFloat( 4.0, 7.0 );
game/server/hl2/npc_PoisonZombie.cpp:		m_flNextMoanSound = gpGlobals->curtime;
game/server/hl2/npc_PoisonZombie.cpp:	m_flNextMoanSound = gpGlobals->curtime + duration + 9999;
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1f, 0.3f ) );
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:			SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:		m_flShotTime  = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_turret_floor.cpp:	m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_MAX_WAIT;	
game/server/hl2/npc_turret_floor.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/npc_turret_floor.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/npc_turret_floor.cpp:		m_flPlayerDropTime = gpGlobals->curtime + 2.0;
game/server/hl2/npc_turret_floor.cpp:			m_flKnockOverFailedTime = gpGlobals->curtime + 3.0;
game/server/hl2/npc_turret_floor.cpp:	if ( m_flPlayerDropTime > gpGlobals->curtime )
game/server/hl2/npc_turret_floor.cpp:		m_flShotTime = gpGlobals->curtime + random->RandomFloat( 1, 2.5 );
game/server/hl2/npc_turret_floor.cpp:		m_flShotTime = gpGlobals->curtime;
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_floor.cpp:	if ( gpGlobals->curtime > m_flLastSight )
game/server/hl2/npc_turret_floor.cpp:			m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_SHORT_WAIT;
game/server/hl2/npc_turret_floor.cpp:			m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_MAX_WAIT;
game/server/hl2/npc_turret_floor.cpp:	if ( m_flShotTime < gpGlobals->curtime && m_vecEnemyLKP != vec3_invalid )
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_floor.cpp:		m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_MAX_WAIT;
game/server/hl2/npc_turret_floor.cpp:			m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_SHORT_WAIT;
game/server/hl2/npc_turret_floor.cpp:			m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_MAX_WAIT;
game/server/hl2/npc_turret_floor.cpp:		m_flLastSight = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_turret_floor.cpp:	if ( m_flShotTime < gpGlobals->curtime )
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:			m_flShotTime  = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_turret_floor.cpp:			m_flShotTime  = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_turret_floor.cpp:		if ( gpGlobals->curtime > m_flNextActivateSoundTime )
game/server/hl2/npc_turret_floor.cpp:			m_flNextActivateSoundTime = gpGlobals->curtime + 3.0;
game/server/hl2/npc_turret_floor.cpp: 	if ( gpGlobals->curtime > m_flLastSight )
game/server/hl2/npc_turret_floor.cpp:	m_vecGoalAngles.x = GetAbsAngles().x + ( sin( gpGlobals->curtime * 1.0f ) * 15.0f );
game/server/hl2/npc_turret_floor.cpp:	m_vecGoalAngles.y = GetAbsAngles().y + ( sin( gpGlobals->curtime * 2.0f ) * 60.0f );
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.2f, 0.4f ) );
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:	if ( gpGlobals->curtime < m_flThrashTime )
game/server/hl2/npc_turret_floor.cpp:		if ( m_flShotTime < gpGlobals->curtime )
game/server/hl2/npc_turret_floor.cpp:			m_flShotTime = gpGlobals->curtime + 0.05f;
game/server/hl2/npc_turret_floor.cpp:				SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/npc_turret_floor.cpp:			SetNextThink( gpGlobals->curtime + 0.25f );
game/server/hl2/npc_turret_floor.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl2/npc_turret_floor.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_floor.cpp:			if ( m_hLastNPCToKickMe && m_flKnockOverFailedTime < gpGlobals->curtime )
game/server/hl2/npc_turret_floor.cpp:				m_flThrashTime = gpGlobals->curtime + random->RandomFloat( 2.0f, 2.5f );
game/server/hl2/npc_turret_floor.cpp:				SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:	if ( m_flPingTime > gpGlobals->curtime )
game/server/hl2/npc_turret_floor.cpp:	m_flPingTime = gpGlobals->curtime + FLOOR_TURRET_PING_TIME;
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_floor.cpp:	m_flLastSight = gpGlobals->curtime + FLOOR_TURRET_MAX_WAIT;
game/server/hl2/npc_turret_floor.cpp:	if ( IsHeldByPhyscannon( ) || (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime) )
game/server/hl2/npc_turret_floor.cpp:	if ( gpGlobals->tickcount != m_muzzleToWorldTick )
game/server/hl2/npc_turret_floor.cpp:		m_muzzleToWorldTick = gpGlobals->tickcount;
game/server/hl2/npc_turret_floor.cpp:	if ( ( gpGlobals->curtime - m_flDestructStartTime ) >= SELF_DESTRUCT_DURATION )
game/server/hl2/npc_turret_floor.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_floor.cpp:	float flDestructPerc = clamp( ( gpGlobals->curtime - m_flDestructStartTime ) / SELF_DESTRUCT_DURATION, 0.0f, 1.0f );
game/server/hl2/npc_turret_floor.cpp:	if ( gpGlobals->curtime > ( m_flPingTime + flBeepTime ) )
game/server/hl2/npc_turret_floor.cpp:		m_flPingTime = gpGlobals->curtime;
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_floor.cpp:	m_flDestructStartTime = gpGlobals->curtime;
game/server/hl2/npc_turret_floor.cpp:	m_flPingTime = gpGlobals->curtime;
game/server/hl2/npc_turret_floor.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_floor.cpp:	m_flSuspendTime = gpGlobals->curtime + time;
game/server/hl2/npc_turret_floor.cpp:	if ( m_flSuspendTime > gpGlobals->curtime )
game/server/hl2/npc_apcdriver.cpp:		m_flTimeLastSeenEnemy = gpGlobals->curtime;
game/server/hl2/npc_apcdriver.cpp:			if ( ( gpGlobals->curtime - m_flTimeLastSeenEnemy ) <= NPC_APCDRIVER_REMEMBER_TIME )
game/server/hl2/npc_apcdriver.cpp:	if ( m_pVehicleInterface->Weapon_PrimaryCanFireAt() > gpGlobals->curtime + 0.1f )
game/server/hl2/npc_apcdriver.cpp:	if ( m_pVehicleInterface->Weapon_SecondaryCanFireAt() > gpGlobals->curtime + 0.1f )
game/server/hl2/weapon_thumper.cpp:	SetNextThink( gpGlobals->curtime + thumpFrequency.GetFloat() );
game/server/hl2/weapon_thumper.cpp:	SetNextThink( gpGlobals->curtime + thumpFrequency.GetFloat() );
game/server/hl2/weapon_thumper.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/hl2/weapon_thumper.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/hl2/weapon_thumper.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_thumper.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_thumper.cpp:	m_hOwner->m_flNextAttack = gpGlobals->curtime + 0.0;
game/server/hl2/weapon_thumper.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/hl2/weapon_thumper.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/server/hl2/weapon_356.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.75;
game/server/hl2/weapon_356.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.75;
game/server/hl2/weapon_356.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/hl2/weapon_356.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_356.cpp:		if ((pOwner->m_afButtonPressed & IN_ATTACK) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_356.cpp:		if ((pOwner->m_afButtonPressed & IN_ATTACK2) && gpGlobals->curtime >= m_flNextSecondaryAttack)
game/server/hl2/weapon_356.cpp:		if ((pOwner->m_afButtonPressed & IN_RELOAD) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_alyxgun.cpp:			m_flTooCloseTimer = gpGlobals->curtime;
game/server/hl2/weapon_alyxgun.cpp:		flTime = gpGlobals->curtime - m_flTooCloseTimer;
game/server/hl2/weapon_alyxgun.cpp:	while (m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/hl2/weapon_alyxgun.cpp:	pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/hl2/weapon_alyxgun.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/npc_turret_ground.cpp:	m_flTimeNextShoot = gpGlobals->curtime;
game/server/hl2/npc_turret_ground.cpp:	m_flTimeNextPing = gpGlobals->curtime;
game/server/hl2/npc_turret_ground.cpp:		SetNextThink( gpGlobals->curtime + 0.03f );
game/server/hl2/npc_turret_ground.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_ground.cpp:	SetNextThink( gpGlobals->curtime + 1.5f );
game/server/hl2/npc_turret_ground.cpp:		SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl2/npc_turret_ground.cpp:		SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.5, 2.5 ) );
game/server/hl2/npc_turret_ground.cpp:		if( pEMemory->timeLastSeen < gpGlobals->curtime - GROUNDTURRET_RETIRE_TIME )
game/server/hl2/npc_turret_ground.cpp:		m_flTimeLastSawEnemy = gpGlobals->curtime;
game/server/hl2/npc_turret_ground.cpp:		if( gpGlobals->curtime - m_flTimeLastSawEnemy >= GROUNDTURRET_RETIRE_TIME )
game/server/hl2/npc_turret_ground.cpp:		if( m_flTimeNextShoot < gpGlobals->curtime )
game/server/hl2/npc_turret_ground.cpp:		m_flTimeNextShoot = gpGlobals->curtime + 0.2;
game/server/hl2/npc_turret_ground.cpp:		m_flTimeNextShoot = gpGlobals->curtime + 0.09;
game/server/hl2/npc_turret_ground.cpp:	if( gpGlobals->curtime >= m_flTimeNextPing )
game/server/hl2/npc_turret_ground.cpp:		m_flTimeNextPing = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_turret_ground.cpp:	scanAngle.y += (GROUNDTURRET_VIEWCONE / 2.0f) * sin( gpGlobals->curtime * 3.0f );
game/server/hl2/npc_turret_ground.cpp:	m_flTimeLastSawEnemy = gpGlobals->curtime;
game/server/hl2/npc_dog.cpp:	m_flNextSwat = gpGlobals->curtime;
game/server/hl2/npc_dog.cpp:	m_flNextRouteTime = gpGlobals->curtime;
game/server/hl2/npc_dog.cpp:	if ( m_flTimeToCatch < gpGlobals->curtime ) 
game/server/hl2/npc_dog.cpp:		if ( m_flTimeToCatch < 0.1 && m_flNextSwat <= gpGlobals->curtime )
game/server/hl2/npc_dog.cpp:		if ( m_flTimeToCatch > gpGlobals->curtime && m_hPhysicsEnt )
game/server/hl2/npc_dog.cpp:				m_flTimeToCatch = gpGlobals->curtime + dog_max_wait_time.GetFloat();
game/server/hl2/npc_dog.cpp:				m_flTimeToPull = gpGlobals->curtime + ( 1000 / vThrowDirection.Length() );
game/server/hl2/npc_dog.cpp:				m_flTimeToCatch = gpGlobals->curtime + 0.1;
game/server/hl2/npc_dog.cpp:				m_flNextRouteTime = gpGlobals->curtime + 0.3;
game/server/hl2/npc_dog.cpp:				m_flNextSwat = gpGlobals->curtime + 0.1;
game/server/hl2/npc_dog.cpp:					if ( m_flTimeToPull <= gpGlobals->curtime )
game/server/hl2/npc_dog.cpp:				if ( m_flTimeToCatch < gpGlobals->curtime && m_bDoWaitforObjectBehavior == false ) 
game/server/hl2/npc_dog.cpp:				 m_flTimeToCatch = gpGlobals->curtime + 0.1;
game/server/hl2/npc_dog.cpp:				 m_flNextRouteTime = gpGlobals->curtime + 0.3;
game/server/hl2/npc_dog.cpp:				 m_flNextSwat = gpGlobals->curtime + 0.1;
game/server/hl2/npc_dog.cpp:		m_flNextSwat = gpGlobals->curtime + pTask->flTaskData;
game/server/hl2/weapon_sos.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_sos.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration(); // +SequenceDuration();
game/server/hl2/weapon_sos.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_sos.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_sos.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_sos.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime;// +SequenceDuration();
game/server/hl2/weapon_sos.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;// +SequenceDuration();
game/server/hl2/weapon_sos.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime;// +SequenceDuration();
game/server/hl2/weapon_sos.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_sos.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_sos.cpp:	pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.1);
game/server/hl2/weapon_sos.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_sos.cpp:	pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 1.0);
game/server/hl2/weapon_sos.cpp:		else if (m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/hl2/weapon_sos.cpp:	if ((m_bNeedPump) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_sos.cpp:	if ((m_bDelayedFire2 || pOwner->m_nButtons & IN_ATTACK2) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/server/hl2/weapon_sos.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/server/hl2/weapon_sos.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_sos.cpp:	else if ((m_bDelayedFire1 || pOwner->m_nButtons & IN_ATTACK) && m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/hl2/weapon_sos.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/server/hl2/weapon_sos.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_sos.cpp:		if (!HasAnyAmmo() && m_flNextPrimaryAttack < gpGlobals->curtime)
game/server/hl2/weapon_sos.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 0.3;
game/server/hl2/weapon_sos.cpp:			if (m_iClip1 <= 0 && !(GetWeaponFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < gpGlobals->curtime)
game/server/hl2/weapon_sos.cpp:	if ((gpGlobals->curtime - m_flHolsterTime) > sk_auto_reload_time.GetFloat())
game/server/hl2/weapon_sos.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/server/hl2/cbasespriteprojectile.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_bullsquid.cpp:	m_flNextSpitTime = gpGlobals->curtime;
game/server/hl2/npc_bullsquid.cpp:	if (gpGlobals->curtime >= m_nextSquidSoundTime)
game/server/hl2/npc_bullsquid.cpp:		m_nextSquidSoundTime	= gpGlobals->curtime + random->RandomInt(1.5,3.0);
game/server/hl2/npc_bullsquid.cpp:	if ( flDist > 85 && flDist <= 784 && flDot >= 0.5 && gpGlobals->curtime >= m_flNextSpitTime )
game/server/hl2/npc_bullsquid.cpp:			m_flNextSpitTime = gpGlobals->curtime + 5;
game/server/hl2/npc_bullsquid.cpp:			m_flNextSpitTime = gpGlobals->curtime + 0.5;
game/server/hl2/npc_bullsquid.cpp:	if ( m_flHungryTime > gpGlobals->curtime )
game/server/hl2/npc_bullsquid.cpp:	if ( gpGlobals->curtime - m_flLastHurtTime <= 20 )
game/server/hl2/npc_bullsquid.cpp:	if (gpGlobals->curtime - m_flLastHurtTime < 5 && FClassnameIs(pTarget, "npc_headcrab"))
game/server/hl2/npc_bullsquid.cpp:	if ( GetEnemy() != NULL && IsMoving() && pevAttacker == GetEnemy() && gpGlobals->curtime - m_flLastHurtTime > 3 )
game/server/hl2/npc_bullsquid.cpp:		m_flLastHurtTime = gpGlobals->curtime;
game/server/hl2/npc_bullsquid.cpp:		m_flLastHurtTime = gpGlobals->curtime;
game/server/hl2/npc_bullsquid.cpp:				m_flLastAttackTime = gpGlobals->curtime;
game/server/hl2/npc_bullsquid.cpp:			m_flHungryTime = gpGlobals->curtime + pTask->flTaskData;
game/server/hl2/npc_bullsquid.cpp:	else if (m_flNextFlinch >= gpGlobals->curtime)
game/server/hl2/grenade_beam.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/grenade_beam.cpp:	if ((gpGlobals->frametime * m_pTarget->m_flBeamSpeed) > flTargetDist)
game/server/hl2/grenade_beam.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/grenade_beam.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/grenade_beam.cpp:	SetNextThink( gpGlobals->curtime + flLifetime );
game/server/hl2/grenade_beam.cpp:	m_flLaunchTime		= gpGlobals->curtime;
game/server/hl2/grenade_beam.cpp:	if (gpGlobals->curtime - m_flLastTouchTime < 0.01)
game/server/hl2/grenade_beam.cpp:	m_flLastTouchTime = gpGlobals->curtime;
game/server/hl2/grenade_beam.cpp:	if (gpGlobals->curtime - m_flLaunchTime > m_flBeamLag)
game/server/hl2/grenade_beam.cpp:	if (gpGlobals->curtime - m_flLaunchTime < m_flBeamLag) 
game/server/hl2/weapon_cguard.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime;
game/server/hl2/weapon_cguard.cpp:	m_flChargeTime			= gpGlobals->curtime;
game/server/hl2/weapon_cguard.cpp:	if ( ( m_flChargeTime < gpGlobals->curtime ) || ( m_bFired ) )
game/server/hl2/weapon_cguard.cpp:	float	angleOffset = ( 1.0f - ( m_flChargeTime - gpGlobals->curtime ) ) / 1.0f;
game/server/hl2/weapon_cguard.cpp:	if ( m_flChargeTime >= gpGlobals->curtime )
game/server/hl2/weapon_cguard.cpp:	m_flChargeTime	= gpGlobals->curtime + 1.0f;
game/server/hl2/weapon_cguard.cpp:	if ( ( m_flChargeTime < gpGlobals->curtime ) && ( m_bFired == false ) )
game/server/hl2/weapon_cguard.cpp:	if ( m_flChargeTime >= gpGlobals->curtime )
game/server/hl2/weapon_cguard.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime;
game/server/hl2/extinguisherjet.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/extinguisherjet.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_alyx.cpp:		if (gpGlobals->curtime - m_flLastAttackTime < 3 || gpGlobals->curtime - GetEnemyLastTimeSeen() < 8)
game/server/hl2/look_door.cpp:		SetNextThink( gpGlobals->curtime + 0.01f );
game/server/hl2/look_door.cpp:		pLookThinker->SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/func_recharge.cpp:		if (m_flSoundTime <= gpGlobals->curtime)
game/server/hl2/func_recharge.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl2/func_recharge.cpp:		if (m_flSoundTime <= gpGlobals->curtime)
game/server/hl2/func_recharge.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl2/func_recharge.cpp:	SetNextThink( gpGlobals->curtime + 0.25 );
game/server/hl2/func_recharge.cpp:	if (m_flNextCharge >= gpGlobals->curtime)
game/server/hl2/func_recharge.cpp:		m_flSoundTime = 0.56 + gpGlobals->curtime;
game/server/hl2/func_recharge.cpp:	if ((m_iOn == 1) && (m_flSoundTime <= gpGlobals->curtime))
game/server/hl2/func_recharge.cpp:	m_flNextCharge = gpGlobals->curtime + 0.1;
game/server/hl2/func_recharge.cpp:		SetNextThink( gpGlobals->curtime + m_iReactivate );
game/server/hl2/func_recharge.cpp:		m_flPrevAnimTime = gpGlobals->curtime;
game/server/hl2/func_recharge.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/hl2/func_recharge.cpp:		if (m_flSoundTime <= gpGlobals->curtime)
game/server/hl2/func_recharge.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl2/func_recharge.cpp:		if ( m_flSoundTime <= gpGlobals->curtime )
game/server/hl2/func_recharge.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl2/func_recharge.cpp:		if ( pActivator->GetHealth() < pActivator->GetMaxHealth() && m_flNextCharge < gpGlobals->curtime )
game/server/hl2/func_recharge.cpp:	SetNextThink( gpGlobals->curtime + CHARGE_RATE );
game/server/hl2/func_recharge.cpp:	if ( m_flNextCharge >= gpGlobals->curtime )
game/server/hl2/func_recharge.cpp:		m_flSoundTime = 0.56 + gpGlobals->curtime;
game/server/hl2/func_recharge.cpp:	if ((m_iOn == 1) && (m_flSoundTime <= gpGlobals->curtime))
game/server/hl2/func_recharge.cpp:	m_flNextCharge = gpGlobals->curtime + 0.1;
game/server/hl2/func_recharge.cpp:			SetNextThink( gpGlobals->curtime + m_iReactivate );
game/server/hl2/hl2_client.cpp:	if (gpGlobals->coop || gpGlobals->deathmatch)
game/server/hl2/hl2_client.cpp:	gpGlobals->teamplay = (teamplay.GetInt() != 0);
game/server/hl2/npc_enemyfinder.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_enemyfinder.cpp:		if ( gpGlobals->curtime - GetEnemyLastTimeSeen() >= 0.5f )
game/server/hl2/npc_enemyfinder.cpp:		m_flTimeNextHateNPC = gpGlobals->curtime;
game/server/hl2/npc_enemyfinder.cpp:	float		m_flTimeWideFOV; // If this is > gpGlobals->curtime, we have 180 degree viewcone.
game/server/hl2/npc_enemyfinder.cpp:	if( m_flTimeWideFOV > gpGlobals->curtime && !pTarget->IsPlayer() )
game/server/hl2/npc_enemyfinder.cpp:			if( gpGlobals->curtime > m_flTimeStopHateNPC )
game/server/hl2/npc_enemyfinder.cpp:				m_flTimeNextHateNPC = gpGlobals->curtime + ai_ef_hate_npc_frequency.GetFloat();
game/server/hl2/npc_enemyfinder.cpp:			if( gpGlobals->curtime > m_flTimeNextHateNPC )
game/server/hl2/npc_enemyfinder.cpp:				m_flTimeStopHateNPC = gpGlobals->curtime + ai_ef_hate_npc_duration.GetFloat();
game/server/hl2/npc_enemyfinder.cpp:	if( m_flTimeWideFOV > gpGlobals->curtime )
game/server/hl2/npc_enemyfinder.cpp:	m_flTimeWideFOV	= gpGlobals->curtime + inputdata.value.Float();
game/server/hl2/weapon_crossbow.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/weapon_crossbow.cpp:		if( GetOwnerEntity() && GetOwnerEntity()->IsPlayer() && pOther->Classify() == CLASS_PLAYER_ALLY_VITAL && FStrEq(STRING(gpGlobals->mapname), "ep2_outland_10") )
game/server/hl2/weapon_crossbow.cpp:				SetNextThink( gpGlobals->curtime + 2.0f );
game/server/hl2/weapon_crossbow.cpp:				SetNextThink( gpGlobals->curtime + 2.0f );
game/server/hl2/weapon_crossbow.cpp://		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/weapon_crossbow.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/weapon_crossbow.cpp:	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration( ACT_VM_PRIMARYATTACK ) );
game/server/hl2/weapon_crossbow.cpp:	if( FStrEq(STRING(gpGlobals->mapname), "ep2_outland_10") )
game/server/hl2/weapon_crossbow.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack	= gpGlobals->curtime + 0.75;
game/server/hl2/npc_monk.cpp:		bGunUp = (gpGlobals->curtime - m_flLastAttackTime < 4);
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1f, 0.3f ) );
game/server/hl2/npc_turret_ceiling.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_turret_ceiling.cpp:			SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_turret_ceiling.cpp:		m_flShotTime  = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_turret_ceiling.cpp:		m_flLastSight = gpGlobals->curtime + CEILING_TURRET_MAX_WAIT;	
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_ceiling.cpp:			m_flLastSight = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_turret_ceiling.cpp:		else if ( gpGlobals->curtime > m_flLastSight )
game/server/hl2/npc_turret_ceiling.cpp:	if ( m_flShotTime < gpGlobals->curtime )
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_ceiling.cpp:			m_flShotTime  = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_turret_ceiling.cpp:			m_flShotTime  = gpGlobals->curtime + 0.1f;
game/server/hl2/npc_turret_ceiling.cpp: 	if ( gpGlobals->curtime > m_flLastSight )
game/server/hl2/npc_turret_ceiling.cpp:	m_vecGoalAngles.y = GetAbsAngles().y + ( sin( gpGlobals->curtime * 2.0f ) * 45.0f );
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.2f, 0.4f ) );
game/server/hl2/npc_turret_ceiling.cpp:			m_flShotTime = gpGlobals->curtime + random->RandomFloat( 0.5, 1.5 );
game/server/hl2/npc_turret_ceiling.cpp:			m_flShotTime = gpGlobals->curtime;
game/server/hl2/npc_turret_ceiling.cpp:	if ( m_flPingTime > gpGlobals->curtime )
game/server/hl2/npc_turret_ceiling.cpp:	m_flPingTime = gpGlobals->curtime + CEILING_TURRET_PING_TIME;
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_turret_ceiling.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_spotlight.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );// keep npc thinking.
game/server/hl2/npc_spotlight.cpp:				flTimeLastSeen + 0.5 < gpGlobals->curtime)
game/server/hl2/npc_spotlight.cpp:	m_flInspectEndTime	= gpGlobals->curtime + fInspectDuration;
game/server/hl2/npc_spotlight.cpp:		m_flInspectEndTime = gpGlobals->curtime + fInspectDuration;
game/server/hl2/npc_spotlight.cpp:	m_flInspectEndTime	= gpGlobals->curtime + fInspectDuration;
game/server/hl2/npc_spotlight.cpp:				gpGlobals->curtime > m_flInspectEndTime	)
game/server/hl2/npc_spotlight.cpp:				m_flNextEntitySearchTime	= gpGlobals->curtime + SPOTLIGHT_ENTITY_INSPECT_DELAY;
game/server/hl2/npc_spotlight.cpp:				m_flNextHintSearchTime		= gpGlobals->curtime + SPOTLIGHT_HINT_INSPECT_DELAY;
game/server/hl2/npc_spotlight.cpp:			if (gpGlobals->curtime		>	m_flNextHintSearchTime	&&
game/server/hl2/npc_spotlight.cpp:					m_flNextHintSearchTime	= gpGlobals->curtime + SPOTLIGHT_HINT_INSPECT_LENGTH;
game/server/hl2/npc_spotlight.cpp:		m_flLastStateChangeTime + 30 < gpGlobals->curtime	)
game/server/hl2/npc_spotlight.cpp:	m_flNextEntitySearchTime= gpGlobals->curtime + SPOTLIGHT_ENTITY_INSPECT_DELAY;
game/server/hl2/npc_spotlight.cpp:	m_flNextHintSearchTime	= gpGlobals->curtime + SPOTLIGHT_HINT_INSPECT_DELAY;
game/server/hl2/npc_blob.cpp:	SetNextThink( gpGlobals->curtime + npc_blob_think_interval.GetFloat() );
game/server/hl2/npc_blob.cpp:	float flInterval = gpGlobals->curtime - GetLastThink();
game/server/hl2/npc_blob.cpp:			flMySine = sin( gpGlobals->curtime * pThisElement->GetSineFrequency() );
game/server/hl2/grenade_energy.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_energy.cpp:	m_flLaunchTime	= gpGlobals->curtime;
game/server/hl2/grenade_energy.cpp:	pEnergy->SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_energy.cpp:	float flLifeLeft = 1-(gpGlobals->curtime  - m_flLaunchTime)/ENERGY_GRENADE_LIFETIME;
game/server/hl2/grenade_energy.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/hl2/grenade_energy.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_energy.cpp:		float flLifeLeft = 1-(gpGlobals->curtime  - m_flLaunchTime)/ENERGY_GRENADE_LIFETIME;
game/server/hl2/weapon_ar2.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_ar2.cpp:	if (m_bShotDelayed && gpGlobals->curtime > m_flDelayedFire)
game/server/hl2/weapon_ar2.cpp:	// m_flNextPrimaryAttack = m_flNextSecondaryAttack = pOwner->m_flNextAttack = gpGlobals->curtime + SequenceDuration(); leads to impossibility
game/server/hl2/weapon_ar2.cpp:	// m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + 0.1f;
game/server/hl2/weapon_ar2.cpp:	pOwner->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/hl2/weapon_ar2.cpp:	// m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_ar2.cpp:	// m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f;
game/server/hl2/weapon_ar2.cpp:	while (m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/hl2/weapon_ar2.cpp:	//if (m_flNextPrimaryAttack >= gpGlobals->curtime)
game/server/hl2/weapon_ar2.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_ar2.cpp:	// m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flDelayedFire = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_ar2.cpp:	m_flDelayedFire = gpGlobals->curtime + 0.5f;
game/server/hl2/weapon_ar2.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f; // m_flNextPrimaryAttack and m_flNextSecondaryAttack should be set here immediately
game/server/hl2/weapon_ar2.cpp:	// m_flNextPrimaryAttack = gpGlobals->curtime + 2.7f;
game/server/hl2/ai_behavior_functank.h:	bool IsBusy( void )					{ return ( gpGlobals->curtime < m_flBusyTime ); }
game/server/hl2/grenade_molotov.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_molotov.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl2/grenade_molotov.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_bugbait.cpp:	SetNextThink( gpGlobals->curtime + duration );
game/server/hl2/npc_combines.cpp:							pAnimating->Dissolve( NULL, gpGlobals->curtime, false, ENTITY_DISSOLVE_NORMAL );
game/server/hl2/npc_BaseZombie.cpp:	m_flNextMoanSound = gpGlobals->curtime + duration + 9999;
game/server/hl2/npc_BaseZombie.cpp:		m_flBurnDamageResetTime = gpGlobals->curtime + 5;
game/server/hl2/npc_BaseZombie.cpp:		m_flNextSwat = gpGlobals->curtime + random->RandomFloat( 2, 4 );
game/server/hl2/npc_BaseZombie.cpp:			m_flNextMoanSound = gpGlobals->curtime;
game/server/hl2/npc_BaseZombie.cpp:			m_flNextSwatScan = gpGlobals->curtime + ZOMBIE_SWAT_DELAY;
game/server/hl2/npc_BaseZombie.cpp:	m_flNextSwat = gpGlobals->curtime;
game/server/hl2/npc_BaseZombie.cpp:	m_flNextSwatScan = gpGlobals->curtime;
game/server/hl2/npc_BaseZombie.cpp:	m_flNextMoanSound = gpGlobals->curtime + 9999;
game/server/hl2/npc_BaseZombie.cpp:	else if ( m_flNextFlinch >= gpGlobals->curtime )
game/server/hl2/npc_BaseZombie.cpp:		m_flNextFlinch = gpGlobals->curtime + ZOMBIE_FLINCH_DELAY;
game/server/hl2/npc_BaseZombie.cpp:		if( gpGlobals->curtime >= m_flNextSwatScan && (m_hPhysicsEnt == NULL) )
game/server/hl2/npc_BaseZombie.cpp:			m_flNextSwatScan = gpGlobals->curtime + 2.0;
game/server/hl2/npc_BaseZombie.cpp:	if( (m_hPhysicsEnt != NULL) && gpGlobals->curtime >= m_flNextSwat && HasCondition( COND_SEE_ENEMY ) && !HasCondition( COND_ZOMBIE_RELEASECRAB ) )
game/server/hl2/npc_BaseZombie.cpp:	if ( ( m_flBurnDamageResetTime ) && ( gpGlobals->curtime >= m_flBurnDamageResetTime ) )
game/server/hl2/npc_BaseZombie.cpp:		m_flNextSwat = gpGlobals->curtime + pTask->flTaskData;
game/server/hl2/npc_BaseZombie.cpp:		pCrab->SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_BaseZombie.cpp:		pCrab->m_flNextAttack = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_BaseZombie.cpp:	if ( pMoveGoal->directTrace.fStatus == AIMR_BLOCKED_ENTITY && gpGlobals->curtime >= m_flNextSwat )
game/server/hl2/ai_allymanager.cpp:	SetNextThink( gpGlobals->curtime + 1.0 );
game/server/hl2/ai_allymanager.cpp:	SetNextThink( gpGlobals->curtime + 1.0 );
game/server/hl2/npc_antlion.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/hl2/npc_antlion.cpp:	SetContextThink( NULL, gpGlobals->curtime, "ZapThink" );
game/server/hl2/npc_antlion.cpp:	return ( flLastSeenTime != 0.0f && ( gpGlobals->curtime - flLastSeenTime ) < flTime );
game/server/hl2/npc_antlion.cpp:	if ( GetNextAttack() > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:				SetNextAttack( gpGlobals->curtime + flTime + random->RandomFloat( 0.5f, 2.0f ) );
game/server/hl2/npc_antlion.cpp:				pAntlion->m_flNextJumpPushTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_antlion.cpp:				m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/hl2/npc_antlion.cpp:		m_flTimeDrownSplash = gpGlobals->curtime + random->RandomFloat( 0, 0.5 );
game/server/hl2/npc_antlion.cpp:		m_flTimeDrown = gpGlobals->curtime + 4;
game/server/hl2/npc_antlion.cpp:		m_flIdleDelay = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_antlion.cpp:			m_flBurrowTime = gpGlobals->curtime + random->RandomFloat( 1, 6 );
game/server/hl2/npc_antlion.cpp:			SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/npc_antlion.cpp:		if ( gpGlobals->curtime > m_flTimeDrownSplash )
game/server/hl2/npc_antlion.cpp:			m_flTimeDrownSplash = gpGlobals->curtime + random->RandomFloat( 0.5, 2.5 );
game/server/hl2/npc_antlion.cpp:		if ( gpGlobals->curtime > m_flTimeDrown )
game/server/hl2/npc_antlion.cpp:		if ( ( m_flIdleDelay > gpGlobals->curtime ) || GetEntityName() != NULL_STRING )
game/server/hl2/npc_antlion.cpp:		if ( m_flBurrowTime > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:		m_flBurrowTime = gpGlobals->curtime + random->RandomFloat( 0.5f, 1.0f );
game/server/hl2/npc_antlion.cpp:		if ( m_flBurrowTime < gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:		 && GetNavType() != NAV_JUMP && m_flNextJumpPushTime <= gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:						pAntlion->m_flNextJumpPushTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_antlion.cpp:	if ( m_flJumpTime > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:		m_flJumpTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 2.0f );		
game/server/hl2/npc_antlion.cpp:		m_flJumpTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 2.0f );
game/server/hl2/npc_antlion.cpp:	if ( m_flZapDuration > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:		SetContextThink( &CNPC_Antlion::ZapThink, gpGlobals->curtime + random->RandomFloat( 0.05f, 0.25f ), "ZapThink" );
game/server/hl2/npc_antlion.cpp:		SetContextThink( NULL, gpGlobals->curtime, "ZapThink" );
game/server/hl2/npc_antlion.cpp:		if ( m_flZapDuration > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:			SetContextThink( &CNPC_Antlion::ZapThink, gpGlobals->curtime, "ZapThink" );
game/server/hl2/npc_antlion.cpp:		if ( m_flNextAcknowledgeTime < gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:			m_flNextAcknowledgeTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_antlion.cpp:		m_flIdleDelay = gpGlobals->curtime + 4.0f;
game/server/hl2/npc_antlion.cpp:					m_flPounceTime = gpGlobals->curtime + 1.5f;
game/server/hl2/npc_antlion.cpp:					SetNextAttack( gpGlobals->curtime + random->RandomFloat( 2.0f, 4.0f ) );
game/server/hl2/npc_antlion.cpp:					SetNextAttack( gpGlobals->curtime + random->RandomFloat( 2.0f, 4.0f ) );
game/server/hl2/npc_antlion.cpp:						SetNextAttack( gpGlobals->curtime + random->RandomFloat( 0.5f, 2.5f ) );
game/server/hl2/npc_antlion.cpp:					m_flPounceTime = gpGlobals->curtime + 1.5f;
game/server/hl2/npc_antlion.cpp:	if ( gpGlobals->curtime - m_flLastDamageTime < 0.5f )
game/server/hl2/npc_antlion.cpp:	m_flLastDamageTime = gpGlobals->curtime;
game/server/hl2/npc_antlion.cpp:	m_flIdleDelay = gpGlobals->curtime + 4.0f;
game/server/hl2/npc_antlion.cpp:	if ( m_flIdleDelay > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:	if ( GetNextAttack() > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:	if ( m_flPounceTime > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:		m_flPounceTime = gpGlobals->curtime + 0.2f;
game/server/hl2/npc_antlion.cpp:		m_flPounceTime = gpGlobals->curtime + 0.2f;
game/server/hl2/npc_antlion.cpp:		m_flBurrowTime = gpGlobals->curtime + random->RandomFloat( 0.5f, 1.0f );
game/server/hl2/npc_antlion.cpp:			SetNextAttack( gpGlobals->curtime + flDuration );
game/server/hl2/npc_antlion.cpp:	m_flJumpTime = gpGlobals->curtime + random->RandomInt( 2, 6 );
game/server/hl2/npc_antlion.cpp:		if ( m_flObeyFollowTime > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:	if ( m_flSuppressFollowTime > gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:		m_flSuppressFollowTime = gpGlobals->curtime + random->RandomInt( 5, 10 );
game/server/hl2/npc_antlion.cpp:	m_flObeyFollowTime = gpGlobals->curtime + ANTLION_OBEY_FOLLOW_TIME;
game/server/hl2/npc_antlion.cpp:	if ( m_flNextAcknowledgeTime < gpGlobals->curtime )
game/server/hl2/npc_antlion.cpp:		m_flNextAcknowledgeTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_antlion.cpp:		m_flSuppressFollowTime = gpGlobals->curtime + random->RandomInt( 10, 15 );
game/server/hl2/npc_antlion.cpp:		m_flZapDuration = gpGlobals->curtime + SequenceDuration( SelectWeightedSequence( (Activity) ACT_ANTLION_ZAP_FLIP) ) + 0.1f;
game/server/hl2/grenade_tripmine.cpp:	m_flPowerUp = gpGlobals->curtime + 2.0;
game/server/hl2/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl2/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/grenade_tripmine.cpp:	if (gpGlobals->curtime > m_flPowerUp)
game/server/hl2/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_tripmine.cpp:	if (gpGlobals->curtime < m_flPowerUp && info.GetDamage() < m_iHealth)
game/server/hl2/grenade_tripmine.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl2/weapon_annabelle.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_annabelle.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_annabelle.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/server/hl2/weapon_annabelle.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_annabelle.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_annabelle.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_annabelle.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_annabelle.cpp:	if ((gpGlobals->curtime - m_flHolsterTime) > sk_auto_reload_time.GetFloat())
game/server/hl2/weapon_annabelle.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/server/hl2/weapon_annabelle.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/server/hl2/weapon_annabelle.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.4f;
game/server/hl2/weapon_annabelle.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.4f;
game/server/hl2/weapon_annabelle.cpp:	pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/hl2/weapon_annabelle.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_annabelle.cpp:		if ((pOwner->m_afButtonPressed & IN_ATTACK) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_annabelle.cpp:		if ((pOwner->m_afButtonPressed & IN_ATTACK2) && gpGlobals->curtime >= m_flNextSecondaryAttack)
game/server/hl2/weapon_annabelle.cpp:		if ((pOwner->m_afButtonPressed & IN_RELOAD) && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/env_speaker.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/env_speaker.cpp:		SetNextThink( gpGlobals->curtime + random->RandomFloat(5.0, 15.0) );
game/server/hl2/env_speaker.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat(m_delayMin, m_delayMax) );
game/server/hl2/env_speaker.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/env_speaker.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/antlion_maker.cpp:		if ( m_bDisabled == false && gpGlobals->eLoadType != MapLoad_LoadGame )
game/server/hl2/antlion_maker.cpp:			SetContextThink( &CAntlionTemplateMaker::PoolRegenThink, gpGlobals->curtime + m_flPoolRegenTime, s_pPoolThinkContext );
game/server/hl2/antlion_maker.cpp:				SetContextThink( &CAntlionTemplateMaker::FindNodesCloseToPlayer, gpGlobals->curtime + 1.0f, s_pBlockedEffectsThinkContext );
game/server/hl2/antlion_maker.cpp:		SetContextThink( &CAntlionTemplateMaker::PoolRegenThink, gpGlobals->curtime + m_flPoolRegenTime, s_pPoolThinkContext );
game/server/hl2/antlion_maker.cpp:		SetContextThink( &CAntlionTemplateMaker::FindNodesCloseToPlayer, gpGlobals->curtime + 1.0f, s_pBlockedEffectsThinkContext );
game/server/hl2/antlion_maker.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pPoolThinkContext );
game/server/hl2/antlion_maker.cpp:	SetContextThink( NULL, gpGlobals->curtime, s_pBlockedEffectsThinkContext );
game/server/hl2/antlion_maker.cpp:				SetContextThink( &CAntlionTemplateMaker::BlockedCheckFunc, gpGlobals->curtime + 2.0f, s_pBlockedCheckContext );
game/server/hl2/antlion_maker.cpp:			m_flBlockedBumpTime = gpGlobals->curtime + random->RandomFloat( 1.75, 2.75 );
game/server/hl2/antlion_maker.cpp:	SetContextThink( &CAntlionTemplateMaker::FindNodesCloseToPlayer, gpGlobals->curtime + random->RandomFloat( 0.75, 1.75 ), s_pBlockedEffectsThinkContext );
game/server/hl2/antlion_maker.cpp:		SetContextThink( NULL, gpGlobals->curtime, s_pPoolThinkContext );
game/server/hl2/antlion_maker.cpp:		SetContextThink( &CAntlionTemplateMaker::PoolRegenThink, gpGlobals->curtime + m_flPoolRegenTime, s_pPoolThinkContext );
game/server/hl2/antlion_maker.cpp:		SetContextThink( NULL, gpGlobals->curtime, s_pPoolThinkContext );
game/server/hl2/antlion_maker.cpp:	SetContextThink( &CAntlionTemplateMaker::PoolRegenThink, gpGlobals->curtime + m_flPoolRegenTime, s_pPoolThinkContext );
game/server/hl2/antlion_maker.cpp:			float flTimeRemaining = GetNextThink( s_pPoolThinkContext ) - gpGlobals->curtime;
game/server/hl2/hl2_player.h:	virtual void		SuspendUse( float flDuration ) { m_flTimeUseSuspended = gpGlobals->curtime + flDuration; }
game/server/hl2/hl2_player.h:	void StartArmorReduction( void ) { m_flArmorReductionTime = gpGlobals->curtime + ARMOR_DECAY_TIME; 
game/server/hl2/proto_sniper.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/proto_sniper.cpp:	SetNextThink( gpGlobals->curtime + 0.02 );
game/server/hl2/proto_sniper.cpp:	flElapsedTime = flTime - (GetWaitFinishTime() - gpGlobals->curtime);
game/server/hl2/proto_sniper.cpp:	vecCurrentDir.x += flNoiseScale * ( sin( 3 * M_PI * gpGlobals->curtime ) * 0.0006 );
game/server/hl2/proto_sniper.cpp:	vecCurrentDir.y += flNoiseScale * ( sin( 2 * M_PI * gpGlobals->curtime + 0.5 * M_PI ) * 0.0006 );
game/server/hl2/proto_sniper.cpp:	vecCurrentDir.z += flNoiseScale * ( sin( 1.5 * M_PI * gpGlobals->curtime + M_PI ) * 0.0006 );
game/server/hl2/proto_sniper.cpp:	fFrustration = gpGlobals->curtime - m_flFrustration;
game/server/hl2/proto_sniper.cpp:	m_flFrustration = gpGlobals->curtime;
game/server/hl2/proto_sniper.cpp:				if( gpGlobals->curtime - m_flTimeLastAttackedPlayer <= SNIPER_FASTER_ATTACK_PERIOD )
game/server/hl2/proto_sniper.cpp:				m_flTimeLastAttackedPlayer = gpGlobals->curtime;
game/server/hl2/proto_sniper.cpp:		SetNextThink( gpGlobals->curtime + 0.03 );
game/server/hl2/proto_sniper.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/proto_sniper.cpp:		if( gpGlobals->curtime - GetEnemies()->LastTimeSeen( GetEnemy() ) > 30 )
game/server/hl2/proto_sniper.cpp:	float flTimeSinceLastMiss = gpGlobals->curtime - m_flTimeLastShotMissed;
game/server/hl2/proto_sniper.cpp:	if( (pPlayer->GetFlags() & FL_DUCKING) && pPlayer->MuzzleFlashTime() > gpGlobals->curtime )
game/server/hl2/proto_sniper.cpp:	m_flTimeLastShotMissed = gpGlobals->curtime;
game/server/hl2/proto_sniper.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/proto_sniper.cpp:	if( gpGlobals->curtime >= m_SoundTime )
game/server/hl2/proto_sniper.cpp:	flInterval = gpGlobals->curtime - GetLastThink();
game/server/hl2/proto_sniper.cpp:	m_flLastThink = gpGlobals->curtime;
game/server/hl2/proto_sniper.cpp:	m_SoundTime = gpGlobals->curtime + flElapsedTime * 0.5;
game/server/hl2/proto_sniper.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/proto_sniper.cpp:		// Never let gpGlobals->curtime get added to the elapsed time!
game/server/hl2/proto_sniper.cpp:		m_ImpactTime[ i ] += gpGlobals->curtime;
game/server/hl2/proto_sniper.cpp:	SetNextThink( gpGlobals->curtime + 1.0 );
game/server/hl2/npc_launcher.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_launcher.cpp:	m_flNextAttack = gpGlobals->curtime + LAUNCHER_REST_TIME;
game/server/hl2/npc_launcher.cpp:	if (gpGlobals->curtime > m_flNextAttack)
game/server/hl2/npc_launcher.cpp:			m_flNextAttack = gpGlobals->curtime + m_nLaunchDelay;
game/server/hl2/npc_launcher.cpp:				m_flNextAttack = gpGlobals->curtime + m_nLaunchDelay;
game/server/hl2/npc_launcher.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/weapon_pistol.cpp:	m_flSoonestPrimaryAttack = gpGlobals->curtime;
game/server/hl2/weapon_pistol.cpp:	m_flSoonestPrimaryAttack	= gpGlobals->curtime + PISTOL_FASTEST_DRY_REFIRE_TIME;
game/server/hl2/weapon_pistol.cpp:	m_flNextPrimaryAttack		= gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_pistol.cpp:	if ( ( gpGlobals->curtime - m_flLastAttackTime ) > 0.5f )
game/server/hl2/weapon_pistol.cpp:	m_flLastAttackTime = gpGlobals->curtime;
game/server/hl2/weapon_pistol.cpp:	m_flSoonestPrimaryAttack = gpGlobals->curtime + PISTOL_FASTEST_REFIRE_TIME;
game/server/hl2/weapon_pistol.cpp:	if ( ( ( pOwner->m_nButtons & IN_ATTACK ) == false ) && ( m_flSoonestPrimaryAttack < gpGlobals->curtime ) )
game/server/hl2/weapon_pistol.cpp:		m_flAccuracyPenalty -= gpGlobals->frametime;
game/server/hl2/weapon_pistol.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/hl2/weapon_pistol.cpp:	if ( ( ( pOwner->m_nButtons & IN_ATTACK ) == false ) && ( m_flSoonestPrimaryAttack < gpGlobals->curtime ) )
game/server/hl2/weapon_pistol.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime - 0.1f;
game/server/hl2/weapon_pistol.cpp:	else if ( ( pOwner->m_nButtons & IN_ATTACK ) && ( m_flNextPrimaryAttack < gpGlobals->curtime ) && ( m_iClip1 <= 0 ) )
game/server/hl2/weapon_pistol.cpp:		SetNextThink(gpGlobals->curtime + 5.2);
game/server/hl2/npc_basescanner.cpp:	m_flNextAttack = gpGlobals->curtime;
game/server/hl2/npc_basescanner.cpp:		if ( gpGlobals->curtime >= m_flNextAttack )
game/server/hl2/npc_basescanner.cpp:	if (m_flNextAttack > gpGlobals->curtime)
game/server/hl2/npc_basescanner.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/npc_basescanner.cpp:		SetNextThink( gpGlobals->curtime + 0.01f );
game/server/hl2/npc_basescanner.cpp:		m_flEngineStallTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_basescanner.cpp:	m_flLastPhysicsInfluenceTime = gpGlobals->curtime;
game/server/hl2/npc_basescanner.cpp:		m_flEngineStallTime = gpGlobals->curtime + 2.0f;
game/server/hl2/npc_basescanner.cpp:		SetNextThink( gpGlobals->curtime + 0.01f );
game/server/hl2/npc_basescanner.cpp:	if ( IsHeldByPhyscannon( ) || (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime) )
game/server/hl2/npc_basescanner.cpp:		float flLerpFactor = (gpGlobals->curtime - m_flLastPhysicsInfluenceTime) / SCANNER_SMASH_TIME;
game/server/hl2/npc_basescanner.cpp:	if ((m_flLastDamageTime + SCANNER_EVADE_TIME) > gpGlobals->curtime)
game/server/hl2/npc_basescanner.cpp:	if ( m_flEngineStallTime > gpGlobals->curtime )
game/server/hl2/npc_basescanner.cpp:				SetContextThink( &CNPC_BaseScanner::DiveBombSoundThink, gpGlobals->curtime + 0.5f, s_pDiveBombSoundThinkContext );
game/server/hl2/npc_basescanner.cpp:	SetContextThink( &CNPC_BaseScanner::DiveBombSoundThink, gpGlobals->curtime + 2.0f * TICK_INTERVAL, s_pDiveBombSoundThinkContext );
game/server/hl2/weapon_flaregun.cpp:		float flDieTime = (pFlare->m_flTimeBurnOut - gpGlobals->curtime) - flKillTime;
game/server/hl2/weapon_flaregun.cpp:			pOwnerEntity->SetNextThink(gpGlobals->curtime + flDieTime + 3.0f);
game/server/hl2/weapon_flaregun.cpp:	m_flNextDamage = gpGlobals->curtime;
game/server/hl2/weapon_flaregun.cpp:	m_flTimeBurnOut = gpGlobals->curtime + 10;
game/server/hl2/weapon_flaregun.cpp:	pFlare->SetNextThink(gpGlobals->curtime + 0.5f);
game/server/hl2/weapon_flaregun.cpp:	pFlare->m_flTimeBurnOut = gpGlobals->curtime + lifetime;
game/server/hl2/weapon_flaregun.cpp:	float	deltaTime = (m_flTimeBurnOut - gpGlobals->curtime);
game/server/hl2/weapon_flaregun.cpp:		if (m_flTimeBurnOut < gpGlobals->curtime)
game/server/hl2/weapon_flaregun.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/hl2/weapon_flaregun.cpp:	if (pOther && pOther->m_takedamage && (m_flNextDamage < gpGlobals->curtime))
game/server/hl2/weapon_flaregun.cpp:		m_flNextDamage = gpGlobals->curtime + 1.0f;
game/server/hl2/weapon_flaregun.cpp:		m_flNextDamage = gpGlobals->curtime + 1.0f;
game/server/hl2/weapon_flaregun.cpp:		m_flTimeBurnOut = gpGlobals->curtime + lifeTime;
game/server/hl2/weapon_flaregun.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/hl2/weapon_flaregun.cpp:	m_flTimeBurnOut = gpGlobals->curtime + fadeTime;
game/server/hl2/weapon_flaregun.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/hl2/weapon_flaregun.cpp:		pOwner->m_flNextAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_flaregun.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime + 1;
game/server/hl2/weapon_flaregun.cpp:		pOwner->m_flNextAttack = gpGlobals->curtime + SequenceDuration();
game/server/hl2/weapon_flaregun.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime + 1;
game/server/hl2/npc_playercompanion.h:	bool			IsReadinessLocked() { return gpGlobals->curtime < m_flReadinessLockedUntil; }
game/server/hl2/npc_zombie.cpp:	m_flNextMoanSound = gpGlobals->curtime + random->RandomFloat( 1.0, 4.0 );
game/server/hl2/npc_zombie.cpp:  	if( gpGlobals->curtime > m_flNextMoanSound )
game/server/hl2/npc_zombie.cpp:  			m_flNextMoanSound = gpGlobals->curtime + random->RandomFloat( 2.0, 5.0 );
game/server/hl2/npc_zombie.cpp:  			m_flNextMoanSound = gpGlobals->curtime + random->RandomFloat( 1.0, 2.0 );
game/server/hl2/npc_zombie.cpp:		m_flNextMoanSound = gpGlobals->curtime + random->RandomFloat( 2.0, 4.0 );
game/server/hl2/weapon_ar1.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.1;
game/server/hl2/npc_rollermine.cpp:	bool	IsShocking() { return gpGlobals->curtime < m_flShockTime ? true : false; }
game/server/hl2/npc_rollermine.cpp:		if ( m_bHackedByAlyx && ( m_flPowerDownDetonateTime > 0.0f && m_flPowerDownDetonateTime <= gpGlobals->curtime ) )
game/server/hl2/npc_rollermine.cpp:		return gpGlobals->curtime > m_flGoIdleTime ? true : false;
game/server/hl2/npc_rollermine.cpp:	bool	IsActive() { return m_flActiveTime > gpGlobals->curtime ? false : true; }
game/server/hl2/npc_rollermine.cpp:				m_flGoIdleTime = gpGlobals->curtime + 10;
game/server/hl2/npc_rollermine.cpp:			m_flChargeTime = gpGlobals->curtime;
game/server/hl2/npc_rollermine.cpp:			flTorqueFactor = 1 + (gpGlobals->curtime - m_flChargeTime) * 2;
game/server/hl2/npc_rollermine.cpp:					if( gpGlobals->curtime - m_flChargeTime > 1.0 && flTorqueFactor > 1 &&  flDot < 0.0 )
game/server/hl2/npc_rollermine.cpp:			flTorqueFactor = 1 + (gpGlobals->curtime - m_flChargeTime) * 2;
game/server/hl2/npc_rollermine.cpp:			if ( m_flPowerDownTime <= gpGlobals->curtime )
game/server/hl2/npc_rollermine.cpp:				m_flNextHop = gpGlobals->curtime;
game/server/hl2/npc_rollermine.cpp:				m_flPowerDownTime = gpGlobals->curtime + RandomFloat( 0.3, 0.9 );
game/server/hl2/npc_rollermine.cpp:			if ( m_flPowerDownDetonateTime <= gpGlobals->curtime )
game/server/hl2/npc_rollermine.cpp:				SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl2/npc_rollermine.cpp:	if ( m_bHeld || m_hVehicleStuckTo || gpGlobals->curtime < m_flShockTime )
game/server/hl2/npc_rollermine.cpp:	m_flActiveTime = gpGlobals->curtime + GetStunDelay();
game/server/hl2/npc_rollermine.cpp:	m_flShockTime = gpGlobals->curtime + 1.25;
game/server/hl2/npc_rollermine.cpp:		aRollersOnVehicle[i]->PreventUnstickUntil( gpGlobals->curtime + 1 );
game/server/hl2/npc_rollermine.cpp:	if ( m_flPreventUnstickUntil > gpGlobals->curtime )
game/server/hl2/npc_rollermine.cpp:	m_flActiveTime = gpGlobals->curtime + GetStunDelay();
game/server/hl2/npc_rollermine.cpp:		aRollersOnVehicle[i]->PreventUnstickUntil( gpGlobals->curtime + 1 );
game/server/hl2/npc_rollermine.cpp:	m_flPowerDownTime = gpGlobals->curtime + RandomFloat( 0.1, 0.5 );
game/server/hl2/npc_rollermine.cpp:		m_flActiveTime = gpGlobals->curtime + GetStunDelay();
game/server/hl2/npc_rollermine.cpp:	m_flActiveTime = gpGlobals->curtime + GetStunDelay();
game/server/hl2/npc_rollermine.cpp:			SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1f, 0.5f ) );
game/server/hl2/npc_rollermine.cpp:			m_flActiveTime = gpGlobals->curtime + GetStunDelay();
game/server/hl2/npc_rollermine.cpp:	if ( m_flNextHop > gpGlobals->curtime )
game/server/hl2/npc_rollermine.cpp:		m_flNextHop = gpGlobals->curtime + ROLLERMINE_HOP_DELAY;
game/server/hl2/npc_rollermine.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl2/npc_rollermine.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_strider.cpp:	m_flTimeNextHuntSound = gpGlobals->curtime - 1.0f;
game/server/hl2/npc_strider.cpp:		m_nextStompTime = gpGlobals->curtime + 5;
game/server/hl2/npc_strider.cpp:		angles.x = gpGlobals->curtime * 20.0f;
game/server/hl2/npc_strider.cpp:				m_flTimeNextHuntSound = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_strider.cpp:				if( gpGlobals->curtime >= m_flTimeNextHuntSound && !m_pMinigun->IsShooting() )
game/server/hl2/npc_strider.cpp:				float flTimeSuppressed = gpGlobals->curtime - m_flTimePlayerMissileDetected;
game/server/hl2/npc_strider.cpp:						if( pEMemory->timeLastSeen == gpGlobals->curtime )
game/server/hl2/npc_strider.cpp:				if( GetEnemy() && m_pMinigun->IsShooting() && GetTimeEnemyAcquired() != gpGlobals->curtime )
game/server/hl2/npc_strider.cpp:							GetEnemies()->SetTimeValidEnemy( GetEnemy(), gpGlobals->curtime + ( STRIDER_IGNORE_TARGET_DURATION * m_iVisibleEnemies ) );
game/server/hl2/npc_strider.cpp:			if ( m_hRagdoll.Get() && (gpGlobals->curtime > m_ragdollTime  || HasCondition( COND_STRIDER_DO_FLICK ) ) )
game/server/hl2/npc_strider.cpp:			if ( gpGlobals->curtime - GetEnemyLastTimeSeen() < TIME_CARE_ENEMY )
game/server/hl2/npc_strider.cpp:			m_nextStompTime = gpGlobals->curtime + 5;
game/server/hl2/npc_strider.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_strider.cpp:		m_flTimePlayerMissileDetected = gpGlobals->curtime;
game/server/hl2/npc_strider.cpp:	if (gpGlobals->curtime < m_nextStompTime)
game/server/hl2/npc_strider.cpp:	if( ( gpGlobals->curtime - m_flTimeLastAlertSound ) > 2.0f )
game/server/hl2/npc_strider.cpp:		m_flTimeLastAlertSound = gpGlobals->curtime;
game/server/hl2/npc_strider.cpp:		m_flTimeNextHuntSound = gpGlobals->curtime + random->RandomFloat( 8.0f, 12.0f );
game/server/hl2/npc_strider.cpp:		float timeSinceSeenEnemy = gpGlobals->curtime - GetEnemyLastTimeSeen();
game/server/hl2/npc_strider.cpp:	if (!IsMoving() && m_doTurn > 180.0f && m_flNextTurnAct < gpGlobals->curtime )
game/server/hl2/npc_strider.cpp:				m_flNextTurnAct = gpGlobals->curtime + GetLayerDuration( iLayer );
game/server/hl2/npc_strider.cpp:				m_flNextTurnAct = gpGlobals->curtime + 0.5;
game/server/hl2/npc_strider.cpp:	if ( GetNextThink( "CANNON_HIT" ) > gpGlobals->curtime )
game/server/hl2/npc_strider.cpp:	m_nextShootTime = gpGlobals->curtime + 5;
game/server/hl2/npc_strider.cpp:	SetContextThink( &CNPC_Strider::CannonHitThink, gpGlobals->curtime + 0.2f, "CANNON_HIT" );
game/server/hl2/npc_strider.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/npc_strider.cpp:		m_ragdollTime = gpGlobals->curtime + 10;
game/server/hl2/npc_strider.cpp:	m_nextTwitchTime = gpGlobals->curtime;
game/server/hl2/npc_strider.cpp:	m_burstTime = gpGlobals->curtime;
game/server/hl2/npc_strider.cpp:	m_nextBulletTime = gpGlobals->curtime;
game/server/hl2/npc_strider.cpp:	m_burstTime = gpGlobals->curtime + duration;
game/server/hl2/npc_strider.cpp:	m_burstTime = gpGlobals->curtime + timeExtend;
game/server/hl2/npc_strider.cpp:	m_burstTime = gpGlobals->curtime + duration;
game/server/hl2/npc_strider.cpp:	m_nextTwitchTime = gpGlobals->curtime + random->RandomFloat( 2.0, 4.0 );
game/server/hl2/npc_strider.cpp:	if( gpGlobals->curtime < m_burstTime )
game/server/hl2/npc_strider.cpp:					float flTimeSinceLastSeen = gpGlobals->curtime - pStrider->GetEnemies()->LastTimeSeen(pTargetEnt);
game/server/hl2/npc_strider.cpp:	if ( !GetTarget() && m_nextTwitchTime <= gpGlobals->curtime )
game/server/hl2/npc_strider.cpp:		m_nextTwitchTime = gpGlobals->curtime + random->RandomFloat( 0.3, 2 );
game/server/hl2/npc_strider.cpp:		if( gpGlobals->curtime > m_burstTime || !pTargetEnt )
game/server/hl2/npc_strider.cpp:	if ( m_nextBulletTime <= gpGlobals->curtime && !IsPegged() )
game/server/hl2/npc_strider.cpp:			float flRemainingShootTime = m_burstTime - gpGlobals->curtime;
game/server/hl2/npc_strider.cpp:		m_nextBulletTime = gpGlobals->curtime + (1.0f / pHost->GetMinigunRateOfFire() );
game/server/hl2/npc_strider.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/npc_strider.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/vehicle_cannon.cpp:	m_flNextAttackTime = gpGlobals->curtime;
game/server/hl2/vehicle_cannon.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_cannon.cpp:	RunCraneMovement( gpGlobals->frametime );
game/server/hl2/vehicle_cannon.cpp:		m_flTurn = UTIL_Approach( m_flMaxTurnSpeed, m_flTurn, flTurnAdd * gpGlobals->frametime );
game/server/hl2/vehicle_cannon.cpp:		m_flTurn = UTIL_Approach( -m_flMaxTurnSpeed, m_flTurn, flTurnAdd * gpGlobals->frametime );
game/server/hl2/vehicle_cannon.cpp:		m_flTurn = UTIL_Approach( 0, m_flTurn, m_flTurnDecel * gpGlobals->frametime );
game/server/hl2/vehicle_cannon.cpp:		m_flExtensionRate = UTIL_Approach( m_flMaxExtensionSpeed, m_flExtensionRate, m_flExtensionAccel * gpGlobals->frametime );
game/server/hl2/vehicle_cannon.cpp:		m_flExtensionRate = UTIL_Approach( -m_flMaxExtensionSpeed, m_flExtensionRate, m_flExtensionAccel * gpGlobals->frametime );
game/server/hl2/vehicle_cannon.cpp:		m_flExtensionRate = UTIL_Approach( 0, m_flExtensionRate, m_flExtensionDecel * gpGlobals->frametime );
game/server/hl2/vehicle_cannon.cpp:		if ( m_flNextAttackTime <= gpGlobals->curtime )
game/server/hl2/vehicle_cannon.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/vehicle_cannon.cpp:		if ( m_flFlyTime - 1.0f <= gpGlobals->curtime && m_flFlyTime - 0.8f > gpGlobals->curtime)
game/server/hl2/vehicle_cannon.cpp:		if ( m_flFlyTime <= gpGlobals->curtime )
game/server/hl2/vehicle_cannon.cpp:	float gravity = -gpGlobals->frametime * 600;
game/server/hl2/vehicle_cannon.cpp:		vOrigin = vOrigin + vVelocity * gpGlobals->frametime;
game/server/hl2/vehicle_cannon.cpp:	m_flFlyTime = gpGlobals->curtime + flTravelTime;
game/server/hl2/vehicle_cannon.cpp:	m_flNextAttackTime = gpGlobals->curtime + g_cannon_reloadtime.GetFloat();
game/server/hl2/vehicle_jeep.cpp:	m_flHandbrakeTime = gpGlobals->curtime + 0.1;
game/server/hl2/vehicle_jeep.cpp:			m_throttleDisableTime = gpGlobals->curtime + 2;
game/server/hl2/vehicle_jeep.cpp:				if ( m_WaterData.m_flNextRippleTime[iWheel] < gpGlobals->curtime )
game/server/hl2/vehicle_jeep.cpp:					m_WaterData.m_flNextRippleTime[iWheel] = gpGlobals->curtime + RandomFloat( 0.1, 0.3 );
game/server/hl2/vehicle_jeep.cpp:	SetSimulationTime( gpGlobals->curtime );
game/server/hl2/vehicle_jeep.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/vehicle_jeep.cpp:		m_flOverturnedTime += gpGlobals->frametime;
game/server/hl2/vehicle_jeep.cpp:					m_flAnimTime = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:	if ( ( m_flAmmoCrateCloseTime < gpGlobals->curtime ) && ( GetSequence() == LookupSequence( "ammo_open" ) ) )
game/server/hl2/vehicle_jeep.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:	if ( m_flCannonTime > gpGlobals->curtime )
game/server/hl2/vehicle_jeep.cpp:	m_flCannonTime = gpGlobals->curtime + 0.2f;
game/server/hl2/vehicle_jeep.cpp:		m_hPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/hl2/vehicle_jeep.cpp:	m_flCannonTime		= gpGlobals->curtime + 0.5f;
game/server/hl2/vehicle_jeep.cpp:	float flChargeAmount = ( gpGlobals->curtime - m_flCannonChargeStartTime ) / MAX_GAUSS_CHARGE_TIME;
game/server/hl2/vehicle_jeep.cpp:		m_hPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5f );
game/server/hl2/vehicle_jeep.cpp:	if ( m_flCannonTime > gpGlobals->curtime )
game/server/hl2/vehicle_jeep.cpp:		m_flCannonChargeStartTime = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:		float flChargeAmount = ( gpGlobals->curtime - m_flCannonChargeStartTime ) / MAX_GAUSS_CHARGE_TIME;
game/server/hl2/vehicle_jeep.cpp:			m_flAnimTime = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:		m_flAmmoCrateCloseTime = gpGlobals->curtime + JEEP_AMMO_CRATE_CLOSE_DELAY;
game/server/hl2/vehicle_jeep.cpp:	float flFrameTime = gpGlobals->frametime;
game/server/hl2/vehicle_jeep.cpp:	if ( ( m_throttleDisableTime > gpGlobals->curtime ) || ( IsOverturned() ) )
game/server/hl2/vehicle_jeep.cpp:	if ( m_flDangerSoundTime > gpGlobals->curtime )
game/server/hl2/vehicle_jeep.cpp:	m_flDangerSoundTime = gpGlobals->curtime + 0.1;
game/server/hl2/vehicle_jeep.cpp:	m_flPlayerExitedTime = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:	m_flLastSawPlayerAt = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:			SetContextThink( &CPropJeep::JeepSeagullThink, gpGlobals->curtime + JEEP_SEAGULL_THINK_INTERVAL, g_pJeepThinkContext );
game/server/hl2/vehicle_jeep.cpp:				SetContextThink( &CPropJeep::JeepSeagullThink, gpGlobals->curtime + JEEP_SEAGULL_POOP_INTERVAL, g_pJeepThinkContext );
game/server/hl2/vehicle_jeep.cpp:				SetContextThink( &CPropJeep::JeepSeagullThink, gpGlobals->curtime + JEEP_SEAGULL_THINK_INTERVAL, g_pJeepThinkContext );
game/server/hl2/vehicle_jeep.cpp:		SetContextThink( &CPropJeep::JeepSeagullThink, gpGlobals->curtime + JEEP_SEAGULL_THINK_INTERVAL, g_pJeepThinkContext );
game/server/hl2/vehicle_jeep.cpp:		m_flLastSawPlayerAt = gpGlobals->curtime;
game/server/hl2/vehicle_jeep.cpp:		SetContextThink( &CPropJeep::JeepSeagullThink, gpGlobals->curtime + JEEP_SEAGULL_THINK_INTERVAL, g_pJeepThinkContext );
game/server/hl2/vehicle_jeep.cpp:	SetContextThink( &CPropJeep::JeepSeagullThink, gpGlobals->curtime + 0.2, g_pJeepThinkContext );
game/server/hl2/vehicle_jeep.cpp:	float flHiddenTime = (gpGlobals->curtime - m_flLastSawPlayerAt);
game/server/hl2/vehicle_jeep.cpp:		SetContextThink( &CPropJeep::JeepSeagullThink, gpGlobals->curtime + JEEP_SEAGULL_POOP_INTERVAL, g_pJeepThinkContext );
game/server/hl2/vehicle_jeep.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/hl2/grenade_frag.cpp:	m_flNextBlipTime = gpGlobals->curtime + FRAG_GRENADE_BLIP_FREQUENCY;
game/server/hl2/grenade_frag.cpp:	UTIL_TraceHull( start, start + vel * gpGlobals->frametime, CollisionProp()->OBBMins(), CollisionProp()->OBBMaxs(), CONTENTS_HITBOX|CONTENTS_MONSTER|CONTENTS_SOLID, &filter, &tr );
game/server/hl2/grenade_frag.cpp:	UTIL_TraceLine( start, start + vel * gpGlobals->frametime, CONTENTS_HITBOX|CONTENTS_MONSTER|CONTENTS_SOLID, &filter, &tr );
game/server/hl2/grenade_frag.cpp:	m_flDetonateTime = gpGlobals->curtime + detonateDelay;
game/server/hl2/grenade_frag.cpp:	m_flWarnAITime = gpGlobals->curtime + warnDelay;
game/server/hl2/grenade_frag.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl2/grenade_frag.cpp:	m_flNextBlipTime = gpGlobals->curtime + FRAG_GRENADE_BLIP_FAST_FREQUENCY;
game/server/hl2/grenade_frag.cpp:		m_flNextBlipTime = gpGlobals->curtime + FRAG_GRENADE_BLIP_FAST_FREQUENCY;
game/server/hl2/grenade_frag.cpp:	if( gpGlobals->curtime > m_flDetonateTime )
game/server/hl2/grenade_frag.cpp:	if( !m_bHasWarnedAI && gpGlobals->curtime >= m_flWarnAITime )
game/server/hl2/grenade_frag.cpp:	if( gpGlobals->curtime > m_flNextBlipTime )
game/server/hl2/grenade_frag.cpp:			m_flNextBlipTime = gpGlobals->curtime + FRAG_GRENADE_BLIP_FAST_FREQUENCY;
game/server/hl2/grenade_frag.cpp:			m_flNextBlipTime = gpGlobals->curtime + FRAG_GRENADE_BLIP_FREQUENCY;
game/server/hl2/grenade_frag.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl2/grenade_frag.cpp:		float timer = m_flDetonateTime - gpGlobals->curtime + 5.0f;
game/server/hl2/grenade_frag.cpp:		float timer = MAX(m_flDetonateTime - gpGlobals->curtime - 5.0f,0.0f);
game/server/hl2/grenade_brickbat.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/grenade_brickbat.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2/npc_missiledefense.cpp:		m_flReloadedTime = gpGlobals->curtime + 0.3;
game/server/hl2/npc_missiledefense.cpp:	m_flReloadedTime = gpGlobals->curtime;
game/server/hl2/npc_missiledefense.cpp:			m_flReloadedTime = gpGlobals->curtime;
game/server/hl2/npc_missiledefense.cpp:	if( m_iAmmoLoaded < 1 && gpGlobals->curtime > m_flReloadedTime )
game/server/hl2/npc_missiledefense.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl2/npc_zombine.cpp:	bool IsSprinting( void ) { return m_flSprintTime > gpGlobals->curtime;	}
game/server/hl2/npc_zombine.cpp:	m_flNextMoanSound = gpGlobals->curtime + random->RandomFloat( 1.0, 4.0 );
game/server/hl2/npc_zombine.cpp:	g_flZombineGrenadeTimes = gpGlobals->curtime;
game/server/hl2/npc_zombine.cpp:	m_flGrenadePullTime = gpGlobals->curtime;
game/server/hl2/npc_zombine.cpp:	if( gpGlobals->curtime > m_flNextMoanSound )
game/server/hl2/npc_zombine.cpp:			m_flNextMoanSound = gpGlobals->curtime + random->RandomFloat( 10.0, 15.0 );
game/server/hl2/npc_zombine.cpp:			m_flNextMoanSound = gpGlobals->curtime + random->RandomFloat( 2.5, 5.0 );
game/server/hl2/npc_zombine.cpp:		m_flSuperFastAttackTime = gpGlobals->curtime + 1.0f;
game/server/hl2/npc_zombine.cpp:		if ( m_flSuperFastAttackTime > gpGlobals->curtime || HasGrenade() )
game/server/hl2/npc_zombine.cpp:	if ( g_flZombineGrenadeTimes > gpGlobals->curtime )
game/server/hl2/npc_zombine.cpp:	if ( m_flGrenadePullTime > gpGlobals->curtime )
game/server/hl2/npc_zombine.cpp:	if ( m_flSuperFastAttackTime >= gpGlobals->curtime )
game/server/hl2/npc_zombine.cpp:			m_flGrenadePullTime = gpGlobals->curtime + 0.5f;
game/server/hl2/npc_zombine.cpp:				g_flZombineGrenadeTimes = gpGlobals->curtime + 10.0f;
game/server/hl2/npc_zombine.cpp:		if ( m_flSprintRestTime > gpGlobals->curtime )
game/server/hl2/npc_zombine.cpp:	m_flSprintTime = gpGlobals->curtime;
game/server/hl2/npc_zombine.cpp:	m_flSprintTime = gpGlobals->curtime + flSprintTime;
game/server/hl2/npc_zombine.cpp:	g_flZombineGrenadeTimes = gpGlobals->curtime + 5.0f;
game/server/hl2/weapon_alyxgun_s.cpp:			m_flTooCloseTimer = gpGlobals->curtime;
game/server/hl2/weapon_alyxgun_s.cpp:		flTime = gpGlobals->curtime - m_flTooCloseTimer;
game/server/hl2/weapon_alyxgun_s.cpp:	while (m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/hl2/weapon_alyxgun_s.cpp:	//pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/hl2/weapon_alyxgun_s.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/ai_playerally.h:	float		GetTimePlayerStaring()		{ return ( m_flTimePlayerStartStare != 0 ) ? gpGlobals->curtime - m_flTimePlayerStartStare : 0; }
game/server/ai_trackpather.cpp:	m_flEnemyPathUpdateTime	= gpGlobals->curtime;
game/server/ai_trackpather.cpp:	if ( m_flEnemyPathUpdateTime > gpGlobals->curtime )
game/server/ai_trackpather.cpp:	m_flEnemyPathUpdateTime	= gpGlobals->curtime + 1.0f;
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime );
game/server/scripted.cpp:		//pTarget->SetNextThink( gpGlobals->curtime );
game/server/scripted.cpp:			DevWarning( "scripted_sequence %d:%s - restarting dormant entity %d:%s : %.1f:%.1f\n", entindex(), GetDebugName(), pTarget->entindex(), pTarget->GetDebugName(), gpGlobals->curtime, pTarget->GetNextThink() );
game/server/scripted.cpp:			pTarget->SetNextThink( gpGlobals->curtime );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/scripted.cpp:	//Msg("%s (for %s) called SynchronizeSequence() at %0.2f\n", GetTarget()->GetDebugName(), GetDebugName(), gpGlobals->curtime);
game/server/scripted.cpp:	float flInterval = gpGlobals->curtime - m_startTime;
game/server/scripted.cpp:	// Msg("%.2f \"%s\"  %s : %f (%f): interval %f\n", gpGlobals->curtime, GetEntityName().ToCStr(), pNPC->GetClassname(), pNPC->m_flAnimTime.Get(), m_startTime, flInterval );
game/server/scripted.cpp:	//Msg("%s SequenceDone() at %0.2f\n", pNPC->GetDebugName(), gpGlobals->curtime );
game/server/scripted.cpp:		//Msg("%s (for %s) forcing synch of %s at %0.2f\n", GetTarget()->GetDebugName(), GetDebugName(), iszSequence, gpGlobals->curtime);
game/server/scripted.cpp: 	//Msg("%s (for %s) starting %s seq at %0.2f\n", pNPC->GetDebugName(), GetDebugName(), iszSequence, gpGlobals->curtime);
game/server/scripted.cpp:	m_startTime = gpGlobals->curtime;
game/server/scripted.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/scripted.cpp:	//Msg("%s finished post idle at %0.2f\n", pNPC->GetDebugName(), gpGlobals->curtime );
game/server/scripted.cpp:	//Msg("SSEQ: %.2f \"%s\" (%d) DelayStart( %d ). Current m_iDelay is: %d\n", gpGlobals->curtime, GetDebugName(), entindex(), bDelay, m_iDelay );
game/server/scripted.cpp:		m_startTime = gpGlobals->curtime;
game/server/scripted.cpp:					pTarget->m_startTime = gpGlobals->curtime;
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime );
game/server/scripted.cpp:	SetNextThink( gpGlobals->curtime );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + delay + m_flRepeat );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + m_flRepeat + 0.5 );
game/server/scripted.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/envmicrophone.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/envmicrophone.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/envmicrophone.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/playerlocaldata.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/EntityFlame.cpp:	pFlame->SetNextThink( gpGlobals->curtime + 0.1f );
game/server/EntityFlame.cpp:	m_flLifetime = gpGlobals->curtime + lifetime;
game/server/EntityFlame.cpp:	return m_flLifetime - gpGlobals->curtime;
game/server/EntityFlame.cpp:	SetNextThink( gpGlobals->curtime + FLAME_DAMAGE_INTERVAL );
game/server/EntityFlame.cpp:	if ( m_flLifetime < gpGlobals->curtime || m_hEntAttached == NULL )
game/server/EntityFlame.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/env_tonemap_controller.cpp:	m_flBlendEndTime = gpGlobals->curtime + atof( pszParam );
game/server/env_tonemap_controller.cpp:	m_flBlendStartTime = gpGlobals->curtime;
game/server/env_tonemap_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/env_tonemap_controller.cpp:	float flRemapped = RemapValClamped( gpGlobals->curtime, m_flBlendStartTime, m_flBlendEndTime, m_flBlendTonemapStart, m_flBlendTonemapEnd );
game/server/env_tonemap_controller.cpp:	//Msg("Setting tonemap scale to %f (curtime %f, %f -> %f)\n", flRemapped, gpGlobals->curtime, m_flBlendStartTime, m_flBlendEndTime ); 
game/server/env_tonemap_controller.cpp:	if ( gpGlobals->curtime >= m_flBlendEndTime )
game/server/env_tonemap_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/client.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/client.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/client.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/client.cpp:		for ( int iClient = 1; iClient <= gpGlobals->maxClients; iClient++ )
game/server/client.cpp:		if (( pPlayer->LastTimePlayerTalked() + TALK_INTERVAL ) < gpGlobals->curtime) 
game/server/client.cpp:		if (( pPlayer->LastTimePlayerTalked() + TALK_INTERVAL ) < gpGlobals->curtime) 
game/server/client.cpp:		&& (gpGlobals->maxClients == 1 || sv_cheats->GetBool()) 
game/server/client.cpp:			else if ( gpGlobals->maxClients > 1 )
game/server/client.cpp:	if ( gpGlobals->deathmatch )
game/server/client.cpp:	   if ( gpGlobals->deathmatch )
game/server/client.cpp:	if ( gpGlobals->deathmatch )
game/server/client.cpp:	if ( gpGlobals->deathmatch )
game/server/ai_relationship.cpp:		SetNextThink( gpGlobals->curtime );
game/server/ai_relationship.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/npc_vehicledriver.cpp:	if ( m_pVehicleInterface->Weapon_PrimaryCanFireAt() > gpGlobals->curtime )
game/server/npc_vehicledriver.cpp:	if ( m_pVehicleInterface->Weapon_SecondaryCanFireAt() > gpGlobals->curtime )
game/server/npc_vehicledriver.cpp:	float flIncTime = gpGlobals->curtime - GetLastThink();
game/server/controlentities.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/sdk/sdk_playermove.cpp:	if (pVehicle && gpGlobals->frametime != 0)
game/server/sdk/sdk_playermove.cpp:	if (pVehicle && gpGlobals->frametime != 0)
game/server/sdk/sdk_client.cpp:	if (gpGlobals->coop || gpGlobals->deathmatch)
game/server/sdk/sdk_client.cpp:	gpGlobals->teamplay = teamplay.GetInt() ? true : false;
game/server/sdk/sdk_vehicle_jeep.cpp:	m_flHandbrakeTime = gpGlobals->curtime + 0.1;
game/server/sdk/sdk_vehicle_jeep.cpp:			m_throttleDisableTime = gpGlobals->curtime + 2;
game/server/sdk/sdk_vehicle_jeep.cpp:				if ( m_WaterData.m_flNextRippleTime[iWheel] < gpGlobals->curtime )
game/server/sdk/sdk_vehicle_jeep.cpp:					m_WaterData.m_flNextRippleTime[iWheel] = gpGlobals->curtime + RandomFloat( 0.1, 0.3 );
game/server/sdk/sdk_vehicle_jeep.cpp:	SetSimulationTime( gpGlobals->curtime );
game/server/sdk/sdk_vehicle_jeep.cpp:	SetNextThink( gpGlobals->curtime );
game/server/sdk/sdk_vehicle_jeep.cpp:		m_flOverturnedTime += gpGlobals->frametime;
game/server/sdk/sdk_vehicle_jeep.cpp:	if ( ( m_flAmmoCrateCloseTime < gpGlobals->curtime ) && ( GetSequence() == LookupSequence( "ammo_open" ) ) )
game/server/sdk/sdk_vehicle_jeep.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/sdk/sdk_vehicle_jeep.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/sdk/sdk_vehicle_jeep.cpp:	if ( m_flCannonTime > gpGlobals->curtime )
game/server/sdk/sdk_vehicle_jeep.cpp:	m_flCannonTime = gpGlobals->curtime + 0.2f;
game/server/sdk/sdk_vehicle_jeep.cpp:		m_hPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/server/sdk/sdk_vehicle_jeep.cpp:	m_flCannonTime		= gpGlobals->curtime + 0.5f;
game/server/sdk/sdk_vehicle_jeep.cpp:	float flChargeAmount = ( gpGlobals->curtime - m_flCannonChargeStartTime ) / MAX_GAUSS_CHARGE_TIME;
game/server/sdk/sdk_vehicle_jeep.cpp:		m_hPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5f );
game/server/sdk/sdk_vehicle_jeep.cpp:	if ( m_flCannonTime > gpGlobals->curtime )
game/server/sdk/sdk_vehicle_jeep.cpp:		m_flCannonChargeStartTime = gpGlobals->curtime;
game/server/sdk/sdk_vehicle_jeep.cpp:			m_flAnimTime = gpGlobals->curtime;
game/server/sdk/sdk_vehicle_jeep.cpp:		m_flAmmoCrateCloseTime = gpGlobals->curtime + JEEP_AMMO_CRATE_CLOSE_DELAY;
game/server/sdk/sdk_vehicle_jeep.cpp:	float flFrameTime = gpGlobals->frametime;
game/server/sdk/sdk_vehicle_jeep.cpp:	if ( ( m_throttleDisableTime > gpGlobals->curtime ) || ( IsOverturned() ) )
game/server/sdk/sdk_vehicle_jeep.cpp:	if ( m_flDangerSoundTime > gpGlobals->curtime )
game/server/sdk/sdk_vehicle_jeep.cpp:	m_flDangerSoundTime = gpGlobals->curtime + 0.1;
game/server/sdk/sdk_vehicle_jeep.cpp:	m_flPlayerExitedTime = gpGlobals->curtime;
game/server/sdk/sdk_vehicle_jeep.cpp:	m_flLastSawPlayerAt = gpGlobals->curtime;
game/server/sdk/sdk_vehicle_jeep.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/sdk/sdk_modelentity.cpp:	if ( m_flNextChangeTime < gpGlobals->curtime )
game/server/sdk/sdk_modelentity.cpp:		m_flNextChangeTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 3.0f );
game/server/sdk/sdk_modelentity.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/server/sdk/sdk_modelentity.cpp:		SetNextThink( gpGlobals->curtime + 0.05f );
game/server/sdk/sdk_modelentity.cpp:		m_flNextChangeTime = gpGlobals->curtime;
game/server/sdk/sdk_bot_temp.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/sdk/sdk_bot_temp.cpp:	if ( bot_mimic.GetInt() > gpGlobals->maxClients )
game/server/sdk/sdk_bot_temp.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/sdk/sdk_bot_temp.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/sdk/sdk_bot_temp.cpp:	float flTimeBase = gpGlobals->curtime + gpGlobals->frametime - frametime;
game/server/sdk/sdk_bot_temp.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/sdk/sdk_bot_temp.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/sdk/sdk_bot_temp.cpp:	if ( gpGlobals->curtime >= pBot->m_flNextStrafeTime )
game/server/sdk/sdk_bot_temp.cpp:		pBot->m_flNextStrafeTime = gpGlobals->curtime + 1.0f;
game/server/sdk/sdk_bot_temp.cpp:			if ( gpGlobals->curtime < pBot->m_flNextTurnTime )
game/server/sdk/sdk_bot_temp.cpp:		pBot->m_flNextTurnTime = gpGlobals->curtime + 2.0;
game/server/sdk/sdk_bot_temp.cpp:	float frametime = gpGlobals->frametime;
game/server/env_entity_maker.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/env_entity_maker.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/env_entity_maker.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/nav_generate.cpp:				engine->ChangeLevel( STRING( gpGlobals->mapname ), NULL );
game/server/logic_mirror_movement.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/logic_mirror_movement.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/buttons.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );// no hurry, make sure everything else spawns
game/server/buttons.cpp:	SetNextThink( gpGlobals->curtime + 0.1 + random->RandomFloat ( 0, 1.5 ) );// spark again at random interval
game/server/buttons.cpp:	if ( gpGlobals->curtime > m_flUseLockedTime )
game/server/buttons.cpp:		m_flUseLockedTime = gpGlobals->curtime + 0.5;
game/server/buttons.cpp:		SetNextThink( gpGlobals->curtime + m_flWait );
game/server/buttons.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );// no hurry
game/server/buttons.cpp:	SetNextThink( gpGlobals->curtime );
game/server/buttons.cpp:		SetNextThink( gpGlobals->curtime );
game/server/buttons.cpp:		SetNextThink( gpGlobals->curtime + 0.01f );
game/server/buttons.cpp:	SetNextThink( gpGlobals->curtime );
game/server/ai_behavior_assault.cpp:	pAssaultPoint->m_flTimeLastUsed = gpGlobals->curtime;
game/server/ai_behavior_assault.cpp:		m_flTimeDeferScheduleSelection = gpGlobals->curtime + pTask->flTaskData;
game/server/ai_behavior_assault.cpp:		if ( ( ( !GetOuter()->DidChooseEnemy() && gpGlobals->curtime - GetOuter()->GetTimeEnemyAcquired() > 1 ) || !GetOuter()->GetEnemy() ) )
game/server/ai_behavior_assault.cpp:	if ( m_flTimeDeferScheduleSelection > gpGlobals->curtime )
game/server/ai_behavior_assault.cpp:		m_flLastSawAnEnemyAt = gpGlobals->curtime;
game/server/ai_behavior_assault.cpp:			if ( m_flLastSawAnEnemyAt && ((gpGlobals->curtime - m_flLastSawAnEnemyAt) < ASSAULT_DIVERSION_TIME) )
game/server/soundent.cpp:	SetNextThink( gpGlobals->curtime + 1 );
game/server/soundent.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );// how often to check the sound list.
game/server/soundent.cpp:		if ( (m_SoundPool[ iSound ].m_flExpireTime <= gpGlobals->curtime && (!m_SoundPool[ iSound ].m_bNoExpirationTime)) || !m_SoundPool[iSound].ValidateOwner() )
game/server/soundent.cpp:				Msg("  Removed Sound: %d (Time:%f)\n", m_SoundPool[ iSound ].SoundType(), gpGlobals->curtime );
game/server/soundent.cpp:				Msg("  Removed Danger Sound: %d (time:%f)\n", m_SoundPool[ iSound ].SoundType(), gpGlobals->curtime );
game/server/soundent.cpp:	pSound->m_flExpireTime = gpGlobals->curtime + flDuration;
game/server/soundent.cpp:		Msg("  Added Sound! Type:%d  Duration:%f (Time:%f)\n", pSound->SoundType(), flDuration, gpGlobals->curtime );
game/server/soundent.cpp:		Msg("  Added Danger Sound! Duration:%f (Time:%f)\n", flDuration, gpGlobals->curtime );
game/server/soundent.cpp:	if ( gpGlobals->maxClients > 1 )
game/server/soundent.cpp:		nTotalSoundsInPool = MIN( MAX_WORLD_SOUNDS_MP, gpGlobals->maxClients + 32 );
game/server/soundent.cpp:	if ( gpGlobals->maxClients+16 > nTotalSoundsInPool )
game/server/soundent.cpp:	for ( i = 0 ; i < gpGlobals->maxClients ; i++ )
game/server/soundent.cpp:	if ( iReturn < 0 || iReturn >= gpGlobals->maxClients )
game/server/ai_moveshoot.h:	bool IsSuspended() { return m_flSuspendUntilTime > gpGlobals->curtime; }
game/server/player_resource.cpp:	SetNextThink( gpGlobals->curtime );
game/server/player_resource.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/player_resource.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/weapon_ar1m1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
game/server/weapon_ar1m1.cpp:	//m_flNextPrimaryAttack = gpGlobals->curtime + 2.2f;
game/server/weapon_ar1m1.cpp:	//m_flNextSecondaryAttack = gpGlobals->curtime + 2.2f;
game/server/weapon_ar1m1.cpp:	m_flSecondaryReloadActivationTime = gpGlobals->curtime; // signal the secondary reload to ItemPostFrame() immediately to forbid ironsight
game/server/weapon_ar1m1.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flSecondaryReloadDeactivationTime = gpGlobals->curtime + SequenceDuration();
game/server/weapon_ar1m1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/weapon_ar1m1.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 2.2f;
game/server/weapon_ar1m1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 2.2f;
game/server/weapon_ar1m1.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/weapon_ar1m1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/weapon_ar1m1.cpp:	pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/weapon_ar1m1.cpp:		//m_flNextPrimaryAttack = gpGlobals->curtime + 2.2f;
game/server/weapon_ar1m1.cpp:		//m_flNextSecondaryAttack = gpGlobals->curtime + 2.2f;
game/server/weapon_ar1m1.cpp:		m_flSecondaryReloadActivationTime = gpGlobals->curtime; // signal the secondary reload to ItemPostFrame() immediately to forbid ironsight
game/server/weapon_ar1m1.cpp:		m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flSecondaryReloadDeactivationTime = gpGlobals->curtime + SequenceDuration();
game/server/weapon_ar1m1.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/weapon_ar1m1.cpp:	if (gpGlobals->curtime >= m_flSecondaryReloadActivationTime)
game/server/weapon_ar1m1.cpp:	if (gpGlobals->curtime >= m_flSecondaryReloadDeactivationTime)
game/server/weapon_ar1m1.cpp:	if (gpGlobals->curtime < m_flNextGrenadeCheck )
game/server/weapon_ar1m1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/weapon_ar1m1.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/weapon_ar1m1.cpp:		//m_flNextGrenadeCheck = gpGlobals->curtime;
game/server/weapon_ar1m1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 0.3; // 1/3 second.
game/server/weapon_ar1m1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/weapon_ar1m1.cpp:	while (m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/weapon_ar1m1.cpp:	pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/ai_basenpc_schedule.cpp:	m_ScheduleState.timeCurTaskStarted = m_ScheduleState.timeStarted = gpGlobals->curtime;
game/server/ai_basenpc_schedule.cpp:		DevMsg(this, AIMF_IGNORE_SELECTED, "Schedule: %s (time: %.2f)\n", pNewSchedule->GetName(), gpGlobals->curtime );
game/server/ai_basenpc_schedule.cpp:	ADD_DEBUG_HISTORY( HISTORY_AI_DECISIONS, UTIL_VarArgs("%s(%d): Schedule: %s (time: %.2f)\n", GetDebugName(), entindex(), pNewSchedule->GetName(), gpGlobals->curtime ) );
game/server/ai_basenpc_schedule.cpp:		choice.m_flTimeSelected = gpGlobals->curtime;
game/server/ai_basenpc_schedule.cpp:			m_ScheduleState.timeCurTaskStarted = gpGlobals->curtime;
game/server/ai_basenpc_schedule.cpp:			// DevMsg( "%.2f StartTask( %s )\n", gpGlobals->curtime, m_pTaskSR->GetStringText( pTask->iTask ) );
game/server/ai_basenpc_schedule.cpp:				// DevMsg( "%.2f RunTask( %s )\n", gpGlobals->curtime, m_pTaskSR->GetStringText( pTask->iTask ) );
game/server/ai_basenpc_schedule.cpp:		m_flNextDodgeTime = gpGlobals->curtime + pTask->flTaskData;
game/server/ai_basenpc_schedule.cpp:					m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/ai_basenpc_schedule.cpp:				m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/ai_basenpc_schedule.cpp:		m_flMoveWaitFinished = gpGlobals->curtime;
game/server/ai_basenpc_schedule.cpp:		SetLastAttackTime( gpGlobals->curtime );
game/server/ai_basenpc_schedule.cpp:		SetLastAttackTime( gpGlobals->curtime );
game/server/ai_basenpc_schedule.cpp:		SetLastAttackTime( gpGlobals->curtime );
game/server/ai_basenpc_schedule.cpp:		SetLastAttackTime( gpGlobals->curtime );
game/server/ai_basenpc_schedule.cpp:						m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/ai_basenpc_schedule.cpp:							m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/ai_basenpc_schedule.cpp:			m_flNextFlinchTime = gpGlobals->curtime + random->RandomFloat( 3, 5 );
game/server/ai_basenpc_schedule.cpp:			m_flNextFlinchTime = gpGlobals->curtime + random->RandomFloat( 3, 5 );
game/server/ai_basenpc_schedule.cpp:		m_flAcceptableTimeSeenEnemy = gpGlobals->curtime;
game/server/ai_basenpc_schedule.cpp:						m_flMoveWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/ai_basenpc_schedule.cpp:				 ( GetState() == NPC_STATE_COMBAT && GetEnemy() && gpGlobals->curtime - GetEnemies()->LastTimeSeen( GetEnemy() ) < 15 ) )
game/server/ai_basenpc_schedule.cpp:						m_flMoveWaitFinished = gpGlobals->curtime + 2;
game/server/ai_basenpc_schedule.cpp:			bool fTimeExpired = ( pTask->flTaskData != 0 && pTask->flTaskData < gpGlobals->curtime - GetTimeTaskStarted() );
game/server/ai_basenpc_schedule.cpp:	if ( gpGlobals->curtime - GetEnemies()->LastTimeSeen( AI_UNKNOWN_ENEMY ) < TIME_CARE_ABOUT_DAMAGE )
game/server/ai_basenpc_schedule.cpp:	if ( HasCondition(COND_NEW_ENEMY) && gpGlobals->curtime - GetEnemies()->FirstTimeSeen(GetEnemy()) < 2.0 )
game/server/ai_basenpc_schedule.cpp:		if ( (pMemory && pMemory->bUnforgettable) || (GetEnemyLastTimeSeen() > (gpGlobals->curtime - 5.0)) )
game/server/ai_basenpc_schedule.cpp:		m_flNextFlinchTime = gpGlobals->curtime + flNextFlinch;
game/server/util.cpp:	if ( playerIndex > 0 && playerIndex <= gpGlobals->maxClients )
game/server/util.cpp:	for (int i = 1; i<=gpGlobals->maxClients; i++ )
game/server/util.cpp:	for (int i = 1; i<=gpGlobals->maxClients; i++ )
game/server/util.cpp:	if ( gpGlobals->maxClients > 1 )
game/server/util.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/util.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/util.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/util.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/server/util.cpp:				else if ( !FStrEq(STRING(gpGlobals->mapname), GlobalEntity_GetMap(globalIndex)) )
game/server/util.cpp:				GlobalEntity_Add( pEntity->m_iGlobalname, gpGlobals->mapname, GLOBAL_ON );
game/server/util.cpp:	if (check > gpGlobals->maxClients)
game/server/util.cpp:		check = gpGlobals->maxClients;
game/server/util.cpp:	if (check == gpGlobals->maxClients)
game/server/util.cpp:		if ( i > gpGlobals->maxClients )
game/server/util.cpp:	float delta = gpGlobals->curtime - g_CheckClient.m_lastchecktime;
game/server/util.cpp:		g_CheckClient.m_lastchecktime = gpGlobals->curtime;
game/server/ai_behavior_lead.cpp:	m_flNextLeadIdle = gpGlobals->curtime + 10;
game/server/ai_behavior_lead.cpp:				if ( !m_flWeaponSafetyTimeOut || (m_flWeaponSafetyTimeOut > gpGlobals->curtime) )
game/server/ai_behavior_lead.cpp:			if ( flAvailableTime <= gpGlobals->curtime )
game/server/ai_behavior_lead.cpp:				if ( gpGlobals->curtime - GetOuter()->GetTimeTaskStarted() > 0.3 )
game/server/ai_behavior_lead.cpp:				if ( m_flNextLeadIdle < gpGlobals->curtime && !IsSpeaking() )
game/server/ai_behavior_lead.cpp:					m_flNextLeadIdle = gpGlobals->curtime + RandomFloat( 10,15 );
game/server/ai_behavior_lead.cpp:		if ( m_flSpeakNextNagTime > gpGlobals->curtime )
game/server/ai_behavior_lead.cpp:		m_flSpeakNextNagTime = gpGlobals->curtime + LEAD_NAG_TIME;
game/server/ai_tacticalservices.cpp:		 GetOuter()->GetTimeScheduleStarted() == gpGlobals->curtime ) // Conditions get nuked before tasks run, assume should try
game/server/tesla.cpp:		SetNextThink( gpGlobals->curtime + flTimeToNext );
game/server/physics_npc_solver.cpp:	m_cancelTime = gpGlobals->curtime + m_separationDuration;
game/server/physics_npc_solver.cpp:	SetNextThink( gpGlobals->curtime + m_separationDuration );
game/server/tanktrain.cpp:	SetNextThink( gpGlobals->curtime );
game/server/tanktrain.cpp:		SetNextThink( gpGlobals->curtime + 0.5f );
game/server/tanktrain.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/tanktrain.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/physics.cpp:	physenv->SetSimulationTimestep( gpGlobals->interval_per_tick ); // 15 ms per tick
game/server/physics.cpp:	float interval = ( gpGlobals->frametime > 0.0f ) ? TICK_INTERVAL : 0.0f;
game/server/physics.cpp:	// update the physics simulation, not we don't use gpGlobals->frametime, since that can be 30 msec or 15 msec
game/server/physics.cpp:	m_impactSoundTime += gpGlobals->frametime;
game/server/physics.cpp:	if ( m_lastTickFrictionError > gpGlobals->tickcount || m_lastTickFrictionError < (gpGlobals->tickcount-1) )
game/server/physics.cpp:	m_lastTickFrictionError = gpGlobals->tickcount;
game/server/physics.cpp:		else if ( gpGlobals->curtime - m_penetrateEvents[i].timeStamp > 1.0 )
game/server/physics.cpp:		event.startTime = gpGlobals->curtime;
game/server/physics.cpp:	event.timeStamp = gpGlobals->curtime;
game/server/physics.cpp:	float eventTime = gpGlobals->curtime - event.startTime;
game/server/physics.cpp:			DevMsg(1, "***Inter-penetration on %s (%d & %d) (%.0f, %.0f)\n", pName1?pName1:"(null)", index0, index1, gpGlobals->curtime, eventTime );
game/server/physics.cpp:			DevMsg(1, "***Inter-penetration between %s(%s) AND %s(%s) (%.0f, %.0f)\n", pName1?pName1:"(null)", pEntity0->GetDebugName(), pName2?pName2:"(null)", pEntity1->GetDebugName(), gpGlobals->curtime, eventTime );
game/server/physics.cpp:		event.startTime = gpGlobals->curtime;
game/server/physics.cpp:		physenv->Simulate( gpGlobals->interval_per_tick );
game/server/physics.cpp:			physenv->Simulate( gpGlobals->interval_per_tick );
game/server/physics.cpp:			if ( (pFriction->flLastEffectTime + 0.5f) > gpGlobals->curtime)
game/server/physics.cpp:				pFriction->flLastUpdateTime = gpGlobals->curtime;
game/server/physics.cpp:		if ( (gpGlobals->curtime - m_fluidEvents[i].impactTime) > FLUID_TIME_MAX )
game/server/physics.cpp:			return gpGlobals->curtime - m_fluidEvents[i].impactTime;
game/server/physics.cpp:	m_fluidEvents[index].impactTime = gpGlobals->curtime;
game/server/physics.cpp:			if ( m_current[i].flLastUpdateTime < (gpGlobals->curtime-0.1f) )
game/server/physics.cpp:		pFriction->flLastUpdateTime = gpGlobals->curtime;
game/server/physics.cpp:		pFriction->flLastEffectTime = gpGlobals->curtime;
game/server/nav_area.h:	m_clearedTimestamp[ teamID % MAX_NAV_TEAMS ] = gpGlobals->curtime;
game/server/nav_area.h:	return ( gpGlobals->tickcount <= m_damagingTickCount );
game/server/nav_area.h:	m_damagingTickCount = gpGlobals->tickcount + TIME_TO_TICKS( duration );
game/server/pointhurt.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/pointhurt.cpp:	SetNextThink( gpGlobals->curtime + m_flDelay );
game/server/pointhurt.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/dynamiclight.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/dynamiclight.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/trains.cpp:	if ( gpGlobals->curtime < m_flNextBlockTime )
game/server/trains.cpp:	m_flNextBlockTime = gpGlobals->curtime + 0.5;
game/server/trains.cpp:	m_lastBlockTick = gpGlobals->tickcount;
game/server/trains.cpp:		m_flSpeedChangeTime = gpGlobals->curtime;
game/server/trains.cpp:			int ticksBlocked = gpGlobals->tickcount - m_lastBlockTick;
game/server/trains.cpp:				m_lastBlockTick = gpGlobals->tickcount;
game/server/trains.cpp:		if ( m_flNextMPSoundTime > gpGlobals->curtime )
game/server/trains.cpp:		m_flNextMPSoundTime = gpGlobals->curtime + 1.0;
game/server/trains.cpp:		m_flNextMoveSoundTime = gpGlobals->curtime + RemapVal( flSpeedRatio, 0, 1, m_flMoveSoundMaxTime, m_flMoveSoundMinTime );
game/server/trains.cpp:		if ( ( m_iszSoundMovePing != NULL_STRING ) && ( gpGlobals->curtime > m_flNextMoveSoundTime ) )
game/server/trains.cpp:			m_flNextMoveSoundTime = gpGlobals->curtime + RemapVal( flSpeedRatio, 0, 1, m_flMoveSoundMaxTime, m_flMoveSoundMinTime );
game/server/trains.cpp:					m_flSpeed = UTIL_Approach( m_flDesiredSpeed, m_flSpeed, flSpeedChangeTime * gpGlobals->frametime );
game/server/trains.cpp:		UpdateTrainVelocity( pNext, pNextNext, nextPos, gpGlobals->frametime );
game/server/trains.cpp:		UpdateTrainOrientation( pNext, pNextNext, nextPos, gpGlobals->frametime );
game/server/trains.cpp:		SetNextThink( gpGlobals->curtime );
game/server/trains.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/trains.cpp:	SetNextThink( gpGlobals->curtime );
game/server/trains.cpp:	SetNextThink( gpGlobals->curtime );
game/server/trains.cpp:	SetNextThink( gpGlobals->curtime + 2 );
game/server/ai_node.h:	bool 			IsLocked() const			{ return ( m_flNextUseTime > gpGlobals->curtime ); }
game/server/ai_node.h:	void			Lock( float duration )		{ m_flNextUseTime = gpGlobals->curtime + duration; }
game/server/ai_node.h:	void			Unlock()					{ m_flNextUseTime = gpGlobals->curtime; }
game/server/vehicle_baseserver.h:		flFrameTime = gpGlobals->frametime;
game/server/event_tempentity_tester.cpp:		life += gpGlobals->curtime;
game/server/event_tempentity_tester.cpp:	SetNextThink( gpGlobals->curtime );
game/server/event_tempentity_tester.cpp:	SetNextThink( gpGlobals->curtime + TEMPENT_TEST_GAP );
game/server/event_tempentity_tester.cpp:	if ( gpGlobals->curtime >= m_fLifeTime )
game/server/ai_basenpc_movement.cpp:			npc->m_flMoveWaitFinished = gpGlobals->curtime;
game/server/ai_basenpc_movement.cpp:	return gpGlobals->curtime + flTravelTime;
game/server/ai_basenpc_movement.cpp:	return (m_flMoveWaitFinished > gpGlobals->curtime);
game/server/ai_basenpc_movement.cpp:		// DevMsg( "%.2f : (%.1f) %.1f %.1f %.1f\n", gpGlobals->curtime, (newPos - GetLocalOrigin()).Length(), newPos.x, newPos.y, newAngles.y );
game/server/hl2mp/grenade_satchel.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2mp/grenade_satchel.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2mp/grenade_satchel.cpp:	if (gpGlobals->curtime > m_flNextBounceSoundTime)
game/server/hl2mp/grenade_satchel.cpp:		m_flNextBounceSoundTime = gpGlobals->curtime + 0.1;
game/server/hl2mp/hl2mp_bot_temp.cpp:	g_BotData[pPlayer->entindex()-1].m_flJoinTeamTime = gpGlobals->curtime + 0.3;
game/server/hl2mp/hl2mp_bot_temp.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/hl2mp/hl2mp_bot_temp.cpp:	if ( bot_mimic.GetInt() > gpGlobals->maxClients )
game/server/hl2mp/hl2mp_bot_temp.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/hl2mp/hl2mp_bot_temp.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/hl2mp/hl2mp_bot_temp.cpp:	float flTimeBase = gpGlobals->curtime + gpGlobals->frametime - frametime;
game/server/hl2mp/hl2mp_bot_temp.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/hl2mp/hl2mp_bot_temp.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/hl2mp/hl2mp_bot_temp.cpp:	float frametime = gpGlobals->frametime;
game/server/hl2mp/hl2mp_bot_temp.cpp:					if ( gpGlobals->curtime < botdata->nextturntime )
game/server/hl2mp/hl2mp_bot_temp.cpp:				botdata->nextturntime = gpGlobals->curtime + 2.0;
game/server/hl2mp/hl2mp_bot_temp.cpp:			if ( gpGlobals->curtime >= botdata->nextstrafetime )
game/server/hl2mp/hl2mp_bot_temp.cpp:				botdata->nextstrafetime = gpGlobals->curtime + 1.0f;
game/server/hl2mp/grenade_tripmine.cpp:	m_flPowerUp = gpGlobals->curtime + 2.0;
game/server/hl2mp/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl2mp/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2mp/grenade_tripmine.cpp:	if (gpGlobals->curtime > m_flPowerUp)
game/server/hl2mp/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2mp/grenade_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl2mp/grenade_tripmine.cpp:	SetNextThink(gpGlobals->curtime + 0.1f);
game/server/hl2mp/grenade_tripmine.cpp:	if (gpGlobals->curtime < m_flPowerUp && info.GetDamage() < m_iHealth)
game/server/hl2mp/grenade_tripmine.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2mp/grenade_tripmine.cpp:	SetNextThink(gpGlobals->curtime + 0.5);
game/server/hl2mp/hl2mp_player.cpp:	m_flNextModelChangeTime = gpGlobals->curtime + MODEL_CHANGE_INTERVAL;
game/server/hl2mp/hl2mp_player.cpp:	m_flNextModelChangeTime = gpGlobals->curtime + MODEL_CHANGE_INTERVAL;
game/server/hl2mp/hl2mp_player.cpp:/*	if ( GetNextTeamChangeTime() >= gpGlobals->curtime )
game/server/hl2mp/hl2mp_player.cpp:		Q_snprintf( szReturnString, sizeof( szReturnString ), "Please wait %d more seconds before trying to switch teams again.\n", (int)(GetNextTeamChangeTime() - gpGlobals->curtime) );
game/server/hl2mp/hl2mp_player.cpp:	m_flNextTeamChangeTime = gpGlobals->curtime + TEAM_CHANGE_INTERVAL;
game/server/hl2mp/hl2mp_player.cpp:			m_fNextSuicideTime = gpGlobals->curtime;	// allow the suicide to work
game/server/hl2mp/hl2mp_player.cpp:		m_RateLimitLastCommandTimes.Insert( args[0], gpGlobals->curtime );
game/server/hl2mp/hl2mp_player.cpp:	else if ( (gpGlobals->curtime - m_RateLimitLastCommandTimes[i]) < HL2MP_COMMAND_MAX_RATE )
game/server/hl2mp/hl2mp_player.cpp:		m_RateLimitLastCommandTimes[i] = gpGlobals->curtime;
game/server/hl2mp/hl2mp_player.cpp:			m_hRagdoll->GetBaseAnimating()->Dissolve( NULL, gpGlobals->curtime, false, ENTITY_DISSOLVE_NORMAL );
game/server/hl2mp/hl2mp_player.cpp:	if ( gpGlobals->curtime < m_flSlamProtectTime &&  (inputInfo.GetDamageType() == DMG_BLAST ) )
game/server/hl2mp/hl2mp_player.cpp:	m_flSlamProtectTime = gpGlobals->curtime + 0.5;
game/server/hl2mp/hl2mp_client.cpp:		if ( gpGlobals->curtime > pPlayer->GetDeathTime() + DEATH_ANIMATION_TIME )
game/server/hl2mp/hl2mp_client.cpp:			pPlayer->SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl2mp/hl2mp_client.cpp:	gpGlobals->teamplay = (teamplay.GetInt() != 0);
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:	if (m_flNextPainSound > gpGlobals->curtime)
game/server/hl1/hl1_npc_nihilanth.cpp:	m_flNextPainSound = gpGlobals->curtime + random->RandomFloat( 2, 5 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:			if (m_flLastSeen < gpGlobals->curtime - 5)
game/server/hl1/hl1_npc_nihilanth.cpp:				m_flPrevSeen = gpGlobals->curtime;
game/server/hl1/hl1_npc_nihilanth.cpp:			m_flLastSeen = gpGlobals->curtime;
game/server/hl1/hl1_npc_nihilanth.cpp:	if (m_flLastSeen + 15 < gpGlobals->curtime)
game/server/hl1/hl1_npc_nihilanth.cpp:		if (m_flLastSeen + 5 > gpGlobals->curtime && flDist < 256 && flDot > 0)
game/server/hl1/hl1_npc_nihilanth.cpp:	if (m_flShootEnd > gpGlobals->curtime)
game/server/hl1/hl1_npc_nihilanth.cpp:		while (m_flShootTime < m_flShootEnd && m_flShootTime < gpGlobals->curtime)
game/server/hl1/hl1_npc_nihilanth.cpp:				vecSrc = vecHand + GetAbsVelocity() * (m_flShootTime - gpGlobals->curtime);
game/server/hl1/hl1_npc_nihilanth.cpp:				vecSrc = vecSrc + vecDir * (gpGlobals->curtime - m_flShootTime);
game/server/hl1/hl1_npc_nihilanth.cpp:				vecSrc = vecHand + GetAbsVelocity() * (m_flShootTime - gpGlobals->curtime);
game/server/hl1/hl1_npc_nihilanth.cpp:				vecSrc = vecSrc + vecDir * (gpGlobals->curtime - m_flShootTime);
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:			m_flShootTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_nihilanth.cpp:			m_flShootEnd = gpGlobals->curtime + 1.0;
game/server/hl1/hl1_npc_nihilanth.cpp:				m_flShootTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_nihilanth.cpp:				m_flShootEnd = gpGlobals->curtime + 1.0;
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl1/hl1_npc_nihilanth.cpp:		SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl1/hl1_npc_nihilanth.cpp:		GetSprite()->SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink ( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_nihilanth.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_client.cpp:	if (gpGlobals->coop || gpGlobals->deathmatch)
game/server/hl1/hl1_client.cpp:	gpGlobals->teamplay = (teamplay.GetInt() != 0);
game/server/hl1/hl1_client.cpp:	if ( !gpGlobals->deathmatch )
game/server/hl1/hl1_npc_controller.cpp:			m_iBallTime[0] = gpGlobals->curtime + atoi( pEvent->options ) / 15.0;
game/server/hl1/hl1_npc_controller.cpp:			m_iBallTime[1] = gpGlobals->curtime + atoi( pEvent->options ) / 15.0;
game/server/hl1/hl1_npc_controller.cpp:			m_flShootTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_controller.cpp:			m_iBallTime[0] = gpGlobals->curtime + atoi( pEvent->options ) / 15.0;
game/server/hl1/hl1_npc_controller.cpp:			m_iBallTime[1] = gpGlobals->curtime + atoi( pEvent->options ) / 15.0;
game/server/hl1/hl1_npc_controller.cpp:			m_iBallTime[0] = gpGlobals->curtime + atoi( pEvent->options ) / 15.0;
game/server/hl1/hl1_npc_controller.cpp:			m_iBallTime[1] = gpGlobals->curtime + atoi( pEvent->options ) / 15.0;
game/server/hl1/hl1_npc_controller.cpp:	if (m_flShootEnd > gpGlobals->curtime)
game/server/hl1/hl1_npc_controller.cpp:		while (m_flShootTime < m_flShootEnd && m_flShootTime < gpGlobals->curtime)
game/server/hl1/hl1_npc_controller.cpp:			Vector vecSrc = vecHand + GetAbsVelocity() * (m_flShootTime - gpGlobals->curtime);
game/server/hl1/hl1_npc_controller.cpp:				vecSrc = vecSrc + vecDir * (gpGlobals->curtime - m_flShootTime);
game/server/hl1/hl1_npc_controller.cpp:		float t = m_iBallTime[i] - gpGlobals->curtime;
game/server/hl1/hl1_npc_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_controller.cpp:	m_flSpawnTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_controller.cpp:	if (gpGlobals->curtime - m_flSpawnTime > 5 || m_pSprite->GetBrightness() < 64 /*|| GetEnemy() == NULL || m_hOwner == NULL*/ || !IsInWorld() )
game/server/hl1/hl1_npc_controller.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_npc_controller.cpp:		SetNextAttack( gpGlobals->curtime + 3.0 );
game/server/hl1/hl1_npc_controller.cpp:		SetNextThink( gpGlobals->curtime + 0.3 );
game/server/hl1/hl1_npc_controller.cpp:	m_flSpawnTime = gpGlobals->curtime; // keep track of when ball spawned
game/server/hl1/hl1_npc_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_controller.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_controller.cpp:	if (gpGlobals->curtime - m_flSpawnTime > 5 || GetAbsVelocity().Length() < 10)
game/server/hl1/hl1_grenade_spit.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_grenade_spit.cpp:		m_fSpitDeathTime < gpGlobals->curtime)
game/server/hl1/hl1_grenade_spit.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_apache.cpp:		if (m_flLastSeen + 90 > gpGlobals->curtime && DotProduct( v1, v2 ) > 0.25)
game/server/hl1/hl1_npc_apache.cpp:	// Vector vecEst1 = GetAbsOrigin() + pev->velocity + gpGlobals->v_up * m_flForce - Vector( 0, 0, 384 );
game/server/hl1/hl1_npc_apache.cpp:	// float flSide = DotProduct( m_posDesired - vecEst1, gpGlobals->v_right );
game/server/hl1/hl1_npc_apache.cpp:	// float flSlip = DotProduct( pev->velocity, gpGlobals->v_right );
game/server/hl1/hl1_npc_apache.cpp:	// ALERT( at_console, "%d %d %d %4.2f\n", GetAbsAngles().x < 0, DotProduct( pev->velocity, gpGlobals->v_forward ) > -100, m_flNextRocket < gpGlobals->curtime, DotProduct( m_vecTarget, vecEst ) );
game/server/hl1/hl1_npc_apache.cpp:		m_flNextRocket = gpGlobals->curtime + 0.5;
game/server/hl1/hl1_npc_apache.cpp:			m_flNextRocket = gpGlobals->curtime + 10;
game/server/hl1/hl1_npc_apache.cpp:	else if (DotProduct( GetAbsVelocity(), vForward ) > -100 && m_flNextRocket < gpGlobals->curtime)
game/server/hl1/hl1_npc_apache.cpp:		if (m_flLastSeen + 60 > gpGlobals->curtime)
game/server/hl1/hl1_npc_apache.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_apache.cpp:	if( gpGlobals->curtime > m_flNextCrashExplosion )
game/server/hl1/hl1_npc_apache.cpp:		m_flNextCrashExplosion = gpGlobals->curtime + random->RandomFloat( 0.3, 0.5 );
game/server/hl1/hl1_npc_ichthyosaur.cpp:	m_flLastAttackSound = gpGlobals->curtime;
game/server/hl1/hl1_npc_ichthyosaur.cpp:		if ( m_flLastAttackSound < gpGlobals->curtime )
game/server/hl1/hl1_npc_ichthyosaur.cpp:			m_flLastAttackSound = gpGlobals->curtime + random->RandomFloat( 2.0f, 4.0f );
game/server/hl1/hl1_npc_ichthyosaur.cpp:			m_flNextAlert = gpGlobals->curtime + 0.2;
game/server/hl1/hl1_npc_ichthyosaur.cpp:		if (m_flNextAlert < gpGlobals->curtime)
game/server/hl1/hl1_npc_ichthyosaur.cpp:			m_flNextAlert = gpGlobals->curtime + RandomFloat( 3, 5 );
game/server/hl1/hl1_npc_ichthyosaur.cpp:		m_flEnemyTouched = gpGlobals->curtime + 0.2f;
game/server/hl1/hl1_npc_ichthyosaur.cpp:				if ( m_flEnemyTouched > gpGlobals->curtime && (pHurt->BodyTarget( GetAbsOrigin() ) - GetAbsOrigin()).Length() > (32+16+32) )
game/server/hl1/hl1_npc_ichthyosaur.cpp:	if (m_flBlink < gpGlobals->curtime)
game/server/hl1/hl1_npc_ichthyosaur.cpp:		if (m_flBlink + 0.2 < gpGlobals->curtime)
game/server/hl1/hl1_npc_ichthyosaur.cpp:			m_flBlink = gpGlobals->curtime + random->RandomFloat( 3, 4 );
game/server/hl1/hl1_npc_tentacle.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl1/hl1_npc_tentacle.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_tentacle.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_tentacle.cpp:		if ( gpGlobals->curtime - m_flPrevSoundTime < 0.5 )
game/server/hl1/hl1_npc_tentacle.cpp:			float dt = gpGlobals->curtime - m_flPrevSoundTime;
game/server/hl1/hl1_npc_tentacle.cpp:		m_flPrevSoundTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_tentacle.cpp:		if (m_flSoundTime < gpGlobals->curtime)
game/server/hl1/hl1_npc_tentacle.cpp:		m_flSoundTime = gpGlobals->curtime + random->RandomFloat( 5.0, 10.0 );
game/server/hl1/hl1_npc_tentacle.cpp:		else if ( m_flSoundTime > gpGlobals->curtime )
game/server/hl1/hl1_npc_tentacle.cpp:			if ( MyLevel() >= 0 && gpGlobals->curtime < m_flSoundTime)
game/server/hl1/hl1_npc_tentacle.cpp:				if ( random->RandomInt(0,9) < m_flSoundTime - gpGlobals->curtime )
game/server/hl1/hl1_npc_tentacle.cpp:				if (m_flNextSong < gpGlobals->curtime)
game/server/hl1/hl1_npc_tentacle.cpp:					m_flNextSong = gpGlobals->curtime + random->RandomFloat( 10, 20 );
game/server/hl1/hl1_npc_tentacle.cpp:	if (m_flPrevSoundTime + 2.0 > gpGlobals->curtime)
game/server/hl1/hl1_npc_tentacle.cpp:	else if (m_flPrevSoundTime + 5.0 > gpGlobals->curtime)
game/server/hl1/hl1_npc_tentacle.cpp:		m_flPlaybackRate = m_iDir + m_iDir * (5 - (gpGlobals->curtime - m_flPrevSoundTime)) / 2 + m_flFramerateAdj;
game/server/hl1/hl1_npc_tentacle.cpp:	if (m_flHitTime > gpGlobals->curtime)
game/server/hl1/hl1_npc_tentacle.cpp:		m_flHitTime = gpGlobals->curtime + 0.5;
game/server/hl1/hl1_grenade_mp5.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_grenade_mp5.cpp:	m_fSpawnTime	= gpGlobals->curtime;
game/server/hl1/hl1_npc_zombie.cpp:		if (m_flNextFlinch < gpGlobals->curtime)
game/server/hl1/hl1_npc_zombie.cpp:			m_flNextFlinch = gpGlobals->curtime + ZOMBIE_FLINCH_DELAY;
game/server/hl1/hl1_item_healthkit.cpp:		if (m_flSoundTime <= gpGlobals->curtime)
game/server/hl1/hl1_item_healthkit.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl1/hl1_item_healthkit.cpp:	SetNextThink( gpGlobals->curtime + 0.25 );
game/server/hl1/hl1_item_healthkit.cpp:	if (m_flNextCharge >= gpGlobals->curtime)
game/server/hl1/hl1_item_healthkit.cpp:		m_flSoundTime = 0.56 + gpGlobals->curtime;
game/server/hl1/hl1_item_healthkit.cpp:	if ((m_iOn == 1) && (m_flSoundTime <= gpGlobals->curtime))
game/server/hl1/hl1_item_healthkit.cpp:	m_flNextCharge = gpGlobals->curtime + 0.1;
game/server/hl1/hl1_item_healthkit.cpp:		SetNextThink( gpGlobals->curtime + m_iReactivate );
game/server/hl1/hl1_monstermaker.cpp:		SetNextThink( gpGlobals->curtime + m_flSpawnFrequency );
game/server/hl1/hl1_monstermaker.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_monstermaker.cpp:	SetNextThink( gpGlobals->curtime + m_flSpawnFrequency );
game/server/hl1/hl1_npc_houndeye.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl1/hl1_func_tank.cpp:	float flTimeDelay = gpGlobals->curtime - m_lastSightTime;
game/server/hl1/hl1_func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.1f ); 
game/server/hl1/hl1_func_tank.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl1/hl1_func_tank.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_func_tank.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl1/hl1_func_tank.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl1/hl1_func_tank.cpp:		m_fireLast = gpGlobals->curtime - (1/m_fireRate) - 0.01;  // to make sure the gun doesn't fire too many bullets
game/server/hl1/hl1_func_tank.cpp:		int bulletCount = (gpGlobals->curtime - m_fireLast) * m_fireRate;
game/server/hl1/hl1_func_tank.cpp:		m_flNextAttack = gpGlobals->curtime + (1/m_fireRate);
game/server/hl1/hl1_func_tank.cpp:		SetNextThink( gpGlobals->curtime + 0.05 );
game/server/hl1/hl1_func_tank.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_func_tank.cpp:					SetNextThink( gpGlobals->curtime );	// Think again immediately
game/server/hl1/hl1_func_tank.cpp:						SetNextThink( gpGlobals->curtime + 2 );	// Wait 2 secs
game/server/hl1/hl1_func_tank.cpp:		m_lastSightTime = gpGlobals->curtime;
game/server/hl1/hl1_func_tank.cpp:		int bulletCount = (gpGlobals->curtime - m_fireLast) * m_fireRate;
game/server/hl1/hl1_func_tank.cpp:			m_fireLast = gpGlobals->curtime;
game/server/hl1/hl1_func_tank.cpp:		m_fireLast = gpGlobals->curtime;
game/server/hl1/hl1_func_tank.cpp:	if ( m_pLaser && (gpGlobals->curtime > m_laserTime) )
game/server/hl1/hl1_func_tank.cpp:			m_laserTime = gpGlobals->curtime;
game/server/hl1/hl1_func_tank.cpp:			m_pLaser->SetFireTime( gpGlobals->curtime - 1.0 );
game/server/hl1/hl1_func_tank.cpp:		int bulletCount = (gpGlobals->curtime - m_fireLast) * m_fireRate;
game/server/hl1/hl1_func_tank.cpp:			m_fireLast = gpGlobals->curtime;
game/server/hl1/hl1_func_tank.cpp:		m_fireLast = gpGlobals->curtime;
game/server/hl1/hl1_npc_snark.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_snark.cpp:	m_flNextHit				= gpGlobals->curtime;
game/server/hl1/hl1_npc_snark.cpp:	m_flNextHunt			= gpGlobals->curtime + 1E6;
game/server/hl1/hl1_npc_snark.cpp:	m_flNextBounceSoundTime	= gpGlobals->curtime;
game/server/hl1/hl1_npc_snark.cpp:	m_flDie = gpGlobals->curtime + SQUEEK_DETONATE_DELAY;
game/server/hl1/hl1_npc_snark.cpp:	m_flNextBounceSoundTime = gpGlobals->curtime;// reset each time a snark is spawned.
game/server/hl1/hl1_npc_snark.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_snark.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_snark.cpp:	if ( gpGlobals->curtime >= m_flDie )
game/server/hl1/hl1_npc_snark.cpp:	if ( m_flNextHunt > gpGlobals->curtime )
game/server/hl1/hl1_npc_snark.cpp:	m_flNextHunt = gpGlobals->curtime + 2.0;
game/server/hl1/hl1_npc_snark.cpp:	if ( (m_flDie - gpGlobals->curtime <= 0.5) && (m_flDie - gpGlobals->curtime >= 0.3) )
game/server/hl1/hl1_npc_snark.cpp:	float flpitch = 155.0 - 60.0 * ( (m_flDie - gpGlobals->curtime) / SQUEEK_DETONATE_DELAY );
game/server/hl1/hl1_npc_snark.cpp:	if ( vecVelocity.z < ( 800 * gpGlobals->frametime ) )
game/server/hl1/hl1_npc_snark.cpp:		vecAbsVelocity *= ( 1.0f - trace.fraction ) * gpGlobals->frametime * flSurfaceFriction;
game/server/hl1/hl1_npc_snark.cpp:	if ( m_flNextHit > gpGlobals->curtime) 
game/server/hl1/hl1_npc_snark.cpp:	flpitch = 155.0 - 60.0 * ( ( m_flDie - gpGlobals->curtime ) / SQUEEK_DETONATE_DELAY );
game/server/hl1/hl1_npc_snark.cpp:	if ( pOther->m_takedamage && m_flNextAttack < gpGlobals->curtime )
game/server/hl1/hl1_npc_snark.cpp:				m_flNextAttack = gpGlobals->curtime + 0.5;
game/server/hl1/hl1_npc_snark.cpp:	m_flNextHit = gpGlobals->curtime + 0.1;
game/server/hl1/hl1_npc_snark.cpp:	m_flNextHunt = gpGlobals->curtime;
game/server/hl1/hl1_npc_snark.cpp:		if ( gpGlobals->curtime < m_flNextBounceSoundTime )
game/server/hl1/hl1_npc_snark.cpp:	m_flNextBounceSoundTime = gpGlobals->curtime + 0.5;// half second.
game/server/hl1/hl1_weapon_snark.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.3;
game/server/hl1/hl1_weapon_snark.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 1.0 );
game/server/hl1/hl1_weapon_snark.cpp:			SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/server/hl1/hl1_weapon_snark.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_weapon_snark.cpp:	pPlayer->SetNextAttack( gpGlobals->curtime + 0.5 );
game/server/hl1/hl1_npc_bigmomma.cpp:		if ( m_crabTime < gpGlobals->curtime && m_crabCount < BIG_MAXCHILDREN )
game/server/hl1/hl1_npc_bigmomma.cpp:		if ( m_flDmgTime != gpGlobals->curtime || (random->RandomInt( 0, 10 ) < 1) )
game/server/hl1/hl1_npc_bigmomma.cpp:			m_flDmgTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_bigmomma.cpp:		if ( gpGlobals->curtime > m_painSoundTime )
game/server/hl1/hl1_npc_bigmomma.cpp:			m_painSoundTime = gpGlobals->curtime + random->RandomInt(1, 3);
game/server/hl1/hl1_npc_bigmomma.cpp:		if ( m_nodeTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_bigmomma.cpp:		m_nodeTime = gpGlobals->curtime + pTask->flTaskData;
game/server/hl1/hl1_npc_bigmomma.cpp:					//Msg( "BM: Sequence %s %f\n", GetNodeSequence(), gpGlobals->curtime );
game/server/hl1/hl1_npc_bigmomma.cpp:		m_flWait = gpGlobals->curtime + GetNodeDelay();
game/server/hl1/hl1_npc_bigmomma.cpp:		if ( gpGlobals->curtime > m_flWaitFinished )
game/server/hl1/hl1_npc_bigmomma.cpp:		m_crabTime = gpGlobals->curtime + RandomFloat( 5, 10 );
game/server/hl1/hl1_npc_bigmomma.cpp:		m_crabTime = gpGlobals->curtime + RandomFloat( 0.5, 2.5 );
game/server/hl1/hl1_npc_bigmomma.cpp:	m_mortarTime = gpGlobals->curtime + RandomFloat( 2, 15 );
game/server/hl1/hl1_npc_bigmomma.cpp:	if ( flDist <= BIG_MORTARDIST && m_mortarTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_bigmomma.cpp:	m_flDmgTime = gpGlobals->curtime + 0.4;
game/server/hl1/hl1_npc_bigmomma.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_bigmomma.cpp:	if ( gpGlobals->curtime > m_flDmgTime )
game/server/hl1/hl1_npc_bigmomma.cpp:		m_flDmgTime = gpGlobals->curtime + 0.2;
game/server/hl1/hl1_npc_bigmomma.cpp:	pSpit->SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_hgrunt.cpp:	m_flNextGrenadeCheck = gpGlobals->curtime + 1;
game/server/hl1/hl1_npc_hgrunt.cpp:	m_flNextPainTime	= gpGlobals->curtime;
game/server/hl1/hl1_npc_hgrunt.cpp:	if ( gpGlobals->curtime <= m_flTalkWaitTime )
game/server/hl1/hl1_npc_hgrunt.cpp:	m_flTalkWaitTime = gpGlobals->curtime + random->RandomFloat( 1.5f, 2.0f );
game/server/hl1/hl1_npc_hgrunt.cpp:			pSquadLeader->m_flLastEnemySightTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_hgrunt.cpp:			if ( gpGlobals->curtime - pSquadLeader->m_flLastEnemySightTime > 5 )
game/server/hl1/hl1_npc_hgrunt.cpp:	if (gpGlobals->curtime < m_flNextGrenadeCheck )
game/server/hl1/hl1_npc_hgrunt.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl1/hl1_npc_hgrunt.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl1/hl1_npc_hgrunt.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 0.3; // 1/3 second.
game/server/hl1/hl1_npc_hgrunt.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl1/hl1_npc_hgrunt.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 0.3; // 1/3 second.
game/server/hl1/hl1_npc_hgrunt.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/hl1/hl1_npc_hgrunt.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
game/server/hl1/hl1_npc_hgrunt.cpp:				m_flNextGrenadeCheck = gpGlobals->curtime + random->RandomFloat( 2, 5 );// wait a random amount of time before shooting again
game/server/hl1/hl1_npc_hgrunt.cpp:				m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
game/server/hl1/hl1_npc_hgrunt.cpp:	if ( gpGlobals->curtime > m_flNextPainTime )
game/server/hl1/hl1_npc_hgrunt.cpp:		m_flNextPainTime = gpGlobals->curtime + 1;
game/server/hl1/hl1_npc_hgrunt.cpp:	SetNextThink( gpGlobals->curtime + -4096.0 * tr.fraction / pGrunt->GetAbsVelocity().z + 0.5 );
game/server/hl1/hl1_npc_osprey.cpp:	m_startTime = gpGlobals->curtime + 1;
game/server/hl1/hl1_npc_osprey.cpp:		SetThink( gpGlobals->curtime + 1.0 );
game/server/hl1/hl1_npc_osprey.cpp:			pBeam->SetNextThink( gpGlobals->curtime + -4096.0 * tr.fraction / pGrunt->GetAbsVelocity().z + 0.5 );
game/server/hl1/hl1_npc_osprey.cpp:	if ( m_startTime != 0.0 && m_startTime <= gpGlobals->curtime )
game/server/hl1/hl1_npc_osprey.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_osprey.cpp:	if( gpGlobals->curtime > m_flNextCrashExplosion )
game/server/hl1/hl1_npc_osprey.cpp:		m_flNextCrashExplosion = gpGlobals->curtime + random->RandomFloat( 0.4, 0.7 );
game/server/hl1/hl1_npc_osprey.cpp:		SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl1/hl1_npc_osprey.cpp:	SetNextThink( gpGlobals->curtime + HELICOPTER_THINK_INTERVAL );
game/server/hl1/hl1_npc_osprey.cpp:		SetNextThink( gpGlobals->curtime + HELICOPTER_THINK_INTERVAL );
game/server/hl1/hl1_npc_osprey.cpp:				if (m_flLastSeen < gpGlobals->curtime - 2)
game/server/hl1/hl1_npc_osprey.cpp:					m_flPrevSeen = gpGlobals->curtime;
game/server/hl1/hl1_npc_osprey.cpp:				m_flLastSeen = gpGlobals->curtime;
game/server/hl1/hl1_npc_osprey.cpp:		if ( !IsCrashing() && m_flLastSeen + 5 > gpGlobals->curtime ) //&& DotProduct( targetDir, desiredDir) > 0.25)
game/server/hl1/hl1_npc_osprey.cpp:	// ALERT( at_console, "%.0f %.0f %.0f\n", gpGlobals->curtime, m_flLastSeen, m_flPrevSeen );
game/server/hl1/hl1_npc_osprey.cpp:		if ( (m_flLastSeen + 1 > gpGlobals->curtime) && (m_flPrevSeen + 2 < gpGlobals->curtime) )
game/server/hl1/hl1_npc_osprey.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_npc_osprey.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_osprey.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl1/hl1_npc_osprey.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_osprey.cpp:	m_flNextCrashExplosion = gpGlobals->curtime + 0.0f;
game/server/hl1/hl1_npc_osprey.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_osprey.cpp:		m_flNextRocket = gpGlobals->curtime + 4.0;
game/server/hl1/hl1_npc_osprey.cpp:		m_flNextRocket = gpGlobals->curtime + 15.0;
game/server/hl1/hl1_npc_osprey.cpp:		m_flLastSeen = m_flPrevSeen = gpGlobals->curtime;
game/server/hl1/hl1_npc_barnacle.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/hl1/hl1_npc_barnacle.cpp:	m_flIgnoreTouchesUntil = gpGlobals->curtime;
game/server/hl1/hl1_npc_barnacle.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_barnacle.cpp:				m_flKillVictimTime = gpGlobals->curtime + 10;
game/server/hl1/hl1_npc_barnacle.cpp:				m_flIgnoreTouchesUntil = gpGlobals->curtime + 1.5;
game/server/hl1/hl1_npc_barnacle.cpp:			if ( m_flKillVictimTime != -1 && gpGlobals->curtime > m_flKillVictimTime )
game/server/hl1/hl1_npc_barnacle.cpp:					SetNextThink( gpGlobals->curtime + 1.5f );
game/server/hl1/hl1_npc_barnacle.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_barnacle.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_barnacle.cpp:	if ( m_flIgnoreTouchesUntil > gpGlobals->curtime )
game/server/hl1/hl1_weapon_crowbar.cpp:	if ( (pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime) )
game/server/hl1/hl1_weapon_crowbar.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + CROWBAR_REFIRE_MISS;
game/server/hl1/hl1_weapon_crowbar.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + CROWBAR_REFIRE_HIT;
game/server/hl1/hl1_npc_hornet.cpp:		m_flStopAttack = gpGlobals->curtime + 3.5;
game/server/hl1/hl1_npc_hornet.cpp:		m_flStopAttack	= gpGlobals->curtime + 5.0;
game/server/hl1/hl1_npc_hornet.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_hornet.cpp:	SetNextThink( gpGlobals->curtime + 4 );
game/server/hl1/hl1_npc_hornet.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_hornet.cpp:	if (gpGlobals->curtime > m_flStopAttack)
game/server/hl1/hl1_npc_hornet.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_hornet.cpp:			SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1, 0.3 ) );
game/server/hl1/hl1_npc_hornet.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );// fixed think time
game/server/hl1/hl1_npc_hornet.cpp:			SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl1/hl1_npc_hornet.cpp:			m_flStopAttack = gpGlobals->curtime;
game/server/hl1/hl1mp_bot_temp.cpp:	g_BotData[pPlayer->entindex()-1].m_flJoinTeamTime = gpGlobals->curtime + 0.3;
game/server/hl1/hl1mp_bot_temp.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/hl1/hl1mp_bot_temp.cpp:	if ( bot_mimic.GetInt() > gpGlobals->maxClients )
game/server/hl1/hl1mp_bot_temp.cpp:	float flOldFrametime = gpGlobals->frametime;
game/server/hl1/hl1mp_bot_temp.cpp:	float flOldCurtime = gpGlobals->curtime;
game/server/hl1/hl1mp_bot_temp.cpp:	float flTimeBase = gpGlobals->curtime + gpGlobals->frametime - frametime;
game/server/hl1/hl1mp_bot_temp.cpp:	gpGlobals->frametime = flOldFrametime;
game/server/hl1/hl1mp_bot_temp.cpp:	gpGlobals->curtime = flOldCurtime;
game/server/hl1/hl1mp_bot_temp.cpp:	float frametime = gpGlobals->frametime;
game/server/hl1/hl1mp_bot_temp.cpp:					if ( gpGlobals->curtime < botdata->nextturntime )
game/server/hl1/hl1mp_bot_temp.cpp:				botdata->nextturntime = gpGlobals->curtime + 2.0;
game/server/hl1/hl1mp_bot_temp.cpp:			if ( gpGlobals->curtime >= botdata->nextstrafetime )
game/server/hl1/hl1mp_bot_temp.cpp:				botdata->nextstrafetime = gpGlobals->curtime + 1.0f;
game/server/hl1/hl1_basegrenade.cpp:	SetNextThink( gpGlobals->curtime + 0.3);
game/server/hl1/hl1_npc_gman.cpp:	const char *pMapName = STRING(gpGlobals->mapname);
game/server/hl1/hl1_npc_gman.cpp:		if (m_flTalkTime > gpGlobals->curtime && m_hTalkTarget != NULL)
game/server/hl1/hl1_npc_gman.cpp:	m_flTalkTime = gpGlobals->curtime + delay;
game/server/hl1/hl1_basecombatweapon.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_basecombatweapon.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_roach.cpp:	m_flNextSmellTime	= gpGlobals->curtime;
game/server/hl1/hl1_npc_roach.cpp:	m_flHungryTime = gpGlobals->curtime + flFullDuration;
game/server/hl1/hl1_npc_roach.cpp:	if ( m_flHungryTime > gpGlobals->curtime )
game/server/hl1/hl1_npc_roach.cpp:		SetNextThink( gpGlobals->curtime + random->RandomFloat( 1.0f , 1.5f ) );
game/server/hl1/hl1_npc_roach.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );// keep monster thinking
game/server/hl1/hl1_npc_roach.cpp:	float flInterval = gpGlobals->curtime - GetLastThink();
game/server/hl1/hl1_npc_roach.cpp:		SetNextThink( gpGlobals->curtime + 1 );
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 1 );
game/server/hl1/hl1_npc_turret.cpp:		if ( m_flDamageTime != gpGlobals->curtime || (random->RandomInt(0,10) < 1) )
game/server/hl1/hl1_npc_turret.cpp:			m_flDamageTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_turret.cpp:		m_flDamageTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:		m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:		m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl1/hl1_npc_turret.cpp:			m_flLastSight = gpGlobals->curtime + 0.5; // continue-shooting timeout
game/server/hl1/hl1_npc_turret.cpp:			if (gpGlobals->curtime > m_flLastSight)
game/server/hl1/hl1_npc_turret.cpp:				m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl1/hl1_npc_turret.cpp:			m_flLastSight = gpGlobals->curtime + 0.5;
game/server/hl1/hl1_npc_turret.cpp:			if (gpGlobals->curtime > m_flLastSight)
game/server/hl1/hl1_npc_turret.cpp:				m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:		m_flSpinUpTime = gpGlobals->curtime + m_flMaxSpin;
game/server/hl1/hl1_npc_turret.cpp: 		if (gpGlobals->curtime > m_flLastSight)
game/server/hl1/hl1_npc_turret.cpp:		else if ((m_flSpinUpTime) && (gpGlobals->curtime > m_flSpinUpTime))
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.3 );
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:	if (m_flDamageTime + random->RandomFloat( 0, 2 ) > gpGlobals->curtime)
game/server/hl1/hl1_npc_turret.cpp:	if (m_flDamageTime + random->RandomFloat( 0, 5 ) > gpGlobals->curtime)
game/server/hl1/hl1_npc_turret.cpp:	if (IsSequenceFinished() && !MoveTurret() && m_flDamageTime + 5 < gpGlobals->curtime)
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:	m_flLastSight = gpGlobals->curtime + m_flMaxWait;
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:				SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:		m_flPingTime = gpGlobals->curtime + 1;
game/server/hl1/hl1_npc_turret.cpp:	else if (m_flPingTime <= gpGlobals->curtime)
game/server/hl1/hl1_npc_turret.cpp:		m_flPingTime = gpGlobals->curtime + 1;
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 ); // turn on delay
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 ); // turn on delay
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.3 ); 
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:			SetNextThink( gpGlobals->curtime + 1.0 );	//spinup delay
game/server/hl1/hl1_npc_turret.cpp:			SetNextThink( gpGlobals->curtime + 0.1 );// retarget delay
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink(gpGlobals->curtime + 0.3); 
game/server/hl1/hl1_npc_turret.cpp:	SetNextThink(gpGlobals->curtime + 0.3); 
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_turret.cpp:		m_flDamageTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_turret.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_hassassin.cpp:	if ( m_flNextJump < gpGlobals->curtime && ( flDist <= 128 || HasMemory( MEMORY_BADJUMP )) && GetEnemy() != NULL )
game/server/hl1/hl1_npc_hassassin.cpp:	if ( m_flNextGrenadeCheck < gpGlobals->curtime && !HasCondition( COND_ENEMY_OCCLUDED ) && flDist <= 512 )
game/server/hl1/hl1_npc_hassassin.cpp:		m_flWaitFinished = gpGlobals->curtime + 2.0f;
game/server/hl1/hl1_npc_hassassin.cpp:		else if( gpGlobals->curtime > m_flWaitFinished || GetAbsVelocity().z == 0.0 )
game/server/hl1/hl1_npc_hassassin.cpp:				m_flWaitFinished = gpGlobals->curtime + 2.0f;
game/server/hl1/hl1_npc_hassassin.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
game/server/hl1/hl1_npc_hassassin.cpp:			m_flNextJump = gpGlobals->curtime + 3.0;
game/server/hl1/hl1_npc_hassassin.cpp:	if (m_flLastShot + 2 < gpGlobals->curtime)
game/server/hl1/hl1_npc_hassassin.cpp:	m_flLastShot = gpGlobals->curtime;
game/server/hl1/hl1_npc_hassassin.cpp:			if (m_flNextJump > gpGlobals->curtime)
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_ents.cpp:	if( gpGlobals->curtime > m_flTimeRefireDone )
game/server/hl1/hl1_ents.cpp:		SetNextThink( gpGlobals->curtime + m_flRefireInterval );
game/server/hl1/hl1_ents.cpp:		m_flTimeRefireDone = gpGlobals->curtime + m_flRefireDuration;
game/server/hl1/hl1_ents.cpp:		SetNextThink( gpGlobals->curtime + m_flRefireInterval );
game/server/hl1/hl1_ents.cpp:	t = gpGlobals->curtime - m_startTime;
game/server/hl1/hl1_ents.cpp:	m_startTime = gpGlobals->curtime;
game/server/hl1/hl1_ents.cpp:	//m_fEnableTime = gpGlobals->curtime + m_OnTrigger.GetMaxDelay();
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_ents.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_ents.cpp:			SetNextThink( gpGlobals->curtime + delta / m_flMaxSpeed);
game/server/hl1/hl1_ents.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );		// Start the pendulum moving
game/server/hl1/hl1_ents.cpp:		m_flTime = gpGlobals->curtime;		// Save time to calculate dt
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );		// Start the pendulum moving
game/server/hl1/hl1_ents.cpp:	m_flTime = gpGlobals->curtime;				// Save time to calculate dt
game/server/hl1/hl1_ents.cpp:	m_flTime = gpGlobals->curtime;
game/server/hl1/hl1_ents.cpp:	dt = gpGlobals->curtime - m_flTime;	// How much time has passed?
game/server/hl1/hl1_ents.cpp:	m_flTime = gpGlobals->curtime;		// Remember the last time called
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_ents.cpp:		pMortar->SetNextThink( gpGlobals->curtime + t );
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_ents.cpp:		if ( gpGlobals->curtime > m_flDmgTime )
game/server/hl1/hl1_ents.cpp:		m_flDmgTime = gpGlobals->curtime + XEN_PLANT_HIDE_TIME;
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1, 0.4 ) );	// Load balance these a bit
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1f, 0.4f ) );	// Load balance these a bit
game/server/hl1/hl1_ents.cpp:		SetNextThink( gpGlobals->curtime + m_lifeTime );
game/server/hl1/hl1_ents.cpp:		SetNextThink( gpGlobals->curtime + 0.5 );
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 10 );
game/server/hl1/hl1_ents.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_ents.cpp:	SetNextThink( gpGlobals->curtime + 4 );
game/server/hl1/hl1_ents.cpp:	if ( gpGlobals->deathmatch )
game/server/hl1/hl1_npc_gargantua.cpp:	SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_npc_gargantua.cpp:	m_flDmgTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_gargantua.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_gargantua.cpp:	Vector vecEnd = vecStart + (m_vecMoveDir * m_flSpeed * gpGlobals->frametime);
game/server/hl1/hl1_npc_gargantua.cpp:	m_flSpeed += (gpGlobals->frametime) * m_uiFramerate;
game/server/hl1/hl1_npc_gargantua.cpp:	m_uiFramerate += (gpGlobals->frametime) * 2000;
game/server/hl1/hl1_npc_gargantua.cpp:	if ( gpGlobals->curtime - m_flDmgTime > 0.2f )
game/server/hl1/hl1_npc_gargantua.cpp:		m_flDmgTime = gpGlobals->curtime - 0.2f;
game/server/hl1/hl1_npc_gargantua.cpp:	while ( gpGlobals->curtime - m_flDmgTime > STOMP_INTERVAL )
game/server/hl1/hl1_npc_gargantua.cpp:				pSprite->SetNextThink( gpGlobals->curtime + 0.3 );
game/server/hl1/hl1_npc_gargantua.cpp:	m_seeTime = gpGlobals->curtime + 5;
game/server/hl1/hl1_npc_gargantua.cpp:	m_flameTime = gpGlobals->curtime + 2;
game/server/hl1/hl1_npc_gargantua.cpp:		m_seeTime = gpGlobals->curtime + 5;
game/server/hl1/hl1_npc_gargantua.cpp:	if ( gpGlobals->curtime > m_flameTime )
game/server/hl1/hl1_npc_gargantua.cpp:	if ( gpGlobals->curtime > m_seeTime )
game/server/hl1/hl1_npc_gargantua.cpp:		m_seeTime = gpGlobals->curtime + 12;
game/server/hl1/hl1_npc_gargantua.cpp:		m_flWaitFinished = gpGlobals->curtime + pTask->flTaskData;
game/server/hl1/hl1_npc_gargantua.cpp:		m_flameTime = gpGlobals->curtime + 6;
game/server/hl1/hl1_npc_gargantua.cpp:		m_flWaitFinished = gpGlobals->curtime + 1.6;
game/server/hl1/hl1_npc_gargantua.cpp:		if ( gpGlobals->curtime > m_flWaitFinished )
game/server/hl1/hl1_npc_gargantua.cpp:			SetNextThink( gpGlobals->curtime + 0.15 );
game/server/hl1/hl1_npc_gargantua.cpp:				pGib->SetNextThink( gpGlobals->curtime + 1.25 );
game/server/hl1/hl1_npc_gargantua.cpp:		if ( gpGlobals->curtime > m_flWaitFinished )
game/server/hl1/hl1_npc_gargantua.cpp:			//FlameControls( angles.x + 2 * sin(gpGlobals->curtime*8), angles.y + 28 * sin(gpGlobals->curtime*8.5) );
game/server/hl1/hl1_npc_gargantua.cpp:			Vector vecEnd = vecStart + ( vForward * GARG_FLAME_LENGTH); //  - offset[i] * gpGlobals->v_right;
game/server/hl1/hl1_npc_gargantua.cpp:			if ( trace.fraction != 1.0 && gpGlobals->curtime > m_streakTime )
game/server/hl1/hl1_npc_gargantua.cpp:		m_streakTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_gargantua.cpp:		if ( m_painSoundTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_gargantua.cpp:			m_painSoundTime = gpGlobals->curtime + random->RandomFloat( 2.5, 4 );
game/server/hl1/hl1_npc_gargantua.cpp:		if ( m_flDmgTime != gpGlobals->curtime || (random->RandomInt( 0, 100 ) < 20) )
game/server/hl1/hl1_npc_gargantua.cpp:			m_flDmgTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_aflock.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_aflock.cpp:		pBoid->SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl1/hl1_npc_aflock.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_aflock.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl1/hl1_npc_aflock.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_aflock.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_aflock.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_aflock.cpp:	if ( m_flFlockNextSoundTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_aflock.cpp:		m_flFlockNextSoundTime = gpGlobals->curtime + random->RandomFloat( 1, 3 );
game/server/hl1/hl1_npc_aflock.cpp:	if ( m_flFakeBlockedTime > gpGlobals->curtime )
game/server/hl1/hl1_npc_aflock.cpp:		m_flLastBlockedTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_aflock.cpp:		m_flLastBlockedTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_aflock.cpp:		m_flLastBlockedTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_aflock.cpp:		m_flLastBlockedTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_aflock.cpp:	if ( !fBlocked && gpGlobals->curtime - m_flLastBlockedTime > 6 )
game/server/hl1/hl1_npc_aflock.cpp:		m_flFakeBlockedTime = gpGlobals->curtime + random->RandomInt(1, 3); 
game/server/hl1/hl1_npc_aflock.cpp:	if ( m_flAlertTime > gpGlobals->curtime )
game/server/hl1/hl1_npc_aflock.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_aflock.cpp:		pSquad->m_flAlertTime = gpGlobals->curtime + 15;
game/server/hl1/hl1_npc_aflock.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_aflock.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_scientist.cpp:	SetNextThink( gpGlobals->curtime + delay );
game/server/hl1/hl1_npc_scientist.cpp:			SetNextThink( gpGlobals->curtime + 5 );
game/server/hl1/hl1_npc_scientist.cpp:	float dt = gpGlobals->frametime;
game/server/hl1/hl1_npc_scientist.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_npc_scientist.cpp:		GetExpresser()->BlockSpeechUntil( gpGlobals->curtime + 10 );
game/server/hl1/hl1_npc_scientist.cpp:		GetExpresser()->BlockSpeechUntil( gpGlobals->curtime + 2 );
game/server/hl1/hl1_npc_scientist.cpp:			GetExpresser()->BlockSpeechUntil( gpGlobals->curtime + 2 );
game/server/hl1/hl1_npc_scientist.cpp:	if ( (m_flHealTime > gpGlobals->curtime) || (pTarget->m_iHealth > (pTarget->m_iMaxHealth * 0.5)) )
game/server/hl1/hl1_npc_scientist.cpp:	if (gpGlobals->curtime < m_flPainTime )
game/server/hl1/hl1_npc_scientist.cpp:	m_flPainTime = gpGlobals->curtime + random->RandomFloat( 0.5, 0.75 );
game/server/hl1/hl1_npc_scientist.cpp:	m_flHealTime = gpGlobals->curtime + 60;
game/server/hl1/hl1_npc_scientist.cpp:				m_flFearTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_scientist.cpp:					if ( gpGlobals->curtime - m_flFearTime > 3 )	// Only cower every 3 seconds or so
game/server/hl1/hl1_npc_scientist.cpp:						m_flFearTime = gpGlobals->curtime;		// Update last fear
game/server/hl1/hl1_npc_scientist.cpp:					m_flFearTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_scientist.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_scientist.cpp:		if (m_flResponseDelay && gpGlobals->curtime > m_flResponseDelay)
game/server/hl1/hl1_npc_scientist.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_npc_scientist.cpp:	m_flResponseDelay = gpGlobals->curtime + random->RandomFloat(3, 4);
game/server/hl1/hl1_func_recharge.cpp:		if (m_flSoundTime <= gpGlobals->curtime)
game/server/hl1/hl1_func_recharge.cpp:			m_flSoundTime = gpGlobals->curtime + 0.62;
game/server/hl1/hl1_func_recharge.cpp:	SetNextThink( gpGlobals->curtime + 0.25 );
game/server/hl1/hl1_func_recharge.cpp:	if (m_flNextCharge >= gpGlobals->curtime)
game/server/hl1/hl1_func_recharge.cpp:		m_flSoundTime = 0.56 + gpGlobals->curtime;
game/server/hl1/hl1_func_recharge.cpp:	if ((m_iOn == 1) && (m_flSoundTime <= gpGlobals->curtime))
game/server/hl1/hl1_func_recharge.cpp:	m_flNextCharge = gpGlobals->curtime + 0.1;
game/server/hl1/hl1_func_recharge.cpp:		SetNextThink( gpGlobals->curtime + m_iReactivate );
game/server/hl1/hl1mp_player.cpp://	SetContextThink( &CTFCPlayer::TFCPlayerThink, gpGlobals->curtime, "TFCPlayerThink" );
game/server/hl1/hl1mp_player.cpp:	m_flNextTeamChangeTime = gpGlobals->curtime + 5;
game/server/hl1/hl1mp_player.cpp:	m_flNextModelChangeTime = gpGlobals->curtime + 5;
game/server/hl1/hl1mp_player.cpp:	m_flNextModelChangeTime = gpGlobals->curtime + 5;
game/server/hl1/hl1_npc_barney.cpp:	if ( gpGlobals->curtime > m_flCheckAttackTime )
game/server/hl1/hl1_npc_barney.cpp:		m_flCheckAttackTime = gpGlobals->curtime + 1;
game/server/hl1/hl1_npc_barney.cpp:		m_flCheckAttackTime = gpGlobals->curtime + 1.5;
game/server/hl1/hl1_npc_barney.cpp:	if (gpGlobals->curtime < m_flPainTime)
game/server/hl1/hl1_npc_barney.cpp:	m_flPainTime = gpGlobals->curtime + random->RandomFloat( 0.5, 0.75 );
game/server/hl1/hl1_npc_barney.cpp:	SetNextThink( gpGlobals->curtime + delay );
game/server/hl1/hl1_npc_barney.cpp:			SetNextThink( gpGlobals->curtime + 5 );
game/server/hl1/hl1_npc_barney.cpp:	float dt = gpGlobals->frametime;
game/server/hl1/hl1_npc_barney.cpp:		SetNextThink( gpGlobals->curtime );
game/server/hl1/hl1_npc_headcrab.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/hl1/hl1_npc_headcrab.cpp:			m_flNextAttack = gpGlobals->curtime + 2;
game/server/hl1/hl1_npc_leech.cpp:	m_stateTime = gpGlobals->curtime + random->RandomFloat( 1, 5 );
game/server/hl1/hl1_npc_leech.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_leech.cpp:	if ( gpGlobals->curtime > m_attackSoundTime )
game/server/hl1/hl1_npc_leech.cpp:		m_attackSoundTime = gpGlobals->curtime + 0.5;
game/server/hl1/hl1_npc_leech.cpp:	m_stateTime = gpGlobals->curtime + random->RandomFloat( 3, 6 );
game/server/hl1/hl1_npc_leech.cpp:			m_stateTime = gpGlobals->curtime + random->RandomFloat( 18, 25 );
game/server/hl1/hl1_npc_leech.cpp:	m_waterTime = gpGlobals->curtime + random->RandomFloat( 5, 7 );
game/server/hl1/hl1_npc_leech.cpp:		m_flNextThink = gpGlobals->curtime + random->RandomFloat( 1.0f, 1.5f );
game/server/hl1/hl1_npc_leech.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_leech.cpp:	if ( m_waterTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_leech.cpp:	if ( m_stateTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_leech.cpp:		if ( m_zTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_leech.cpp:			m_zTime = gpGlobals->curtime + random->RandomFloat( 1, 4 );
game/server/hl1/hl1_npc_leech.cpp:	if ( m_sideTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_leech.cpp:		m_sideTime = gpGlobals->curtime + random->RandomFloat(0.5,1);
game/server/hl1/hl1_npc_leech.cpp:		m_waterTime = gpGlobals->curtime + 2;	// Recalc again soon, water may be rising
game/server/hl1/hl1_npc_scientist.h:	bool	DisregardEnemy( CBaseEntity *pEnemy ) { return !pEnemy->IsAlive() || (gpGlobals->curtime - m_flFearTime) > 15; }
game/server/hl1/hl1_npc_bullsquid.cpp:	m_flNextSpitTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_bullsquid.cpp:	if ( flDist > 85 && flDist <= 784 && flDot >= 0.5 && gpGlobals->curtime >= m_flNextSpitTime )
game/server/hl1/hl1_npc_bullsquid.cpp:			m_flNextSpitTime = gpGlobals->curtime + 5;
game/server/hl1/hl1_npc_bullsquid.cpp:			m_flNextSpitTime = gpGlobals->curtime + 0.5;
game/server/hl1/hl1_npc_bullsquid.cpp:	if ( m_flHungryTime > gpGlobals->curtime )
game/server/hl1/hl1_npc_bullsquid.cpp:	if ( gpGlobals->curtime - m_flLastHurtTime <= 20 )
game/server/hl1/hl1_npc_bullsquid.cpp:	if ( gpGlobals->curtime - m_flLastHurtTime < 5 && FClassnameIs ( pTarget, "monster_headcrab" ) )
game/server/hl1/hl1_npc_bullsquid.cpp:	if ( GetEnemy() != NULL && IsMoving() && pevAttacker == GetEnemy() && gpGlobals->curtime - m_flLastHurtTime > 3 )
game/server/hl1/hl1_npc_bullsquid.cpp:		m_flLastHurtTime = gpGlobals->curtime;
game/server/hl1/hl1_npc_bullsquid.cpp:			m_flHungryTime = gpGlobals->curtime + pTask->flTaskData;
game/server/hl1/hl1_env_speaker.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_env_speaker.cpp:		SetNextThink( gpGlobals->curtime + random->RandomFloat( 5.0, 15.0 ) );
game/server/hl1/hl1_env_speaker.cpp:		SetNextThink( gpGlobals->curtime + releaseTime + random->RandomFloat( 5, 10 ) );
game/server/hl1/hl1_env_speaker.cpp:		SetNextThink ( gpGlobals->curtime + 
game/server/hl1/hl1_env_speaker.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_env_speaker.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_npc_agrunt.cpp:	m_flNextSpeakTime	= m_flNextWordTime = gpGlobals->curtime + 10 + random->RandomInt( 0, 10 );
game/server/hl1/hl1_npc_agrunt.cpp:	if ( m_flNextPainTime > gpGlobals->curtime )
game/server/hl1/hl1_npc_agrunt.cpp:	m_flNextPainTime = gpGlobals->curtime + 0.6;
game/server/hl1/hl1_npc_agrunt.cpp:	if ( m_flNextSpeakTime > gpGlobals->curtime )
game/server/hl1/hl1_npc_agrunt.cpp:			m_flNextSpeakTime = gpGlobals->curtime + 3;
game/server/hl1/hl1_npc_agrunt.cpp:		if ( m_flNextWordTime < gpGlobals->curtime )
game/server/hl1/hl1_npc_agrunt.cpp:				m_flNextWordTime = gpGlobals->curtime + random->RandomFloat( 0.5, 1 );
game/server/hl1/hl1_npc_agrunt.cpp:	if ( gpGlobals->curtime < m_flNextHornetAttackCheck )
game/server/hl1/hl1_npc_agrunt.cpp:			m_flNextHornetAttackCheck = gpGlobals->curtime + random->RandomFloat( 2, 5 );
game/server/hl1/hl1_npc_agrunt.cpp:	m_flNextHornetAttackCheck = gpGlobals->curtime + 0.2;// don't check for half second if this check wasn't successful
game/server/hl1/hl1_npc_agrunt.cpp:	m_flNextWordTime = m_flNextSpeakTime = gpGlobals->curtime + 10 + random->RandomInt(0, 10);
game/server/hl1/hl1_npc_agrunt.cpp:			SetLastAttackTime( gpGlobals->curtime );
game/server/hl1/hl1_npc_agrunt.cpp:		if ( m_flDamageTime != gpGlobals->curtime || (random->RandomInt(0,10) < 1) )
game/server/hl1/hl1_npc_agrunt.cpp:			m_flDamageTime = gpGlobals->curtime;
game/server/hl1/hl1_weapon_tripmine.cpp:				SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/server/hl1/hl1_weapon_tripmine.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/server/hl1/hl1_weapon_tripmine.cpp:			SetWeaponIdleTime( gpGlobals->curtime ); // MO curtime correct ?
game/server/hl1/hl1_weapon_tripmine.cpp:		SetWeaponIdleTime( m_flTimeWeaponIdle = gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/server/hl1/hl1_weapon_tripmine.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_weapon_tripmine.cpp:	pPlayer->SetNextAttack( gpGlobals->curtime + 0.5 );
game/server/hl1/hl1_weapon_tripmine.cpp:		m_flPowerUp = gpGlobals->curtime + 1.0;
game/server/hl1/hl1_weapon_tripmine.cpp:		m_flPowerUp = gpGlobals->curtime + 2.5;
game/server/hl1/hl1_weapon_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/server/hl1/hl1_weapon_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl1/hl1_weapon_tripmine.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_weapon_tripmine.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_weapon_tripmine.cpp:			SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_weapon_tripmine.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_weapon_tripmine.cpp:	if ( gpGlobals->curtime > m_flPowerUp )
game/server/hl1/hl1_weapon_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_weapon_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 1.0f );
game/server/hl1/hl1_weapon_tripmine.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/hl1/hl1_weapon_tripmine.cpp:	if (gpGlobals->curtime < m_flPowerUp && info.GetDamage() < m_iHealth)
game/server/hl1/hl1_weapon_tripmine.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/hl1/hl1_weapon_tripmine.cpp:	SetNextThink( gpGlobals->curtime + random->RandomFloat( 0.1, 0.3 ) );
game/server/hl1/hl1_npc_talker.cpp:			if ( gpGlobals->curtime > m_flWaitFinished )
game/server/hl1/hl1_npc_talker.cpp:				IdleHeadTurn( GetSpeechTarget(), GetExpresser()->GetTimeSpeechComplete() - gpGlobals->curtime );
game/server/hl1/hl1_npc_talker.cpp:				if ( gpGlobals->curtime > m_flWaitFinished && GetMotor()->DeltaIdealYaw() < 10 )
game/server/hl1/hl1_npc_talker.cpp:				// ALERT( at_console, "waiting %f\n", m_flStopTalkTime - gpGlobals->time );
game/server/hl1/hl1_npc_talker.cpp:				IdleHeadTurn( GetSpeechTarget(), GetExpresser()->GetTimeSpeechComplete() - gpGlobals->curtime );
game/server/hl1/hl1_npc_talker.cpp:				IdleHeadTurn( GetSpeechTarget(), GetExpresser()->GetTimeSpeechComplete() - gpGlobals->curtime );
game/server/hl1/hl1_npc_talker.cpp:		GetExpresser()->BlockSpeechUntil( gpGlobals->curtime + random->RandomFloat(4.8, 5.2) );
game/server/hl1/hl1_npc_talker.cpp:		GetExpresser()->BlockSpeechUntil( gpGlobals->curtime + random->RandomFloat(4.8, 5.2) );
game/server/hl1/hl1_npc_talker.cpp:	m_flNextIdleSpeechTime = gpGlobals->curtime + 3;
game/server/hl1/hl1_npc_talker.cpp:	if ( GetUseTime() > gpGlobals->curtime )
game/server/hl1/hl1_player.cpp:	if (abs(gpGlobals->curtime - m_tbdPrev) < 2.0)
game/server/hl1/hl1_player.cpp:	m_tbdPrev = gpGlobals->curtime;
game/server/hl1/hl1_player.cpp:		m_flLastDamageTime = gpGlobals->curtime;
game/server/hl1/hl1_player.cpp:				m_tbdPrev = gpGlobals->curtime;
game/server/hl1/hl1_player.cpp:	if ( m_flTargetFindTime > gpGlobals->curtime )
game/server/hl1/hl1_player.cpp:	m_flTargetFindTime	= gpGlobals->curtime + 1.0f;
game/server/hl1/hl1_player.cpp:		m_flFlashLightTime = FLASH_DRAIN_TIME + gpGlobals->curtime;
game/server/hl1/hl1_player.cpp:	m_flFlashLightTime = FLASH_CHARGE_TIME + gpGlobals->curtime;
game/server/hl1/hl1_player.cpp:	if ( ( m_flFlashLightTime ) && ( m_flFlashLightTime <= gpGlobals->curtime ) )
game/server/hl1/hl1_player.cpp:				m_flFlashLightTime = FLASH_DRAIN_TIME + gpGlobals->curtime;
game/server/hl1/hl1_player.cpp:				m_flFlashLightTime = FLASH_CHARGE_TIME + gpGlobals->curtime;
game/server/hl1/hl1_player.cpp:	m_timeToArrive = gpGlobals->frametime;
game/server/hl1/hl1_npc_vortigaunt.cpp:			m_flNextAttack = gpGlobals->curtime + random->RandomFloat( 0.5, 4.0 );
game/server/hl1/hl1_npc_vortigaunt.cpp:	if ( gpGlobals->curtime < m_flNextAttack )
game/server/PointAngularVelocitySensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/PointAngularVelocitySensor.cpp:			float dt = gpGlobals->curtime - GetLastThink();
game/server/PointAngularVelocitySensor.cpp:				m_flFireTime = gpGlobals->curtime + m_flFireInterval;
game/server/PointAngularVelocitySensor.cpp:		else if ((m_flFireTime != 0) && (gpGlobals->curtime >= m_flFireTime))
game/server/PointAngularVelocitySensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/PointAngularVelocitySensor.cpp:		m_flFireTime = gpGlobals->curtime + m_flFireInterval;
game/server/PointAngularVelocitySensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/PointAngularVelocitySensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/PointAngularVelocitySensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/PointAngularVelocitySensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/smoke_trail.cpp:		m_StopEmitTime = gpGlobals->curtime + atof( szValue );
game/server/smoke_trail.cpp:		m_StopEmitTime = gpGlobals->curtime + atof( szValue );
game/server/MaterialModifyControl.cpp:	Q_snprintf( temp, 32, "%f", gpGlobals->curtime );
game/server/scriptedtarget.cpp:	SetNextThink( gpGlobals->curtime );
game/server/scriptedtarget.cpp:		m_flPauseDoneTime = gpGlobals->curtime + m_flPauseDuration;
game/server/scriptedtarget.cpp:	if (gpGlobals->curtime >= m_flPauseDoneTime)
game/server/scriptedtarget.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/basecombatweapon.cpp:		pNewWeapon->SetNextThink( gpGlobals->curtime + g_pGameRules->FlWeaponRespawnTime( this ) );
game/server/basecombatweapon.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/basecombatweapon.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/basecombatweapon.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/basecombatweapon.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/basecombatweapon.cpp:	SetNextThink( gpGlobals->curtime + time );
game/server/pointanglesensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/pointanglesensor.cpp:						m_flFacingTime = gpGlobals->curtime;
game/server/pointanglesensor.cpp:					if (gpGlobals->curtime >= m_flFacingTime + m_flDuration)
game/server/pointanglesensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/pointanglesensor.cpp:			SetNextThink( gpGlobals->curtime );
game/server/pointanglesensor.cpp:		SetNextThink(gpGlobals->curtime);
game/server/pointanglesensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/pointanglesensor.cpp:			SetNextThink( gpGlobals->curtime );
game/server/pointanglesensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/pointanglesensor.cpp:		SetNextThink( gpGlobals->curtime );
game/server/fourwheelvehiclephysics.cpp:	float retval = m_pVehicle->UpdateBooster(gpGlobals->frametime );
game/server/fourwheelvehiclephysics.cpp:	m_pVehicle->Update( gpGlobals->frametime, m_controls);
game/server/fourwheelvehiclephysics.cpp:		m_turboTimer = gpGlobals->curtime + 2.75f;		// min duration for turbo sound
game/server/fourwheelvehiclephysics.cpp:		if ( gpGlobals->curtime >= m_turboTimer )
game/server/fourwheelvehiclephysics.cpp:	m_actionValue += m_actionSpeed * m_actionScale * gpGlobals->frametime;
game/server/fourwheelvehiclephysics.cpp:	m_controls.steering = Approach(0, m_controls.steering, flSteeringRate * gpGlobals->frametime );
game/server/fourwheelvehiclephysics.cpp:	flSteeringRate *= gpGlobals->frametime;
game/server/fourwheelvehiclephysics.cpp:	flSteeringRate *= gpGlobals->frametime;
game/server/fourwheelvehiclephysics.cpp:	SetSteering( flSign * flSteerAdj, flSteeringRate * gpGlobals->frametime );
game/server/fourwheelvehiclephysics.cpp:		m_throttleStartTime = gpGlobals->curtime;		// need to track how long throttle is down
game/server/fourwheelvehiclephysics.cpp:		m_throttleActiveTime = gpGlobals->curtime - m_throttleStartTime;
game/server/message_entity.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/message_entity.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/server/monstermaker.cpp:	m_TimeNextAvailable = gpGlobals->curtime;
game/server/monstermaker.cpp:	if( m_TimeNextAvailable > gpGlobals->curtime )
game/server/monstermaker.cpp:	m_TimeNextAvailable = gpGlobals->curtime + m_ReuseDelay;
game/server/monstermaker.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/monstermaker.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/monstermaker.cpp:	SetNextThink( gpGlobals->curtime );
game/server/monstermaker.cpp:	SetNextThink( gpGlobals->curtime + m_flSpawnFrequency );
game/server/npc_talker.cpp:	if ( m_flNextIdleSpeechTime > gpGlobals->curtime )
game/server/npc_talker.cpp:	float flTime = gpGlobals->curtime + flDelay;
game/server/npc_talker.cpp:			m_flNextIdleSpeechTime = gpGlobals->curtime + 3;
game/server/npc_talker.cpp:	m_flNextIdleSpeechTime = gpGlobals->curtime + 3;
game/server/npc_talker.cpp:	m_useTime = gpGlobals->curtime + delay;
game/server/npc_talker.cpp:	if ( m_useTime > gpGlobals->curtime )
game/server/subs.cpp:			DevMsg( 2, "[%03d] Found: %s, firing (%s)\n", gpGlobals->tickcount%1000, pTarget->GetDebugName(), targetName );
game/server/physics_impact_damage.cpp:		if ( gpGlobals->maxClients == 1 )
game/server/physics_impact_damage.cpp:		if ( gpGlobals->maxClients == 1 )
game/server/ai_motor.cpp:		// GetOuter()->SetCycle( flTime - gpGlobals->curtime );
game/server/ai_motor.cpp:	float dt = MIN( 0.2, gpGlobals->curtime - GetLastThink() );
game/server/intermission.cpp:	SetNextThink( gpGlobals->curtime + 2 );// let targets spawn !
game/server/waterbullet.cpp:	SetNextThink( gpGlobals->curtime );
game/server/waterbullet.cpp:	SetNextThink( gpGlobals->curtime + 0.05 );
game/server/weapon_adot.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + RETHROW_DELAY;
game/server/weapon_adot.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + RETHROW_DELAY;
game/server/weapon_adot.cpp:	if ((m_bRedraw) && (m_flNextPrimaryAttack <= gpGlobals->curtime) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/server/weapon_adot.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/weapon_adot.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/server/weapon_adot.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/server/physics_cannister.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/physics_cannister.cpp:	if ( (gpGlobals->curtime - m_activateTime) <= 0.1 )
game/server/physics_cannister.cpp:	m_activateTime = gpGlobals->curtime;
game/server/physics_cannister.cpp:	SetNextThink( gpGlobals->curtime + m_thrustTime );
game/server/physics_cannister.cpp:	SetPhysicsAttacker( pPhysGunUser, gpGlobals->curtime );
game/server/physics_cannister.cpp:	SetPhysicsAttacker( pPhysGunUser, gpGlobals->curtime );
game/server/physics_cannister.cpp:	if (gpGlobals->curtime - dt <= m_flLastPhysicsInfluenceTime)
game/server/trigger_portal.cpp:	SetContextThink( DisabledThink, gpGlobals->curtime + 0.1, TRIGGER_DISABLED_THINK );
game/server/trigger_portal.cpp:		SetContextThink( NULL, gpGlobals->curtime, TRIGGER_DISABLED_THINK );
game/server/trigger_portal.cpp:	SetContextThink( DisabledThink, gpGlobals->curtime + 0.1, TRIGGER_DISABLED_THINK );
game/server/baseentity.h:	float flNavIgnoreUntilTime = ( duration == FLT_MAX ) ? FLT_MAX : gpGlobals->curtime + duration;
game/server/baseentity.h:	return ( gpGlobals->curtime <= m_flNavIgnoreUntilTime );
game/server/trigger_area_capture.cpp:	SetNextThink( gpGlobals->curtime + AREA_THINK_TIME );
game/server/trigger_area_capture.cpp:	SetNextThink( gpGlobals->curtime + AREA_THINK_TIME );
game/server/trigger_area_capture.cpp:			m_hPoint->SetLastContestedAt( gpGlobals->curtime );
game/server/trigger_area_capture.cpp:		float flTimeDelta = gpGlobals->curtime - m_flLastReductionTime;
game/server/trigger_area_capture.cpp:		m_flLastReductionTime = gpGlobals->curtime;
game/server/trigger_area_capture.cpp:							 ( TeamplayGameRules()->PointsMayAlwaysBeBlocked() && m_Blockers[i].flNextBlockTime < gpGlobals->curtime && m_bStartTouch ) )
game/server/trigger_area_capture.cpp:						m_Blockers[iNew].flNextBlockTime = gpGlobals->curtime + 10.0f;
game/server/trigger_area_capture.cpp:	m_flLastReductionTime = gpGlobals->curtime;
game/server/trigger_area_capture.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/weapon_ar1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 6;// wait six seconds before even looking again to see if a grenade can be thrown.
game/server/weapon_ar1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/server/weapon_ar1.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/server/weapon_ar1.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f;
game/server/weapon_ar1.cpp:	//pPlayer->SetMuzzleFlashTime(gpGlobals->curtime + 0.5);
game/server/weapon_ar1.cpp:	if (m_bForbidIronsight && gpGlobals->curtime >= m_flNextPrimaryAttack)
game/server/weapon_ar1.cpp:	if (gpGlobals->curtime < m_flNextGrenadeCheck )
game/server/weapon_ar1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/weapon_ar1.cpp:			m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/weapon_ar1.cpp:		//m_flNextGrenadeCheck = gpGlobals->curtime;
game/server/weapon_ar1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 0.3; // 1/3 second.
game/server/weapon_ar1.cpp:		m_flNextGrenadeCheck = gpGlobals->curtime + 1; // one full second.
game/server/weapon_ar1.cpp:	while (m_flNextPrimaryAttack <= gpGlobals->curtime)
game/server/physgun.cpp:		m_timeToArrive = gpGlobals->frametime;
game/server/physgun.cpp:				m_distance = UTIL_Approach( 1024, m_distance, gpGlobals->frametime * 100 );
game/server/physgun.cpp:				m_distance = UTIL_Approach( 40, m_distance, gpGlobals->frametime * 100 );
game/server/physgun.cpp:			float maxDist = m_gravCallback.m_maxVel * gpGlobals->frametime;
game/server/physgun.cpp:			m_glueTime = gpGlobals->curtime + 1;
game/server/physgun.cpp:		if ( m_pelletHeld >= 0 && gpGlobals->curtime > m_glueTime )
game/server/physgun.cpp:	if ( m_pelletHeld >= 0 && gpGlobals->curtime > m_glueTime )
game/server/physgun.cpp:		m_glueTime = gpGlobals->curtime;
game/server/physgun.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.1;
game/server/physgun.cpp:					m_flNextPrimaryAttack = gpGlobals->curtime + 0.75;
game/server/ai_basenpc.cpp:	if ( m_flLastDamageTime != gpGlobals->curtime )
game/server/ai_basenpc.cpp:		if ((gpGlobals->curtime - m_flLastDamageTime) < 1.0)
game/server/ai_basenpc.cpp:		m_flLastDamageTime = gpGlobals->curtime;
game/server/ai_basenpc.cpp:			m_flLastPlayerDamageTime = gpGlobals->curtime;
game/server/ai_basenpc.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_basenpc.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_basenpc.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_basenpc.cpp:			m_flLastSawPlayerTime = gpGlobals->curtime;
game/server/ai_basenpc.cpp:					if( gpGlobals->curtime > m_flIgnoreDangerSoundsUntil)
game/server/ai_basenpc.cpp:	if (m_flNextEyeLookTime < gpGlobals->curtime)
game/server/ai_basenpc.cpp:			m_flNextEyeLookTime = gpGlobals->curtime + random->RandomInt(1,5);
game/server/ai_basenpc.cpp:	if (m_flNextEyeLookTime > gpGlobals->curtime)
game/server/ai_basenpc.cpp:	if (m_flNextEyeLookTime < gpGlobals->curtime)
game/server/ai_basenpc.cpp:		m_flNextEyeLookTime = gpGlobals->curtime + 0.5; // random->RandomInt(1,5);
game/server/ai_basenpc.cpp:	float flInterval = ( m_flTimeLastMovement != FLT_MAX ) ? gpGlobals->curtime - m_flTimeLastMovement : 0.1;
game/server/ai_basenpc.cpp:	m_flTimeLastMovement = gpGlobals->curtime;
game/server/ai_basenpc.cpp:		if ( gpGlobals->curtime >= g_AINextDisabledMessageTime && !IsInCommentaryMode() )
game/server/ai_basenpc.cpp:			g_AINextDisabledMessageTime = gpGlobals->curtime + 0.5f;
game/server/ai_basenpc.cpp:	if ( gpGlobals->framecount != iPrevFrame )
game/server/ai_basenpc.cpp:		iPrevFrame = gpGlobals->framecount;
game/server/ai_basenpc.cpp:	if ( gpGlobals->curtime - GetLastAttackTime() < .15 )
game/server/ai_basenpc.cpp:	bool bFramerateOk = ( gpGlobals->frametime < ai_frametime_limit.GetFloat() );
game/server/ai_basenpc.cpp:		 gpGlobals->curtime - GetLastAttackTime() < .2 ||
game/server/ai_basenpc.cpp:		 gpGlobals->curtime - m_flLastDamageTime < .2 ||
game/server/ai_basenpc.cpp:			if ( gpGlobals->maxClients > 1 )
game/server/ai_basenpc.cpp:					for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_basenpc.cpp:		if ( gpGlobals->tickcount != iPrevTick )
game/server/ai_basenpc.cpp:			DevMsg( "NPC per tick is %d [%d] (tick %d, frame %d)\n", nRebalanceableThinksInTick, nThinksInTick, iPrevTick, gpGlobals->framecount );
game/server/ai_basenpc.cpp:			iPrevTick = gpGlobals->tickcount;
game/server/ai_basenpc.cpp:	if ( ShouldRebalanceThinks() && gpGlobals->tickcount >= gm_iNextThinkRebalanceTick )
game/server/ai_basenpc.cpp:		gm_iNextThinkRebalanceTick = gpGlobals->tickcount + TIME_TO_TICKS( random->RandomFloat( 3, 5) );
game/server/ai_basenpc.cpp:		int iMinTickRebalance = gpGlobals->tickcount - 1; // -1 needed for alternate ticks
game/server/ai_basenpc.cpp:		int iMaxTickRebalance = gpGlobals->tickcount + iTicksPer10Hz;
game/server/ai_basenpc.cpp:			int iCurTickDistributing = MIN( gpGlobals->tickcount, rebalanceCandidates[0].iNextThinkTick );
game/server/ai_basenpc.cpp:		if ( m_iFrameBlocked == gpGlobals->framecount )
game/server/ai_basenpc.cpp:			DbgFrameLimitMsg( "Stalled %d (%d)\n", this, gpGlobals->framecount );
game/server/ai_basenpc.cpp:			SetNextThink( gpGlobals->curtime );
game/server/ai_basenpc.cpp:		else if ( gpGlobals->framecount != iPrevFrame )
game/server/ai_basenpc.cpp:			DbgFrameLimitMsg( "--- FRAME: %d (%d)\n", this, gpGlobals->framecount );
game/server/ai_basenpc.cpp:			iPrevFrame = gpGlobals->framecount;
game/server/ai_basenpc.cpp:				float timeSinceLastRealThink = gpGlobals->curtime - m_flLastRealThinkTime;
game/server/ai_basenpc.cpp:					DbgFrameLimitMsg( "Bumped %d (%d)\n", this, gpGlobals->framecount );
game/server/ai_basenpc.cpp:					m_iFrameBlocked = gpGlobals->framecount;
game/server/ai_basenpc.cpp:					SetNextThink( gpGlobals->curtime );
game/server/ai_basenpc.cpp:		DbgFrameLimitMsg( "Running %d (%d)\n", this, gpGlobals->framecount );
game/server/ai_basenpc.cpp:	m_flLastRealThinkTime = gpGlobals->curtime;
game/server/ai_basenpc.cpp:				if ( m_flNextDecisionTime <= gpGlobals->curtime )
game/server/ai_basenpc.cpp:				SetSimulationTime( gpGlobals->curtime );
game/server/ai_basenpc.cpp:			m_flNextDecisionTime = gpGlobals->curtime + g_DecisionIntervals[GetEfficiency()];
game/server/ai_basenpc.cpp:			SetNextThink( gpGlobals->curtime + .1 );
game/server/ai_basenpc.cpp:			SetNextThink( gpGlobals->curtime + .2 );
game/server/ai_basenpc.cpp:		m_flLastStateChangeTime = gpGlobals->curtime;
game/server/ai_basenpc.cpp:	return m_nWakeTick == gpGlobals->tickcount ? true : false;
game/server/ai_basenpc.cpp:		m_nWakeTick = gpGlobals->tickcount;
game/server/ai_basenpc.cpp:	if ( m_flNextFlinchTime >= gpGlobals->curtime )
game/server/ai_basenpc.cpp:	if ( HasMemory(bits_MEMORY_FLINCHED) && gpGlobals->curtime > m_flNextFlinchTime )
game/server/ai_basenpc.cpp:	if( gpGlobals->curtime > m_flTimePingEffect && m_flTimePingEffect > 0.0f )
game/server/ai_basenpc.cpp:				m_flLastEnemyTime = gpGlobals->curtime;
game/server/ai_basenpc.cpp:	   (!GetEnemy() && gpGlobals->curtime - GetEnemies()->LastTimeSeen( AI_UNKNOWN_ENEMY ) < TIME_CARE_ABOUT_DAMAGE ) )
game/server/ai_basenpc.cpp:		(!GetEnemy() && gpGlobals->curtime - GetEnemies()->LastTimeSeen( AI_UNKNOWN_ENEMY ) < TIME_CARE_ABOUT_DAMAGE ) )
game/server/ai_basenpc.cpp:	if( m_flNextWeaponSearchTime > gpGlobals->curtime )
game/server/ai_basenpc.cpp:			m_flNextWeaponSearchTime = gpGlobals->curtime + 2;
game/server/ai_basenpc.cpp:				m_flNextWeaponSearchTime = gpGlobals->curtime + 1;
game/server/ai_basenpc.cpp:				m_flNextWeaponSearchTime = gpGlobals->curtime + 2;
game/server/ai_basenpc.cpp:	if ( HasCondition( COND_NEW_ENEMY ) || GetSenses()->GetTimeLastUpdate( GetEnemy() ) == gpGlobals->curtime )
game/server/ai_basenpc.cpp:	if (gpGlobals->curtime - GetEnemyLastTimeSeen() > 8)
game/server/ai_basenpc.cpp:			if ( ( pLastWarn != this && lastWarnActivity != translatedActivity ) || gpGlobals->curtime - timeLastWarn > 5.0 )
game/server/ai_basenpc.cpp:				timeLastWarn = gpGlobals->curtime;
game/server/ai_basenpc.cpp:	if ( gpGlobals->frametime <= 0.0f || !ai_auto_contact_solver.GetBool() )
game/server/ai_basenpc.cpp:	SetNextThink( gpGlobals->curtime + 0.01f );
game/server/ai_basenpc.cpp:		m_ShotRegulator.FireNoEarlierThan( gpGlobals->curtime + flDuration + 0.5 );
game/server/ai_basenpc.cpp:				m_ShotRegulator.FireNoEarlierThan( gpGlobals->curtime + flDuration + 0.5 );
game/server/ai_basenpc.cpp:	SetLastAttackTime( gpGlobals->curtime );
game/server/ai_basenpc.cpp:	m_flLastRealThinkTime = gpGlobals->curtime;
game/server/ai_basenpc.cpp:	if ( gm_flTimeLastSpawn != gpGlobals->curtime )
game/server/ai_basenpc.cpp:		gm_flTimeLastSpawn = gpGlobals->curtime;
game/server/ai_basenpc.cpp:	SetNextThink( gpGlobals->curtime + nextThinkTimes[gm_nSpawnedThisFrame % 20] );
game/server/ai_basenpc.cpp:			m_UnreachableEnts[i].fExpireTime	 = gpGlobals->curtime + NPC_UNREACHABLE_TIMEOUT;
game/server/ai_basenpc.cpp:	m_UnreachableEnts[nNewIndex].fExpireTime	 = gpGlobals->curtime + NPC_UNREACHABLE_TIMEOUT;
game/server/ai_basenpc.cpp:			if ( gpGlobals->curtime > m_UnreachableEnts[i].fExpireTime ||
game/server/ai_basenpc.cpp:			if ( pEMemory->timeLastSeen < gpGlobals->curtime - TIME_CONSIDER_ENEMY_UNSEEN )
game/server/ai_basenpc.cpp:		if ( pEMemory->timeValidEnemy > gpGlobals->curtime )
game/server/ai_basenpc.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/ai_basenpc.cpp:		if ( m_flMoveWaitFinished > gpGlobals->curtime )
game/server/ai_basenpc.cpp:			DevMsg( ": Stopped for %.2f. ", m_flMoveWaitFinished - gpGlobals->curtime );
game/server/ai_basenpc.cpp:			float timeSinceValidEnemy = gpGlobals->curtime - pEnemyInfo->timeValidEnemy;
game/server/ai_basenpc.cpp:			float timeSinceReacquire = gpGlobals->curtime - pEnemyInfo->timeLastReacquired;
game/server/ai_basenpc.cpp:			float timeSinceValidEnemy = gpGlobals->curtime - pEnemyInfo->timeValidEnemy;
game/server/ai_basenpc.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/server/ai_basenpc.cpp:	SetNextThink( gpGlobals->curtime + 0.5f );
game/server/ai_basenpc.cpp:	m_flTimeEnemyAcquired = gpGlobals->curtime;
game/server/ai_basenpc.cpp:				 ( pInfo && ( pInfo->timeAtFirstHand == AI_INVALID_TIME || gpGlobals->curtime - pInfo->timeLastSeen > 10 ) ) )
game/server/ai_basenpc.cpp:		if ( pInfo && pInfo->timeValidEnemy < gpGlobals->curtime )
game/server/ai_basenpc.cpp:		if (gpGlobals->curtime <= m_flSoundWaitTime)
game/server/ai_basenpc.cpp:	m_flSoundWaitTime = gpGlobals->curtime + flSoundLength + random->RandomFloat(1.5, 2.0);
game/server/ai_basenpc.cpp:		m_pSquad->JustMadeSound( soundPriority, gpGlobals->curtime + flSoundLength + random->RandomFloat(1.5, 2.0) );
game/server/ai_basenpc.cpp:	if( gpGlobals->curtime < m_flTimePingEffect )
game/server/ai_basenpc.cpp:	m_flIgnoreDangerSoundsUntil = gpGlobals->curtime + flDelay;
game/server/ai_basenpc.cpp:			//Msg("%s(%s) enabled collisions with %s(%s) at %0.2f\n", GetClassname(), GetDebugName(), m_hInteractionPartner->GetClassName(), m_hInteractionPartner->GetDebugName(), gpGlobals->curtime );
game/server/ai_basenpc.cpp:	m_flMoveWaitFinished = gpGlobals->curtime + pDoor->GetOpenInterval();
game/server/ai_basenpc.cpp:		 gpGlobals->tickcount );
game/server/ai_basenpc.cpp:		m_flWaitFinished = gpGlobals->curtime + ( 0.1 * minThinks );
game/server/ai_basenpc.cpp:		m_flWaitFinished = gpGlobals->curtime + ( 0.1 * random->RandomInt( minThinks, maxThinks ) );
game/server/ai_basenpc.cpp:	return ( gpGlobals->curtime >= m_flWaitFinished );
game/server/ai_basenpc.cpp:	return ( m_flNextDodgeTime <= gpGlobals->curtime );
game/server/ai_basenpc.cpp:		//Msg("%s(%s) disabled collisions with %s(%s) at %0.2f\n", GetClassname(), GetDebugName(), pOtherNPC->GetClassName(), pOtherNPC->GetDebugName(), gpGlobals->curtime );
game/server/ai_basenpc.cpp:	pInteraction->flNextAttemptTime = gpGlobals->curtime + pInteraction->flDelay + RandomFloat(-2,2);
game/server/ai_basenpc.cpp:		if ( pInteraction->flNextAttemptTime > gpGlobals->curtime )
game/server/ai_basenpc.cpp:			if ( ( gpGlobals->curtime > m_flForcedInteractionTimeout ) && ( m_iInteractionState == NPCINT_MOVING_TO_MARK ) )
game/server/ai_basenpc.cpp:	m_flForcedInteractionTimeout = gpGlobals->curtime + 8.0f;
game/server/ai_basenpc.cpp:		set.AppendCriteria( "timesinceseenplayer", UTIL_VarArgs( "%f", gpGlobals->curtime - m_flLastSawPlayerTime ) );
game/server/ai_route.cpp:		m_routeStartTime = gpGlobals->curtime;
game/server/baseanimating.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/baseanimating.cpp:	m_flPrevAnimTime = gpGlobals->curtime;
game/server/baseanimating.cpp:	if (m_flAnimTime < gpGlobals->curtime)
game/server/baseanimating.cpp:		flInterval = clamp( gpGlobals->curtime - m_flAnimTime, 0.f, MAX_ANIMTIME_INTERVAL );
game/server/baseanimating.cpp:			GetClassname(), gpGlobals->curtime, 
game/server/baseanimating.cpp:	if ( !pcache || !pcache->IsValid( gpGlobals->curtime, deltaTime ) )
game/server/baseanimating.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/baseanimating.cpp:	float flInterval = gpGlobals->curtime - m_flAnimTime;
game/server/baseanimating.cpp:	m_flAnimTime = gpGlobals->curtime;
game/server/baseanimating.cpp:		Msg("%5.2f : %s : %s : %5.3f\n", gpGlobals->curtime, GetClassname(), GetSequenceName( GetSequence() ), GetCycle() );
game/server/baseanimating.cpp:		SetNextThink( gpGlobals->curtime + 2.0f );
game/server/baseanimating.cpp:			pFireChild->SetNextThink( gpGlobals->curtime + 0.1f );
game/server/baseanimating.cpp:	// m_flAnimTime = gpGlobals->time;
game/server/baseanimating.cpp:					hDustTrail->m_StopEmitTime = gpGlobals->curtime + flDuration;
game/server/baseanimating.cpp:	m_flIKGroundContactTime = gpGlobals->curtime;
game/server/baseanimating.cpp:	if (m_flIKGroundContactTime > 0.2 && m_flIKGroundContactTime > gpGlobals->curtime - 0.2)
game/server/baseanimating.cpp:		// Msg( "%.03f : %s:%s not in pvs\n", gpGlobals->curtime, GetClassname(), GetEntityName().ToCStr() );
game/server/baseanimating.cpp:			m_pIk->Init( pStudioHdr, GetAbsAngles(), adjOrigin, gpGlobals->curtime, m_iIKCounter, boneMask );
game/server/baseanimating.cpp:			CalculateIKLocks( gpGlobals->curtime );
game/server/baseanimating.cpp:			// Msg( "%.03f : %s:%s\n", gpGlobals->curtime, GetClassname(), GetEntityName().ToCStr() );
game/server/baseanimating.cpp:		if ( pcache->IsValid( gpGlobals->curtime ) && (pcache->m_boneMask & boneMask) == boneMask && pcache->m_timeValid <= gpGlobals->curtime)
game/server/baseanimating.cpp:		pcache->UpdateBones( bonetoworld, pStudioHdr->numbones(), gpGlobals->curtime );
game/server/baseanimating.cpp:		params.curtime = gpGlobals->curtime;
game/server/baseanimating.cpp:	boneSetup.AccumulatePose( pos, q, GetSequence(), GetCycle(), 1.0, gpGlobals->curtime, m_pIk );
game/server/baseanimating.cpp:		auto_ik.Init( pStudioHdr, GetAbsAngles(), GetAbsOrigin(), gpGlobals->curtime, 0, boneMask );
game/server/baseanimating.cpp:		boneSetup.CalcAutoplaySequences( pos, q, gpGlobals->curtime, &auto_ik );
game/server/baseanimating.cpp:		boneSetup.CalcAutoplaySequences( pos, q, gpGlobals->curtime, NULL );
game/server/baseanimating.cpp:		mvs->m_flModelScaleStartTime = gpGlobals->curtime;
game/server/baseanimating.cpp:	float frac = ( gpGlobals->curtime - mvs->m_flModelScaleStartTime ) / dt;
game/server/baseanimating.cpp:	if ( gpGlobals->curtime >= mvs->m_flModelScaleFinishTime )
game/server/ai_pathfinder.cpp:	if ( gpGlobals->curtime < nodeLink->m_timeStaleExpires )
game/server/ai_pathfinder.cpp:	if (gpGlobals->curtime == m_flLastStaleLinkCheckTime)
game/server/ai_pathfinder.cpp:		m_flLastStaleLinkCheckTime = gpGlobals->curtime;
game/server/ai_pathfinder.cpp:	nodeLink->m_timeStaleExpires = gpGlobals->curtime + 1.0;
game/server/gameinterface.cpp:// Purpose: This prevents sv.tickcount/gpGlobals->tickcount from advancing during restore which
game/server/gameinterface.cpp:	if ( IsX360() && !background && (gpGlobals->maxClients == 1) && (g_nCurrentChapterIndex >= 0) )
game/server/gameinterface.cpp:			gpGlobals->eLoadType = MapLoad_Transition;
game/server/gameinterface.cpp:			gpGlobals->eLoadType = MapLoad_LoadGame;
game/server/gameinterface.cpp:			gpGlobals->eLoadType = MapLoad_Background;
game/server/gameinterface.cpp:			gpGlobals->eLoadType = MapLoad_NewGame;
game/server/gameinterface.cpp:		if ( gpGlobals->tickcount & 1 )
game/server/gameinterface.cpp:		gpGlobals->frametime *= 2.0f;
game/server/gameinterface.cpp:	float oldframetime = gpGlobals->frametime;
game/server/gameinterface.cpp:	gpGlobals->frametime = oldframetime;
game/server/gameinterface.cpp:	if ( m_fAutoSaveDangerousTime != 0.0f && m_fAutoSaveDangerousTime < gpGlobals->curtime )
game/server/gameinterface.cpp:		if ( pPlayer && ( pPlayer->GetDeathTime() == 0.0f || pPlayer->GetDeathTime() > gpGlobals->curtime )
game/server/gameinterface.cpp:	char const *mapname = STRING( gpGlobals->mapname );
game/server/gameinterface.cpp:	if ( gpGlobals->eLoadType == MapLoad_Background )
game/server/gameinterface.cpp:	CSaveRestoreData *pSaveData = gpGlobals->pSaveData;
game/server/gameinterface.cpp:	Assert ( gpGlobals->maxClients == 1 );
game/server/gameinterface.cpp:	if ( gpGlobals->eLoadType != MapLoad_LoadGame )
game/server/gameinterface.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/gameinterface.cpp:			Q_snprintf( buf, buflen, "%sCurrent time: %6.3f\n", buf, gpGlobals->curtime );
game/server/testtraceline.cpp:	SetNextThink( gpGlobals->curtime );
game/server/testtraceline.cpp:		float s = sin( gpGlobals->curtime );
game/server/testtraceline.cpp:		angles[1] = gpGlobals->curtime * 10;
game/server/testtraceline.cpp:	SetNextThink( gpGlobals->curtime );
game/server/basegrenade_contact.cpp:	SetNextThink( gpGlobals->curtime );
game/server/team_objectiveresource.cpp:	SetNextThink( gpGlobals->curtime + LAZY_UPDATE_TIME );
game/server/team_objectiveresource.cpp:	SetNextThink( gpGlobals->curtime + LAZY_UPDATE_TIME );
game/server/vehicle_baseserver.cpp:				pAnimating->m_flAnimTime = gpGlobals->curtime;
game/server/vehicle_baseserver.cpp:				pAnimating->m_flAnimTime = gpGlobals->curtime;
game/server/vehicle_baseserver.cpp:			pAnimating->m_flAnimTime = gpGlobals->curtime;
game/server/vehicle_baseserver.cpp:	return gpGlobals->curtime;
game/server/vehicle_baseserver.cpp:	return gpGlobals->curtime;
game/server/vehicle_baseserver.cpp:	float timeInState = gpGlobals->curtime - m_soundStateStartTime;
game/server/vehicle_baseserver.cpp:	m_soundStateStartTime = gpGlobals->curtime;
game/server/logic_measure_movement.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/logic_measure_movement.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/logic_measure_movement.cpp:	SetNextThink( gpGlobals->curtime + TICK_INTERVAL );
game/server/soundscape_system.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/soundscape_system.cpp:	const char *mapname = STRING( gpGlobals->mapname );
game/server/soundscape_system.cpp:		int maxPlayers = gpGlobals->maxClients / 2;
game/server/soundscape_system.cpp:		for ( int i = 0; i < gpGlobals->maxClients && traceCount <= maxTraces && playerCount <= maxPlayers; i++ )
game/server/soundscape_system.cpp:			m_activeIndex = (m_activeIndex+1) % gpGlobals->maxClients;
game/server/ai_concommands.cpp:			pNPC->SetNextThink( gpGlobals->curtime );
game/server/ai_basenpc_physicsflyer.h:			m_vCurrentVelocity.x += noiseScale*sin(m_vNoiseMod.x * gpGlobals->curtime + m_vNoiseMod.x);
game/server/ai_basenpc_physicsflyer.h:			m_vCurrentVelocity.y += noiseScale*cos(m_vNoiseMod.y * gpGlobals->curtime + m_vNoiseMod.y);
game/server/ai_basenpc_physicsflyer.h:			m_vCurrentVelocity.z -= noiseScale*cos(m_vNoiseMod.z * gpGlobals->curtime + m_vNoiseMod.z);
game/server/movehelper_server.cpp:		return STRING(gpGlobals->mapname);
game/server/movehelper_server.cpp:	if ( gpGlobals->maxClients == 1 )
game/server/ai_utils.h:	if ( gpGlobals->maxClients > 1 )
game/server/ai_utils.h:	return ( gpGlobals->maxClients == 1 );
game/server/physconstraint_sounds.h:	m_fPrevSampleTime = gpGlobals->curtime;
game/server/vehicle_choreo_generic.cpp:	SetNextThink( gpGlobals->curtime );
game/server/vehicle_choreo_generic.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/server/vehicle_choreo_generic.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/vehicle_choreo_generic.cpp:		m_flAnimTime = gpGlobals->curtime;
game/server/maprules.cpp:		if ( gpGlobals->maxClients == 1 )
game/server/maprules.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/server/EnvMessage.cpp:			pPlayer = (gpGlobals->maxClients > 1) ? NULL : UTIL_GetLocalPlayer();
game/shared/voice_gamemgr.cpp:	for(int i=1; i <= gpGlobals->maxClients; i++)
game/shared/props_shared.cpp:	if ( m_iLastFrame == gpGlobals->framecount )
game/shared/props_shared.cpp:	m_iLastFrame = gpGlobals->framecount;
game/shared/props_shared.cpp:		if ( nFrameNumber != gpGlobals->framecount ) 
game/shared/props_shared.cpp:			nFrameNumber = gpGlobals->framecount; 
game/shared/props_shared.cpp:			if ( gpGlobals->maxClients > 1 && breakable_multiplayer.GetBool() )
game/shared/props_shared.cpp:			if ( gpGlobals->maxClients > 1 )
game/shared/props_shared.cpp:		if ( nFrameNumber != gpGlobals->framecount ) 
game/shared/props_shared.cpp:			nFrameNumber = gpGlobals->framecount; 
game/shared/props_shared.cpp:			if ( gpGlobals->maxClients > 1 && breakable_multiplayer.GetBool() )
game/shared/props_shared.cpp:			if ( gpGlobals->maxClients > 1 )
game/shared/weapon_ifmsteadycam.cpp:	float flMaxAngle = gpGlobals->frametime * flRate;
game/shared/weapon_ifmsteadycam.cpp:	Vector2DMA( m_vecViewOffset.AsVector2D(), gpGlobals->frametime, m_vec2DVelocity.AsVector2D(), m_vecViewOffset.AsVector2D() ); 
game/shared/weapon_ifmsteadycam.cpp:	Vector2DMA( m_vec2DVelocity.AsVector2D(), gpGlobals->frametime, vecForce, m_vec2DVelocity.AsVector2D() ); 
game/shared/weapon_ifmsteadycam.cpp:			stream.SetSeed( (int)(gpGlobals->curtime * 100) );
game/shared/hintmessage.cpp:	//if ( gpGlobals->curtime > m_tmMessageEnd )
game/shared/hintmessage.cpp:			m_tmMessageEnd = gpGlobals->curtime + msg->GetDuration();
game/shared/Multiplayer/multiplayer_animstate.cpp:	m_flLastAnimationStateClearTime = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp:			m_flJumpStartTime = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp:	m_aGestureSlots[iGestureSlot].m_pAnimLayer->m_flLastEventCheck = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp:	m_aGestureSlots[iGestureSlot].m_pAnimLayer->m_flLastEventCheck = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp:		pPlayer->m_flAnimTime = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp:		else if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
game/shared/Multiplayer/multiplayer_animstate.cpp:		m_iv_flMaxGroundSpeed.NoteChanged( gpGlobals->curtime, 0, false );
game/shared/Multiplayer/multiplayer_animstate.cpp:	if ( gpGlobals->curtime - m_flLastGroundSpeedUpdateTime >= flGroundSpeedInterval )
game/shared/Multiplayer/multiplayer_animstate.cpp:		m_flLastGroundSpeedUpdateTime = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp:		m_iv_flMaxGroundSpeed.NoteChanged( gpGlobals->curtime, flGroundSpeedInterval, false );
game/shared/Multiplayer/multiplayer_animstate.cpp:	m_iv_flMaxGroundSpeed.Interpolate( gpGlobals->curtime, flGroundSpeedInterval );
game/shared/Multiplayer/multiplayer_animstate.cpp:	flCycle += pPlayer->GetSequenceCycleRate( pStudioHdr, pGesture->m_pAnimLayer->m_nSequence ) * gpGlobals->frametime * GetGesturePlaybackRate() * pGesture->m_pAnimLayer->m_flPlaybackRate;
game/shared/Multiplayer/multiplayer_animstate.cpp:	float flDeltaTime = gpGlobals->frametime;
game/shared/Multiplayer/multiplayer_animstate.cpp:			m_PoseParameterData.m_flLastAimTurnTime = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp:			ConvergeYawAngles( m_flGoalFeetYaw, /*DOD_BODYYAW_RATE*/720.0f, gpGlobals->frametime, m_flCurrentFeetYaw );
game/shared/Multiplayer/multiplayer_animstate.cpp:			m_flLastAimTurnTime = gpGlobals->curtime;
game/shared/Multiplayer/multiplayer_animstate.cpp://	Anim_StateLog( "-------------%s: frame %d -----------------\n", bIsServer ? "Server" : "Client", gpGlobals->framecount );
game/shared/Multiplayer/multiplayer_animstate.cpp:	Anim_StatePrintf( iLine++, "-------------%s: frame %d -----------------\n", bIsServer ? "Server" : "Client", gpGlobals->framecount );
game/shared/Multiplayer/multiplayer_animstate.cpp:	Anim_StatePrintf( iLine++, "Time: %.2f, Speed: %.2f, MaxSpeed: %.2f", gpGlobals->curtime, vecVelocity.Length2D(), GetCurrentMaxGroundSpeed() );
game/shared/Multiplayer/multiplayer_animstate.cpp:	Anim_StateLog( "----------------- frame %d -----------------\n", gpGlobals->framecount );
game/shared/Multiplayer/multiplayer_animstate.cpp:		vOuterVel.Length2D(), gpGlobals->curtime, GetInterpolatedGroundSpeed() );
game/shared/util_shared.h:	float Now( void ) const;		// work-around since client header doesn't like inlined gpGlobals->curtime
game/shared/util_shared.h:	float Now( void ) const;		// work-around since client header doesn't like inlined gpGlobals->curtime
game/shared/saverestore.cpp:					Q_strncat( buf, gpGlobals->mapname.ToCStr(), sizeof(buf) );
game/shared/saverestore.cpp:			bool bIsPlayer = ( ( nEntIndex >= 1 ) && ( nEntIndex <= gpGlobals->maxClients ) ) ? true : false;
game/shared/saverestore.cpp:			else if ( (pEntInfo->edictindex > 0) && (pEntInfo->edictindex <= gpGlobals->maxClients) )
game/shared/saverestore.cpp:			else if ( !FStrEq( STRING(gpGlobals->mapname), GlobalEntity_GetMap(globalIndex) ) )
game/shared/saverestore.cpp:			GlobalEntity_Add( pEntity->m_iGlobalname, gpGlobals->mapname, GLOBAL_ON );
game/shared/saverestore.cpp:		GlobalEntity_SetMap( globalIndex, gpGlobals->mapname );
game/shared/saverestore.cpp:	pSaveData->levelInfo.time = gpGlobals->curtime;	// Use DLL time
game/shared/saverestore.cpp:	gpGlobals->pSaveData = pSaveData;
game/shared/saverestore.cpp:		if ( (pEntInfo->edictindex > 0) && (pEntInfo->edictindex <= gpGlobals->maxClients) )	
game/shared/sceneentity_shared.cpp:	Msg( "%8.3f[%d] %s:  %s", gpGlobals->curtime, gpGlobals->tickcount, CBaseEntity::IsServer() ? "sv" : "cl", msg );
game/shared/physics_main_shared.cpp:	move.x = (vecAbsVelocity.x + GetBaseVelocity().x ) * gpGlobals->frametime;
game/shared/physics_main_shared.cpp:	move.y = (vecAbsVelocity.y + GetBaseVelocity().y ) * gpGlobals->frametime;
game/shared/physics_main_shared.cpp:		move.z = GetBaseVelocity().z * gpGlobals->frametime;
game/shared/physics_main_shared.cpp:	float newZVelocity = vecAbsVelocity.z - GetActualGravity( this ) * gpGlobals->frametime;
game/shared/physics_main_shared.cpp:	move.z = ((vecAbsVelocity.z + newZVelocity) / 2.0 + GetBaseVelocity().z ) * gpGlobals->frametime;
game/shared/physics_main_shared.cpp:		if ( vecVelocity.z < ( GetActualGravity( this ) * gpGlobals->frametime ) )
game/shared/physics_main_shared.cpp:			VectorScale( vecAbsVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, vecVelocity ); 
game/shared/physics_main_shared.cpp:			VectorMA( vecVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, GetBaseVelocity() * flScale, vecVelocity );
game/shared/physics_main_shared.cpp:	if ( vecVelocity.z < ( GetActualGravity( this ) * gpGlobals->frametime ) )
game/shared/physics_main_shared.cpp:		vecAbsVelocity *= ( 1.0f - trace.fraction ) * gpGlobals->frametime * flSurfaceFriction;
game/shared/physics_main_shared.cpp:		if ( vecVelocity.z < ( GetActualGravity( this ) * gpGlobals->frametime ) )
game/shared/physics_main_shared.cpp:		VectorScale(vecAbsVelocity, gpGlobals->frametime, move);
game/shared/physics_main_shared.cpp:	SimulateAngles( gpGlobals->frametime );
game/shared/physics_main_shared.cpp:		VPhysicsGetObject()->UpdateShadow( GetAbsOrigin(), vec3_angle, true, gpGlobals->frametime );
game/shared/physics_main_shared.cpp:		VPhysicsGetObject()->UpdateShadow( GetAbsOrigin(), bAxisAligned ? vec3_angle : GetAbsAngles(), true, gpGlobals->frametime );
game/shared/physics_main_shared.cpp:	if (m_nSimulationTick == gpGlobals->tickcount)
game/shared/physics_main_shared.cpp:	m_nSimulationTick = gpGlobals->tickcount;
game/shared/physics_main_shared.cpp:			VectorMA( GetAbsVelocity(), 1.0 + (gpGlobals->frametime*0.5), GetBaseVelocity(), vecAbsVelocity );
game/shared/physics_main_shared.cpp:		Msg( "-----------------\nThink report frame %i\n", gpGlobals->tickcount );
game/shared/physics_main_shared.cpp:	if ( thinktick <= 0 || thinktick > gpGlobals->tickcount )
game/shared/physics_main_shared.cpp:	if ( thinktime < gpGlobals->curtime )
game/shared/physics_main_shared.cpp:		thinktime = gpGlobals->curtime;	
game/shared/physics_main_shared.cpp:	g_ThinkChecker.EntityThinking( gpGlobals->tickcount, this, thinktime, m_nNextThinkTick );
game/shared/physics_main_shared.cpp:	SetLastThink( nContextIndex, gpGlobals->curtime );
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.25f;
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.25f;
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;//SequenceDuration();
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;//SequenceDuration();
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;//SequenceDuration();
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;//SequenceDuration();
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + fDelay;
game/shared/portal/weapon_portalgun_shared.cpp:	if ( ( gpGlobals->curtime - m_flHolsterTime ) > sk_auto_reload_time.GetFloat() )
game/shared/portal/weapon_portalgun_shared.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/portal/weapon_portalgun_shared.cpp:	m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime;
game/shared/portal/weapon_portalgun_shared.cpp:		pOwner->SetNextAttack( gpGlobals->curtime );
game/shared/portal/weapon_portalgun_shared.cpp:		if ( m_flRaiseTime < gpGlobals->curtime && GetActivity() == ACT_VM_IDLE_LOWERED ) 
game/shared/portal/portal_mp_gamerules.cpp:	return m_flIntermissionEndTime > gpGlobals->curtime;
game/shared/portal/portal_mp_gamerules.cpp:		if ( m_flIntermissionEndTime < gpGlobals->curtime )
game/shared/portal/portal_mp_gamerules.cpp:			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/portal/portal_mp_gamerules.cpp:	if ( gpGlobals->curtime > m_tmNextPeriodicThink )
game/shared/portal/portal_mp_gamerules.cpp:		m_tmNextPeriodicThink = gpGlobals->curtime + 1.0;
game/shared/portal/portal_mp_gamerules.cpp:	if ( m_flRestartGameTime > 0.0f && m_flRestartGameTime <= gpGlobals->curtime )
game/shared/portal/portal_mp_gamerules.cpp:		m_flRestartGameTime = gpGlobals->curtime + 5;
game/shared/portal/portal_mp_gamerules.cpp:	m_flIntermissionEndTime = gpGlobals->curtime + mp_chattime.GetInt();
game/shared/portal/portal_mp_gamerules.cpp:		if ( m_flIntermissionEndTime < gpGlobals->curtime )
game/shared/portal/portal_mp_gamerules.cpp:		if ( gEntList.NumberOfEntities() < (gpGlobals->maxEntities - ENTITY_INTOLERANCE) )
game/shared/portal/portal_mp_gamerules.cpp:		if ( pItem->m_flNextResetCheckTime > gpGlobals->curtime )
game/shared/portal/portal_mp_gamerules.cpp:		pItem->m_flNextResetCheckTime = gpGlobals->curtime + sv_hl2mp_item_respawn_time.GetFloat();
game/shared/portal/portal_mp_gamerules.cpp:		if ( pWeapon->m_flNextResetCheckTime > gpGlobals->curtime )
game/shared/portal/portal_mp_gamerules.cpp:		pWeapon->m_flNextResetCheckTime = gpGlobals->curtime + sv_hl2mp_weapon_respawn_time.GetFloat();
game/shared/portal/portal_mp_gamerules.cpp:		if ( pPortalPlayer->GetNextModelChangeTime() >= gpGlobals->curtime )
game/shared/portal/portal_mp_gamerules.cpp:			Q_snprintf( szReturnString, sizeof( szReturnString ), "Please wait %d more seconds before trying to switch.\n", (int)(pPlayer->GetNextModelChangeTime() - gpGlobals->curtime) );
game/shared/portal/portal_mp_gamerules.cpp:	float timeleft = (m_flGameStartTime + mp_timelimit.GetInt() * 60.0f ) - gpGlobals->curtime;
game/shared/portal/portal_mp_gamerules.cpp:	m_flGameStartTime = gpGlobals->curtime;
game/shared/portal/portal_mp_gamerules.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/portal/portal_mp_gamerules.cpp:		m_flRestartGameTime = gpGlobals->curtime + iRestartDelay;
game/shared/portal/portal_mp_gamerules.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/portal/portal_playeranimstate.cpp:	else if ( m_flHoldDeployedPoseUntilTime > gpGlobals->curtime )
game/shared/portal/portal_playeranimstate.cpp:			else if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
game/shared/portal/portal_util_shared.cpp:		if( fTime < gpGlobals->curtime )
game/shared/portal/portal_util_shared.cpp:	qInterped.Interpolate( gpGlobals->curtime );
game/shared/portal/portal_util_shared.cpp:		if( fTime < gpGlobals->curtime )
game/shared/portal/portal_util_shared.cpp:	vInterped.Interpolate( gpGlobals->curtime );
game/shared/portal/PortalSimulation.cpp:			ADD_DEBUG_HISTORY( HISTORY_PLAYER_DAMAGE, UTIL_VarArgs( "Player in PortalSimulator but not touching a portal, removing from sim at : %f\n",  gpGlobals->curtime ) );
game/shared/portal/portal_gamemovement.cpp:	float flStoreFrametime = gpGlobals->frametime;
game/shared/portal/portal_gamemovement.cpp:	gpGlobals->frametime *= pPlayer->GetLaggedMovementValue();
game/shared/portal/portal_gamemovement.cpp:	gpGlobals->frametime = flStoreFrametime;
game/shared/portal/portal_gamemovement.cpp:	accelspeed = accel * wishspeed * gpGlobals->frametime * player->m_surfaceFriction;
game/shared/portal/portal_player_shared.cpp:	float dt = gpGlobals->frametime;
game/shared/portal/portal_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/portal/portal_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/portal/portal_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/portal/portal_player_shared.cpp:		turning = ConvergeAngles( m_flGoalFeetYaw, turnrate, gpGlobals->frametime, m_flCurrentFeetYaw );
game/shared/portal/portal_player_shared.cpp:			( gpGlobals->curtime > m_flLastTurnTime + mp_facefronttime.GetFloat() ) )
game/shared/portal/portal_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/portal/portal_player_shared.cpp:			turning = ConvergeAngles( m_flGoalFeetYaw, turnrate, gpGlobals->frametime, m_flCurrentFeetYaw );
game/shared/portal/weapon_portalbasecombatweapon.cpp:	if ( ( gpGlobals->curtime - m_flHolsterTime ) > sk_auto_reload_time.GetFloat() )
game/shared/portal/weapon_portalbasecombatweapon.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/portal/weapon_portalbasecombatweapon.cpp:	m_flRaiseTime = gpGlobals->curtime + 0.5f;
game/shared/portal/weapon_portalbasecombatweapon.cpp:					pPlayer->SetNextAttack( gpGlobals->curtime + 1.0 );
game/shared/portal/weapon_portalbasecombatweapon.cpp:					m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/portal/weapon_portalbasecombatweapon.cpp:					m_flNextSecondaryAttack	= gpGlobals->curtime + 1.0;
game/shared/portal/weapon_portalbasecombatweapon.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/portal/weapon_portalbasecombatweapon.cpp:		if ( m_flRaiseTime < gpGlobals->curtime && GetActivity() == ACT_VM_IDLE_LOWERED ) 
game/shared/portal/weapon_portalbasecombatweapon.cpp:	if ( ( !gpGlobals->frametime ) || ( player == NULL ) )
game/shared/portal/weapon_portalbasecombatweapon.cpp:	bobtime += ( gpGlobals->curtime - lastbobtime ) * bob_offset;
game/shared/portal/weapon_portalbasecombatweapon.cpp:	lastbobtime = gpGlobals->curtime;
game/shared/baseparticleentity.cpp:		SetNextThink( gpGlobals->curtime + lifetime );
game/shared/util_shared.cpp:	for ( int k = 1; k <= gpGlobals->maxClients; ++k )
game/shared/util_shared.cpp:// work-around since client header doesn't like inlined gpGlobals->curtime
game/shared/util_shared.cpp:	return gpGlobals->curtime;
game/shared/util_shared.cpp:// work-around since client header doesn't like inlined gpGlobals->curtime
game/shared/util_shared.cpp:	return gpGlobals->curtime;
game/shared/util_shared.cpp:		for (int i = 1; i<=gpGlobals->maxClients; i++ )
game/shared/baseentity_shared.cpp:			PhysicsRelinkChildren(gpGlobals->frametime);
game/shared/baseentity_shared.cpp:	CBaseEntity *pPlayer = ( gpGlobals->maxClients == 1 ) ? UTIL_GetLocalPlayer() : NULL;
game/shared/baseentity_shared.cpp:	if ( gpGlobals->maxClients != 1 )
game/shared/singleplay_gamerules.cpp:		return gpGlobals->curtime;//now!
game/shared/death_pose.cpp:		Vector vAdjustedOrigin = vNewOrigin + vDirection * ( ( flVelocity * flVelocity ) * gpGlobals->frametime );
game/shared/death_pose.cpp:		entity->Interpolate( gpGlobals->curtime );
game/shared/death_pose.cpp:		entity->SetupBones( NULL, -1, BONE_USED_BY_ANYTHING, gpGlobals->curtime );
game/shared/predictioncopy.cpp:	Msg( "%i %s %s : %s\n", gpGlobals->tickcount, m_pOperation, m_pCurrentField->fieldName, data );
game/shared/achievement_saverestore.cpp:			( ( MapLoad_LoadGame == gpGlobals->eLoadType ) || ( MapLoad_NewGame == gpGlobals->eLoadType )  ) 
game/shared/cstrike/weapon_glock.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_glock.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3;
game/shared/cstrike/weapon_glock.cpp:	m_flAccuracy -= (0.275)*(0.325 - (gpGlobals->curtime - m_flLastFire));
game/shared/cstrike/weapon_glock.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_glock.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/shared/cstrike/weapon_glock.cpp:		gpGlobals->curtime);
game/shared/cstrike/weapon_glock.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + flCycleTime;
game/shared/cstrike/weapon_glock.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2.5f );
game/shared/cstrike/weapon_glock.cpp:		m_fNextBurstShot = gpGlobals->curtime + kGlockBurstCycleTime;
game/shared/cstrike/weapon_glock.cpp:	while ( m_iBurstShotsRemaining > 0 && gpGlobals->curtime >= m_fNextBurstShot )
game/shared/cstrike/weapon_glock.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_glock.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 20 );
game/shared/cstrike/weapon_csbase.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.4;
game/shared/cstrike/weapon_csbase.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.4;
game/shared/cstrike/weapon_csbase.cpp:	if ((m_bInReload) && (pPlayer->m_flNextAttack <= gpGlobals->curtime))
game/shared/cstrike/weapon_csbase.cpp:	if ((pPlayer->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/shared/cstrike/weapon_csbase.cpp:	else if ((pPlayer->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime ))
game/shared/cstrike/weapon_csbase.cpp:	else if ( pPlayer->m_nButtons & IN_RELOAD && GetMaxClip1() != WEAPON_NOCLIP && !m_bInReload && m_flNextPrimaryAttack < gpGlobals->curtime)
game/shared/cstrike/weapon_csbase.cpp:			m_flDecreaseShotsFired = gpGlobals->curtime + 0.4;
game/shared/cstrike/weapon_csbase.cpp:			if ( (pPlayer->m_iShotsFired > 0) && (m_flDecreaseShotsFired < gpGlobals->curtime)	)
game/shared/cstrike/weapon_csbase.cpp:				m_flDecreaseShotsFired = gpGlobals->curtime + 0.0225;
game/shared/cstrike/weapon_csbase.cpp:		if ( (!IsUseable() && m_flNextPrimaryAttack < gpGlobals->curtime) )
game/shared/cstrike/weapon_csbase.cpp:			if ( m_iClip1 == 0 && !(GetWeaponFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < gpGlobals->curtime )
game/shared/cstrike/weapon_csbase.cpp:	// Msg( "deploy %s at %f\n", GetClassname(), gpGlobals->curtime );
game/shared/cstrike/weapon_csbase.cpp:	pOwner->SetNextAttack( gpGlobals->curtime + SequenceDuration() );
game/shared/cstrike/weapon_csbase.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime;
game/shared/cstrike/weapon_csbase.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime;
game/shared/cstrike/weapon_csbase.cpp:	float fDeltaAttack = gpGlobals->curtime - fCurAttack;
game/shared/cstrike/weapon_csbase.cpp:	if ( fDeltaAttack < 0 || fDeltaAttack > gpGlobals->interval_per_tick )
game/shared/cstrike/weapon_csbase.cpp:		fCurAttack = gpGlobals->curtime;
game/shared/cstrike/weapon_csbase.cpp:	m_flDecreaseShotsFired = gpGlobals->curtime;
game/shared/cstrike/weapon_csbase.cpp:		if ( m_nextPrevOwnerTouchTime > gpGlobals->curtime )
game/shared/cstrike/weapon_csbase.cpp:	m_nextPrevOwnerTouchTime = gpGlobals->curtime + 0.8f;
game/shared/cstrike/weapon_csbase.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/cstrike/weapon_csbase.cpp:	if ((m_prevOwner != NULL) && (pOther == m_prevOwner) && (gpGlobals->curtime < m_nextPrevOwnerTouchTime))
game/shared/cstrike/weapon_csbase.cpp:						m_flCrosshairDistance = Lerp(expf(-gpGlobals->frametime / 0.44888f), fCrosshairDistanceGoal, m_flCrosshairDistance);
game/shared/cstrike/weapon_csbase.cpp:		SetNextThink( gpGlobals->curtime + time );
game/shared/cstrike/weapon_csbase.cpp:			pNewWeapon->SetNextThink( gpGlobals->curtime + g_pGameRules->FlWeaponRespawnTime( this ) );
game/shared/cstrike/weapon_csbase.cpp:		if ( ( !gpGlobals->frametime ) ||
game/shared/cstrike/weapon_csbase.cpp:		float flmaxSpeedDelta = MAX( 0, (gpGlobals->curtime - lastbobtime) * 320.0f );
game/shared/cstrike/weapon_csbase.cpp:		bobtime += ( gpGlobals->curtime - lastbobtime ) * bob_offset;
game/shared/cstrike/weapon_csbase.cpp:		lastbobtime = gpGlobals->curtime;
game/shared/cstrike/weapon_csbase.cpp:		for ( int i=0; i<gpGlobals->maxClients; ++i )
game/shared/cstrike/weapon_p228.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_p228.cpp:	m_flAccuracy -= (0.3)*(0.325 - (gpGlobals->curtime - m_flLastFire));
game/shared/cstrike/weapon_p228.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_p228.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/shared/cstrike/weapon_p228.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + GetCSWpnData().m_flCycleTime;
game/shared/cstrike/weapon_p228.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2 );
game/shared/cstrike/weapon_p228.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_p228.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 3.0 ) ;
game/shared/cstrike/flashbang_projectile.cpp:		if ( gpGlobals->curtime > pPSG->m_flSpawnTime + pPSG->m_FadeStartTime )		// ignore the smoke grenade if it's fading.
game/shared/cstrike/flashbang_projectile.cpp:	pGrenade->SetNextThink( gpGlobals->curtime );
game/shared/cstrike/weapon_scout.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3f;   
game/shared/cstrike/weapon_scout.cpp:	m_zoomFullyActiveTime = gpGlobals->curtime + 0.15; // The worst zoom time from above.  
game/shared/cstrike/weapon_scout.cpp:		if (pPlayer->GetFOV() == pPlayer->GetDefaultFOV() || (gpGlobals->curtime < m_zoomFullyActiveTime))
game/shared/cstrike/weapon_c4.cpp:		SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/cstrike/weapon_c4.cpp:		m_flC4Blow = gpGlobals->curtime + m_flTimerLength;
game/shared/cstrike/weapon_c4.cpp:		SetNextThink( gpGlobals->curtime + 0.12 );
game/shared/cstrike/weapon_c4.cpp:		if (m_flC4Blow <= gpGlobals->curtime)
game/shared/cstrike/weapon_c4.cpp:			if ( m_flDefuseCountDown > gpGlobals->curtime)
game/shared/cstrike/weapon_c4.cpp:				if( m_flNextDefuse < gpGlobals->curtime || !iOnGround )
game/shared/cstrike/weapon_c4.cpp:                    float   timeToDetonation = (m_flC4Blow - gpGlobals->curtime);
game/shared/cstrike/weapon_c4.cpp:				if ( player->m_iNextTimeCheck < gpGlobals->curtime )
game/shared/cstrike/weapon_c4.cpp:					player->m_iNextTimeCheck = gpGlobals->curtime + 1;
game/shared/cstrike/weapon_c4.cpp:			m_flNextDefuse = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_c4.cpp:			m_flNextDefuse = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_c4.cpp:			m_flDefuseCountDown = gpGlobals->curtime + m_flDefuseLength;
game/shared/cstrike/weapon_c4.cpp:			m_fArmedTime = gpGlobals->curtime + WEAPON_C4_ARM_TIME;
game/shared/cstrike/weapon_c4.cpp:			pPlayer->SetNextAttack( gpGlobals->curtime );
game/shared/cstrike/weapon_c4.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/cstrike/weapon_c4.cpp:			if( gpGlobals->curtime >= m_fArmedTime ) //the c4 is ready to be armed
game/shared/cstrike/weapon_c4.cpp:			else if( ( gpGlobals->curtime >= (m_fArmedTime - 0.75) ) && ( !m_bBombPlacedAnimation ) )
game/shared/cstrike/weapon_c4.cpp:            float   plantingTime = gpGlobals->curtime - CSGameRules()->GetRoundStartTime();
game/shared/cstrike/weapon_c4.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/cstrike/weapon_c4.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.3;
game/shared/cstrike/weapon_c4.cpp:	SetWeaponIdleTime( gpGlobals->curtime + SharedRandomFloat("C4IdleTime", 10, 15 ) );
game/shared/cstrike/weapon_c4.cpp:			pPlayer->SetNextAttack( gpGlobals->curtime );
game/shared/cstrike/weapon_c4.cpp:	float flProgress = ( gpGlobals->curtime - flStartTime ) / ( WEAPON_C4_ARM_TIME - 0.75 );
game/shared/cstrike/weapon_c4.cpp:			for( i=1;i<=gpGlobals->maxClients;i++ )
game/shared/cstrike/weapon_c4.cpp:    pPlayer->SetBombPickupTime(gpGlobals->curtime);
game/shared/cstrike/weapon_c4.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/cstrike/weapon_m4a1.cpp:	if ( gpGlobals->curtime < m_flDoneSwitchingSilencer )
game/shared/cstrike/weapon_m4a1.cpp:	if ( gpGlobals->curtime < m_flDoneSwitchingSilencer )
game/shared/cstrike/weapon_m4a1.cpp:	m_flDoneSwitchingSilencer = gpGlobals->curtime + 2;
game/shared/cstrike/weapon_m4a1.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 2;
game/shared/cstrike/weapon_m4a1.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 2;
game/shared/cstrike/weapon_m4a1.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2 );
game/shared/cstrike/weapon_m4a1.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_m4a1.cpp:		SetWeaponIdleTime( gpGlobals->curtime + GetCSWpnData().m_flIdleInterval );
game/shared/cstrike/weapon_csbasegun.cpp:	if ( (m_flNextPrimaryAttack <= gpGlobals->curtime) && (pPlayer->m_bResumeZoom == TRUE) )
game/shared/cstrike/weapon_csbasegun.cpp:			m_zoomFullyActiveTime = gpGlobals->curtime + 0.05f;// Make sure we think that we are zooming on the server so we don't get instant acc bonus
game/shared/cstrike/weapon_csbasegun.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/shared/cstrike/weapon_csbasegun.cpp:	SetWeaponIdleTime( gpGlobals->curtime + GetCSWpnData().m_flTimeToIdleAfterFire );
game/shared/cstrike/weapon_csbasegun.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_csbasegun.cpp:		SetWeaponIdleTime( gpGlobals->curtime + GetCSWpnData().m_flIdleInterval );
game/shared/cstrike/weapon_xm1014.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.15;
game/shared/cstrike/weapon_xm1014.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.25;
game/shared/cstrike/weapon_xm1014.cpp:		m_flPumpTime = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_xm1014.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 2.5 );
game/shared/cstrike/weapon_xm1014.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.25 );
game/shared/cstrike/weapon_xm1014.cpp:	if (m_flNextPrimaryAttack > gpGlobals->curtime)
game/shared/cstrike/weapon_xm1014.cpp:		pPlayer->m_flNextAttack = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_xm1014.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/cstrike/weapon_xm1014.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_xm1014.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_xm1014.cpp:		if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_xm1014.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/cstrike/weapon_xm1014.cpp:	if (m_flPumpTime && m_flPumpTime < gpGlobals->curtime)
game/shared/cstrike/weapon_xm1014.cpp:	if (m_flTimeWeaponIdle < gpGlobals->curtime)
game/shared/cstrike/weapon_xm1014.cpp:				SetWeaponIdleTime( gpGlobals->curtime + 1.5 );
game/shared/cstrike/basecsgrenade_projectile.cpp:			if ( gpGlobals->curtime - m_flSpawnTime < 0.5 )
game/shared/cstrike/basecsgrenade_projectile.cpp:		m_flSpawnTime = gpGlobals->curtime;
game/shared/cstrike/basecsgrenade_projectile.cpp:		if( gpGlobals->curtime > m_flDetonateTime )
game/shared/cstrike/basecsgrenade_projectile.cpp:		SetNextThink( gpGlobals->curtime + 0.2 );
game/shared/cstrike/basecsgrenade_projectile.cpp:		m_flDetonateTime = gpGlobals->curtime + timer;
game/shared/cstrike/basecsgrenade_projectile.cpp:				VectorScale( vecAbsVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, vecVelocity ); 
game/shared/cstrike/basecsgrenade_projectile.cpp:				VectorMA( vecVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, GetBaseVelocity() * flScale, vecVelocity );
game/shared/cstrike/weapon_sg552.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3;
game/shared/cstrike/weapon_awp.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3f;
game/shared/cstrike/weapon_awp.cpp:	m_zoomFullyActiveTime = gpGlobals->curtime + 0.15; // The worst zoom time from above.  
game/shared/cstrike/weapon_awp.cpp:		if (pPlayer->GetFOV() == pPlayer->GetDefaultFOV() || (gpGlobals->curtime < m_zoomFullyActiveTime))
game/shared/cstrike/weapon_awp.cpp:			SetContextThink( &CWeaponAWP::UnzoomThink, gpGlobals->curtime + sv_awpunzoomdelay.GetFloat(), SNIPER_ZOOM_CONTEXT );
game/shared/cstrike/cs_gamemovement.cpp:			m_pCSPlayer->m_flVelocityModifier += gpGlobals->frametime / 3.0f;
game/shared/cstrike/cs_gamemovement.cpp:		float flFrametimeRatio = gpGlobals->frametime / flReferenceFrametime;
game/shared/cstrike/cs_gamemovement.cpp:	float frame_msec = 1000.0f * gpGlobals->frametime;
game/shared/cstrike/cs_gamemovement.cpp:		m_pCSPlayer->m_flWaterJumpTime -= gpGlobals->frametime;
game/shared/cstrike/cs_gamemovement.cpp:	len -= (10.0 + len * 0.5) * gpGlobals->frametime;
game/shared/cstrike/cs_gamemovement.cpp:			m_fTimeLastUnducked = gpGlobals->curtime;
game/shared/cstrike/cs_gamemovement.cpp:				&& ( m_fTimeLastUnducked > (gpGlobals->curtime - sv_timebetweenducks.GetFloat() ) ) )
game/shared/cstrike/bot/bot_manager.cpp:	for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_manager.cpp:				if (((gpGlobals->tickcount + bot->entindex()) % g_BotUpdateSkipCount) == 0)
game/shared/cstrike/bot/nav_path.cpp:		float deltaT = gpGlobals->curtime - m_lastTime;
game/shared/cstrike/bot/nav_path.cpp:		m_lastTime = gpGlobals->curtime;
game/shared/cstrike/bot/bot_util.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for (int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for ( i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for ( i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for( int i=1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot_util.cpp:	for ( int p=1; p <= gpGlobals->maxClients; ++p )
game/shared/cstrike/bot/bot.h:	if ( UTIL_ClientsInGame() >= gpGlobals->maxClients )
game/shared/cstrike/bot/bot.h:		CONSOLE_ECHO( "Unable to create bot: Server is full (%d/%d clients).\n", UTIL_ClientsInGame(), gpGlobals->maxClients );
game/shared/cstrike/bot/bot.h:	if (gpGlobals->curtime >= m_flNextFullBotThink)
game/shared/cstrike/bot/bot.h:		m_flNextFullBotThink = gpGlobals->curtime + g_flBotFullThinkInterval;
game/shared/cstrike/bot/bot.h:		if (gpGlobals->curtime - m_jumpTimestamp < minJumpInterval)
game/shared/cstrike/bot/bot.h:	if (gpGlobals->curtime - m_jumpTimestamp < sanityInterval)
game/shared/cstrike/bot/bot.h:	m_jumpTimestamp = gpGlobals->curtime;
game/shared/cstrike/bot/bot.h:	if (gpGlobals->curtime - m_jumpTimestamp > 3.0f)
game/shared/cstrike/bot/bot.h:	if (gpGlobals->curtime - m_jumpTimestamp < 0.9f) // 1.0f
game/shared/cstrike/bot/bot.h:	cmd.command_number = gpGlobals->tickcount;
game/shared/cstrike/bot/bot.h:	iNewMsec = (int)( (gpGlobals->curtime - m_flPreviousCommandTime) * 1000 );
game/shared/cstrike/bot/bot.h:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot.h:	for ( int i = 1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/bot/bot.cpp:		m_dieTimestamp = gpGlobals->curtime + smokeLingerTime;
game/shared/cstrike/bot/bot.cpp:		if ( m_entity == NULL && gpGlobals->curtime > m_dieTimestamp )
game/shared/cstrike/weapon_g3sg1.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_g3sg1.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3f;   
game/shared/cstrike/weapon_g3sg1.cpp:	m_zoomFullyActiveTime = gpGlobals->curtime + 0.3; // The worst zoom time from above.  
game/shared/cstrike/weapon_g3sg1.cpp:		if (pPlayer->GetFOV() == pPlayer->GetDefaultFOV() || (gpGlobals->curtime < m_zoomFullyActiveTime))
game/shared/cstrike/weapon_g3sg1.cpp:	m_flAccuracy = 0.55 + (0.3) * (gpGlobals->curtime - m_flLastFire);	
game/shared/cstrike/weapon_g3sg1.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/hegrenade_projectile.cpp:	pGrenade->SetNextThink( gpGlobals->curtime );
game/shared/cstrike/weapon_basecsgrenade.cpp:	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/cstrike/weapon_basecsgrenade.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/cstrike/weapon_basecsgrenade.cpp:	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/cstrike/weapon_basecsgrenade.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/cstrike/weapon_basecsgrenade.cpp:	if ( ( m_bRedraw ) && ( m_flNextPrimaryAttack <= gpGlobals->curtime ) && ( m_flNextSecondaryAttack <= gpGlobals->curtime ) )
game/shared/cstrike/weapon_basecsgrenade.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/cstrike/weapon_basecsgrenade.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/cstrike/weapon_basecsgrenade.cpp:		SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/cstrike/weapon_basecsgrenade.cpp:		SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/cstrike/weapon_basecsgrenade.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration(); // we're still throwing, so reset our next primary attack
game/shared/cstrike/weapon_basecsgrenade.cpp:	else if ((m_fThrowTime > 0) && (m_fThrowTime < gpGlobals->curtime))
game/shared/cstrike/weapon_basecsgrenade.cpp:		if( m_flTimeWeaponIdle < gpGlobals->curtime )
game/shared/cstrike/weapon_basecsgrenade.cpp:		m_fThrowTime = gpGlobals->curtime + 0.1f;
game/shared/cstrike/weapon_basecsgrenade.cpp:		m_fThrowTime = gpGlobals->curtime + 0.1f;
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		m_flNextHostageAnnouncement = gpGlobals->curtime;	// asap.
game/shared/cstrike/cs_gamerules.cpp:		if ( filesystem->FileExists( UTIL_VarArgs( "maps/cfg/%s.cfg", STRING(gpGlobals->mapname) ) ) )
game/shared/cstrike/cs_gamerules.cpp:			engine->ServerCommand( UTIL_VarArgs( "exec \"%s.cfg\" */maps\n", STRING(gpGlobals->mapname) ) );
game/shared/cstrike/cs_gamerules.cpp:			if ( pPlayer->m_iNextTimeCheck < gpGlobals->curtime )
game/shared/cstrike/cs_gamerules.cpp:				pPlayer->m_iNextTimeCheck = gpGlobals->curtime + 1;
game/shared/cstrike/cs_gamerules.cpp:			m_firstKillTime = gpGlobals->curtime - m_fRoundStartTime;
game/shared/cstrike/cs_gamerules.cpp:		int iLevelIndex = GetCSLevelIndex( STRING( gpGlobals->mapname ) );
game/shared/cstrike/cs_gamerules.cpp:        for ( int clientIndex = 1; clientIndex <= gpGlobals->maxClients; clientIndex++ )
game/shared/cstrike/cs_gamerules.cpp:		if ( !IsFinite( gpGlobals->curtime ) )
game/shared/cstrike/cs_gamerules.cpp:			gpGlobals->curtime = 0.0f;
game/shared/cstrike/cs_gamerules.cpp:			m_flGameStartTime = gpGlobals->curtime;
game/shared/cstrike/cs_gamerules.cpp:			for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		m_fRoundStartTime = gpGlobals->curtime + m_iFreezeTime;
game/shared/cstrike/cs_gamerules.cpp:		for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:        for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		m_flNextHostageAnnouncement = gpGlobals->curtime;
game/shared/cstrike/cs_gamerules.cpp:		// CreateWeaponManager( "weapon_*", gpGlobals->maxClients * 2 );
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		if ( m_flRestartRoundTime > 0.0f && m_flRestartRoundTime <= gpGlobals->curtime )
game/shared/cstrike/cs_gamerules.cpp:			for ( int i=1; i <= gpGlobals->maxClients; ++i )
game/shared/cstrike/cs_gamerules.cpp:					if ( gpGlobals->curtime > m_flRestartRoundTime + 10.0f )
game/shared/cstrike/cs_gamerules.cpp:		if ( gpGlobals->curtime > m_tmNextPeriodicThink )
game/shared/cstrike/cs_gamerules.cpp:			m_tmNextPeriodicThink = gpGlobals->curtime + 1.0;
game/shared/cstrike/cs_gamerules.cpp:			if ( m_flIntermissionEndTime && ( m_flIntermissionEndTime < gpGlobals->curtime ) )
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:			m_fRoundStartTime.GetForModify() = gpGlobals->curtime;
game/shared/cstrike/cs_gamerules.cpp:		if ( IsFinite( startTime ) && gpGlobals->curtime < startTime )
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		PrintToConsole( player, str.sprintf( "Timers and related info at %f:\n", gpGlobals->curtime ) );
game/shared/cstrike/cs_gamerules.cpp:		for (playerNum = 1; playerNum <= gpGlobals->maxClients; ++playerNum)
game/shared/cstrike/cs_gamerules.cpp:			m_flRestartRoundTime = gpGlobals->curtime + iRestartDelay;
game/shared/cstrike/cs_gamerules.cpp:			for ( int j = 1; j <= gpGlobals->maxClients; j++ )
game/shared/cstrike/cs_gamerules.cpp:		if ( gpGlobals->curtime < m_flRestartRoundTime )
game/shared/cstrike/cs_gamerules.cpp:			if ( gpGlobals->curtime > (m_fRoundStartTime + 20) )
game/shared/cstrike/cs_gamerules.cpp:		m_flRestartRoundTime = gpGlobals->curtime + tmDelay;
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:		if( gpGlobals->curtime > m_flNextHostageAnnouncement && m_iRoundWinStatus == WINNER_NONE )
game/shared/cstrike/cs_gamerules.cpp:			m_flNextHostageAnnouncement = gpGlobals->curtime + 60.0;
game/shared/cstrike/cs_gamerules.cpp:	g_flGameStatsUpdateTime -= gpGlobals->curtime;
game/shared/cstrike/cs_gamerules.cpp:		Q_strncpy( stats.header.szMapName, STRING( gpGlobals->mapname ), sizeof( stats.header.szMapName ) );
game/shared/cstrike/cs_gamerules.cpp:		stats.iMinutesPlayed = clamp( (short)( gpGlobals->curtime / 60 ), 0, MY_USHRT_MAX ); 
game/shared/cstrike/cs_gamerules.cpp:				STRING( gpGlobals->mapname ),
game/shared/cstrike/cs_gamerules.cpp:	float flTimeLeft =  ( m_flGameStartTime + mp_timelimit.GetInt() * 60 ) - gpGlobals->curtime;
game/shared/cstrike/cs_gamerules.cpp:	return gpGlobals->curtime;
game/shared/cstrike/cs_gamerules.cpp:	return (float) (m_fRoundStartTime + m_iRoundTime) - gpGlobals->curtime; 
game/shared/cstrike/cs_gamerules.cpp:	return gpGlobals->curtime - m_fRoundStartTime;
game/shared/cstrike/cs_gamerules.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/cs_gamerules.cpp:			m_firstBloodTime = gpGlobals->curtime - m_fRoundStartTime;
game/shared/cstrike/weapon_famas.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3;
game/shared/cstrike/weapon_famas.cpp:	if ( m_iBurstShotsRemaining > 0 && gpGlobals->curtime >= m_fNextBurstShot )
game/shared/cstrike/weapon_famas.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.15;
game/shared/cstrike/weapon_famas.cpp:		m_fNextBurstShot = gpGlobals->curtime + kFamasBurstCycleTime;
game/shared/cstrike/weapon_knife.cpp:		GetPlayerOwner()->m_flNextAttack = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_knife.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_knife.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 20 );
game/shared/cstrike/weapon_knife.cpp:	bool bFirstSwing = (m_flNextPrimaryAttack + 0.4) < gpGlobals->curtime;
game/shared/cstrike/weapon_knife.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + fPrimDelay;
game/shared/cstrike/weapon_knife.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + fSecDelay;
game/shared/cstrike/weapon_knife.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2 );
game/shared/cstrike/weapon_knife.cpp:		m_flSmackTime = gpGlobals->curtime + (bStab?0.2f:0.1f);
game/shared/cstrike/weapon_knife.cpp:	if( m_flSmackTime > 0 && gpGlobals->curtime > m_flSmackTime )
game/shared/cstrike/cs_player_shared.cpp:	for ( int k = 1; k <= gpGlobals->maxClients; k++ )
game/shared/cstrike/cs_player_shared.cpp:			AddBulletStat( gpGlobals->realtime, VectorLength( vecSrc-tr.endpos), tr.endpos );
game/shared/cstrike/weapon_usp.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_usp.cpp:	if ( gpGlobals->curtime < m_flDoneSwitchingSilencer )
game/shared/cstrike/weapon_usp.cpp:	if ( gpGlobals->curtime < m_flDoneSwitchingSilencer )
game/shared/cstrike/weapon_usp.cpp:	m_flDoneSwitchingSilencer = gpGlobals->curtime + 3;
game/shared/cstrike/weapon_usp.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 3;
game/shared/cstrike/weapon_usp.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 3;
game/shared/cstrike/weapon_usp.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 3 );
game/shared/cstrike/weapon_usp.cpp:	m_flAccuracy -= (0.275)*(0.3 - (gpGlobals->curtime - m_flLastFire));
game/shared/cstrike/weapon_usp.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_usp.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/cstrike/weapon_usp.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + flCycleTime;
game/shared/cstrike/weapon_usp.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2 );
game/shared/cstrike/weapon_usp.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_usp.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 6.0 );
game/shared/cstrike/cs_playeranimstate.cpp:		m_flJumpStartTime = gpGlobals->curtime;
game/shared/cstrike/cs_playeranimstate.cpp:		m_flReloadHoldEndTime = gpGlobals->curtime + 0.75f;
game/shared/cstrike/cs_playeranimstate.cpp:		flCurCycle += m_pOuter->GetSequenceCycleRate( pStudioHdr, iSequence ) * gpGlobals->frametime;
game/shared/cstrike/cs_playeranimstate.cpp:	bool hold = m_flReloadHoldEndTime > gpGlobals->curtime;
game/shared/cstrike/cs_playeranimstate.cpp:		if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
game/shared/cstrike/fx_cs_shared.cpp:			gpGlobals->curtime, weaponAlias, fInaccuracy, fSpread, fInaccuracy + fSpread, iMode, fVelocity, iSeed, szFlags);
game/shared/cstrike/weapon_fiveseven.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_fiveseven.cpp:	m_flAccuracy -= (0.25)*(0.275 - (gpGlobals->curtime - m_flLastFire));
game/shared/cstrike/weapon_fiveseven.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_fiveseven.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/shared/cstrike/weapon_fiveseven.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + GetCSWpnData().m_flCycleTime;
game/shared/cstrike/weapon_fiveseven.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2 );
game/shared/cstrike/weapon_fiveseven.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_fiveseven.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 4 );
game/shared/cstrike/weapon_elite.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_elite.cpp:	m_flAccuracy -= (0.275)*(0.325 - (gpGlobals->curtime - m_flLastFire));
game/shared/cstrike/weapon_elite.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_elite.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/shared/cstrike/weapon_elite.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + GetCSWpnData().m_flCycleTime;
game/shared/cstrike/weapon_elite.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2.5 );
game/shared/cstrike/weapon_elite.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/achievements_cs.cpp:		if ( flTeamplayStartTime < ( gpGlobals->curtime - flRoundTime ) + CS_FULL_ROUND_GRACE_PERIOD )
game/shared/cstrike/achievements_cs.cpp:                for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/cstrike/weapon_sg550.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_sg550.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3f;
game/shared/cstrike/weapon_sg550.cpp:	m_zoomFullyActiveTime = gpGlobals->curtime + 0.3; // The worst zoom time from above.  
game/shared/cstrike/weapon_sg550.cpp:		if (pPlayer->GetFOV() == pPlayer->GetDefaultFOV() || (gpGlobals->curtime < m_zoomFullyActiveTime))
game/shared/cstrike/weapon_sg550.cpp:	m_flAccuracy = 0.65 + (0.35) * (gpGlobals->curtime - m_flLastFire);	
game/shared/cstrike/weapon_sg550.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_deagle.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_deagle.cpp:	m_flAccuracy -= (0.35)*(0.4 - ( gpGlobals->curtime - m_flLastFire ) );
game/shared/cstrike/weapon_deagle.cpp:	m_flLastFire = gpGlobals->curtime;
game/shared/cstrike/weapon_deagle.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.1f;
game/shared/cstrike/weapon_deagle.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + GetCSWpnData().m_flCycleTime;
game/shared/cstrike/weapon_deagle.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 1.8 );
game/shared/cstrike/weapon_deagle.cpp:	if ( m_flTimeWeaponIdle > gpGlobals->curtime )
game/shared/cstrike/weapon_deagle.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 20 );
game/shared/cstrike/weapon_aug.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.3;
game/shared/cstrike/weapon_galil.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.15;
game/shared/cstrike/weapon_m3.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.15;
game/shared/cstrike/weapon_m3.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/cstrike/weapon_m3.cpp:		m_flPumpTime = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_m3.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 2.5 );
game/shared/cstrike/weapon_m3.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.875 );
game/shared/cstrike/weapon_m3.cpp:	if (m_flNextPrimaryAttack > gpGlobals->curtime)
game/shared/cstrike/weapon_m3.cpp:		pPlayer->m_flNextAttack = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_m3.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_m3.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/cstrike/weapon_m3.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/cstrike/weapon_m3.cpp:		if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/cstrike/weapon_m3.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/cstrike/weapon_m3.cpp:	if (m_flPumpTime && m_flPumpTime < gpGlobals->curtime)
game/shared/cstrike/weapon_m3.cpp:	if (m_flTimeWeaponIdle < gpGlobals->curtime)
game/shared/cstrike/weapon_m3.cpp:				SetWeaponIdleTime( gpGlobals->curtime + 1.5 );
game/shared/voice_status.cpp:	if (gpGlobals->curtime - m_LastUpdateServerState > 1)
game/shared/voice_status.cpp:	m_LastUpdateServerState = gpGlobals->curtime;
game/shared/GameStats.cpp:		DevMsg( "[GS %s - %7.2f] %s", timeString, gpGlobals->realtime, buf );
game/shared/GameStats.cpp:			filesystem->FPrintf( g_LogFileHandle, "[GS %s - %7.2f] %s", timeString, gpGlobals->realtime, buf );
game/shared/GameStats.cpp:	if ( gpGlobals->maxClients == 1 )
game/shared/GameStats.cpp:		elapsed = gpGlobals->realtime - CBGSDriver.m_flLevelStartTime;
game/shared/GameStats.cpp:		Warning( "EVENT_CREDITS with negative elapsed time (rt %f starttime %f)\n", gpGlobals->realtime, CBGSDriver.m_flLevelStartTime );
game/shared/GameStats.cpp:	if ( Q_stricmp( m_PrevMapName.String(), STRING( gpGlobals->mapname ) ) )
game/shared/GameStats.cpp:		m_PrevMapName = STRING( gpGlobals->mapname );
game/shared/GameStats.cpp:		gamestats->Event_MapChange( PrevMapBackup.String(), STRING( gpGlobals->mapname ) );
game/shared/GameStats.cpp:	m_flLevelStartTime = gpGlobals->realtime;
game/shared/GameStats.cpp:	float flElapsed = gpGlobals->realtime - m_flLevelStartTime;
game/shared/GameStats.cpp:		Warning( "EVENT_LEVELSHUTDOWN:  with negative elapsed time (rt %f starttime %f)\n", gpGlobals->realtime, m_flLevelStartTime );
game/shared/GameStats.cpp:	if ( m_bInLevel && ( gpGlobals->eLoadType != MapLoad_Background ) )
game/shared/GameStats.cpp:			Q_strncpy( szMap, gpGlobals->mapname.ToCStr(), ARRAYSIZE( szMap ) );
game/shared/GameStats.cpp:			int mapTime = gpGlobals->realtime - m_flLevelStartTime;
game/shared/GameStats.cpp:	bool bGamePaused = ( gpGlobals->frametime == 0.0f );
game/shared/GameStats.cpp:			m_flPauseStartTime = gpGlobals->realtime;
game/shared/GameStats.cpp:			float flPausedTime = gpGlobals->realtime - m_flPauseStartTime;
game/shared/GameStats.cpp:				Warning( "Game paused time showing up negative (rt %f pausestart %f)\n", gpGlobals->realtime, m_flPauseStartTime );
game/shared/env_meteor_shared.cpp:	return ( m_flNextSpawnTime - gpGlobals->curtime );
game/shared/querycache.cpp:			 ( gpGlobals->curtime - pFound->m_flLastUpdateTime >= 
game/shared/querycache.cpp:	float flCurTime = gpGlobals->curtime;
game/shared/querycache.cpp:	m_flLastUpdateTime = gpGlobals->curtime;
game/shared/SpriteTrail.cpp:	if ( m_flUpdateTime > gpGlobals->curtime )
game/shared/SpriteTrail.cpp:		pNewPoint->m_flDieTime	= gpGlobals->curtime + m_flLifeTime;
game/shared/SpriteTrail.cpp:	m_flUpdateTime = gpGlobals->curtime + ( m_flLifeTime / (float) MAX_SPRITE_TRAIL_POINTS );
game/shared/SpriteTrail.cpp:	currentPoint.m_flDieTime = gpGlobals->curtime + m_flLifeTime;
game/shared/SpriteTrail.cpp:		float flLifePerc = (pPoint->m_flDieTime - gpGlobals->curtime) / m_flLifeTime;
game/shared/SpriteTrail.cpp:		if ( pPoint->m_flDieTime <= gpGlobals->curtime )
game/shared/weapon_ifmbase.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/ragdoll_shared.cpp:		DevMsg(2, "TICK:%5d:Ragdoll separation count: %d\n", gpGlobals->tickcount, fixCount );
game/shared/ragdoll_shared.cpp:		pFire->SetNextClientThink( gpGlobals->curtime + 7.0f );
game/shared/cam_thirdperson.cpp:	float flFrac = RemapValClamped( gpGlobals->curtime - m_flLerpTime, 0, CAMERA_OFFSET_LERP_TIME, 0, 1 );
game/shared/cam_thirdperson.cpp:	flFrac = RemapValClamped( gpGlobals->curtime - m_flUpLerpTime, 0, CAMERA_UP_OFFSET_LERP_TIME, 0, 1 );
game/shared/cam_thirdperson.cpp:			m_flLerpTime = gpGlobals->curtime;
game/shared/cam_thirdperson.cpp:			m_flLerpTime = gpGlobals->curtime;
game/shared/cam_thirdperson.cpp:					m_flUpLerpTime = gpGlobals->curtime;
game/shared/cam_thirdperson.cpp:					m_flUpLerpTime = gpGlobals->curtime;
game/shared/teamplay_gamerules.cpp:	if ( flTimeLimit != 0 && gpGlobals->curtime >= flTimeLimit )
game/shared/teamplay_gamerules.cpp:	for ( i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/teamplay_gamerules.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/hintsystem.h:	bool				HintIsCurrentlyVisible( void ) { return (gpGlobals->curtime - m_flLastHintPlayedAt < 11 ); }
game/shared/multiplay_gamerules.cpp:		if ( flTimeLimit != 0 && gpGlobals->curtime >= flTimeLimit )
game/shared/multiplay_gamerules.cpp:			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/multiplay_gamerules.cpp:		return gpGlobals->curtime;//now!
game/shared/multiplay_gamerules.cpp:				return gpGlobals->curtime + 0;		// weapon respawns almost instantly
game/shared/multiplay_gamerules.cpp:		return gpGlobals->curtime + WEAPON_RESPAWN_TIME;
game/shared/multiplay_gamerules.cpp:			if ( gEntList.NumberOfEntities() < (gpGlobals->maxEntities - ENTITY_INTOLERANCE) )
game/shared/multiplay_gamerules.cpp:		return gpGlobals->curtime + ITEM_RESPAWN_TIME;
game/shared/multiplay_gamerules.cpp:		m_flIntermissionEndTime = gpGlobals->curtime + flWaitTime;
game/shared/multiplay_gamerules.cpp:			Q_strncpy( szCurrentMapName, STRING(gpGlobals->mapname), MAX_MAP_NAME );
game/shared/multiplay_gamerules.cpp:			Q_strncpy( szDefaultMapName, STRING(gpGlobals->mapname), MAX_MAP_NAME );
game/shared/multiplay_gamerules.cpp:			V_snprintf( szBaseName, sizeof( szBaseName ), "scripts/population/%s*.pop", STRING(gpGlobals->mapname) );
game/shared/multiplay_gamerules.cpp:				const char *pchPopPostfix = StringAfterPrefix( pPopFileName, STRING(gpGlobals->mapname) );
game/shared/multiplay_gamerules.cpp:			if ( V_strcmp( STRING( gpGlobals->mapname ), m_MapList[i] ) == 0 )
game/shared/multiplay_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/multiplay_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/predicted_viewmodel.cpp:		m_LagAnglesHistory.NoteChanged( gpGlobals->curtime, cl_wpn_sway_interp.GetFloat(), false );
game/shared/predicted_viewmodel.cpp:		m_LagAnglesHistory.Interpolate( gpGlobals->curtime, cl_wpn_sway_interp.GetFloat() );
game/shared/animation.cpp:			pNPCEvent->eventtime = gpGlobals->curtime;
game/shared/gamerules.cpp:	GetVoiceGameMgr()->Init( g_pVoiceGameMgrHelper, gpGlobals->maxClients );
game/shared/gamerules.cpp:	GlobalEntity_Add( "skill.cfg", STRING(gpGlobals->mapname), GLOBAL_ON );
game/shared/gamerules.cpp:	GetVoiceGameMgr()->Update( gpGlobals->frametime );
game/shared/gamerules.cpp:		if ( m_flNextVerboseLogOutput < gpGlobals->curtime )
game/shared/gamerules.cpp:			m_flNextVerboseLogOutput = gpGlobals->curtime + log_verbose_interval.GetFloat();
game/shared/simtimer.h:		return ( gpGlobals->curtime - m_next > -ST_EPS );
game/shared/simtimer.h:		m_next = gpGlobals->curtime + interval;
game/shared/simtimer.h:			m_next = gpGlobals->curtime + random->RandomFloat( minInterval, maxInterval );
game/shared/simtimer.h:			m_next = gpGlobals->curtime + minInterval;
game/shared/simtimer.h:		float result = m_next - gpGlobals->curtime;
game/shared/simtimer.h:		m_next = (startExpired) ? -1.0 : gpGlobals->curtime + m_interval;
game/shared/simtimer.h:			m_next = gpGlobals->curtime + m_interval;
game/shared/simtimer.h:			m_next = gpGlobals->curtime + interval;
game/shared/simtimer.h:				m_next = gpGlobals->curtime + m_minInterval;
game/shared/simtimer.h:				m_next = gpGlobals->curtime + random->RandomFloat( m_minInterval, m_maxInterval );
game/shared/simtimer.h:			m_next = gpGlobals->curtime + m_minInterval;
game/shared/simtimer.h:			m_next = gpGlobals->curtime + random->RandomFloat( m_minInterval, m_maxInterval );
game/shared/simtimer.h:		m_next = gpGlobals->curtime + intervalOverride;
game/shared/simtimer.h:			m_next = gpGlobals->curtime + minOverride;
game/shared/simtimer.h:			m_next = gpGlobals->curtime + random->RandomFloat( minOverride, maxOverride );
game/shared/simtimer.h:		if ( m_lastTime == gpGlobals->curtime )
game/shared/simtimer.h:		m_lastTime = gpGlobals->curtime;
game/shared/simtimer.h:		return ( gpGlobals->curtime == m_lastTime );
game/shared/simtimer.h:		m_lastTime = gpGlobals->curtime;
game/shared/hintsystem.cpp:	if ( bOnlyIfClear && (gpGlobals->curtime - m_flLastHintPlayedAt < 11 ) )
game/shared/hintsystem.cpp:	m_flLastHintPlayedAt = gpGlobals->curtime;
game/shared/achievementmgr.cpp:		if ( m_vecThinkListeners[i].m_flThinkTime < gpGlobals->curtime )
game/shared/achievementmgr.cpp:			if ( m_vecThinkListeners[i].pAchievement->IsAchieved() || m_vecThinkListeners[i].m_flThinkTime < gpGlobals->curtime )
game/shared/achievementmgr.cpp:	Q_strncpy( m_szMap, gpGlobals->mapname.ToCStr(), ARRAYSIZE( m_szMap ) );
game/shared/achievementmgr.cpp:	m_flLevelInitTime = gpGlobals->curtime;
game/shared/achievementmgr.cpp:		if (gpGlobals->curtime >= fNextNotification)
game/shared/achievementmgr.cpp:			fNextNotification = gpGlobals->curtime + fNotificationCooldown;
game/shared/achievementmgr.cpp:		m_flLastClassChangeTime =  gpGlobals->curtime;
game/shared/achievementmgr.cpp:					m_flTeamplayStartTime = gpGlobals->curtime;
game/shared/achievementmgr.cpp:			m_vecThinkListeners[i].m_flThinkTime = gpGlobals->curtime + flThinkTime;
game/shared/achievementmgr.cpp:	m_vecThinkListeners[iIdx].m_flThinkTime = gpGlobals->curtime + flThinkTime;
game/shared/dod/weapon_dodbaserpg.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_dodbaserpg.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_dodbaserpg.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration() + 0.5;
game/shared/dod/weapon_dodbaserpg.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration() + 0.5;	//length of the fire anim!
game/shared/dod/weapon_dodbaserpg.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 2.0f;
game/shared/dod/weapon_dodbaserpg.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/dod/weapon_dodbaserpg.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbaserpg.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbaserpg.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbaserpg.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbaserpg.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbaserpg.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbaserpg.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/dod_gamerules.cpp:		Q_snprintf(szFullName,sizeof(szFullName), "maps/%s.ent", STRING( gpGlobals->mapname ));
game/shared/dod/dod_gamerules.cpp:		Q_snprintf( szCommand, sizeof(szCommand), "exec \"%s.cfg\"\n", STRING(gpGlobals->mapname) );
game/shared/dod/dod_gamerules.cpp:		if ( Q_strlen( STRING( gpGlobals->mapname ) ) > 0 )
game/shared/dod/dod_gamerules.cpp:			Q_strncpy( stats.header.szMapName, STRING( gpGlobals->mapname ), sizeof( stats.header.szMapName ) );
game/shared/dod/dod_gamerules.cpp:			stats.iMinutesPlayed = clamp( (short)( gpGlobals->curtime / 60 ), 0, MY_USHRT_MAX ); 
game/shared/dod/dod_gamerules.cpp:					STRING( gpGlobals->mapname ),
game/shared/dod/dod_gamerules.cpp:			if ( pDODPlayer->m_flNextTimeCheck < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:				pDODPlayer->m_flNextTimeCheck = gpGlobals->curtime + 1;
game/shared/dod/dod_gamerules.cpp:			if ( pDODPlayer->m_flNextTimeCheck < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:				pDODPlayer->m_flNextTimeCheck = gpGlobals->curtime + 1;
game/shared/dod/dod_gamerules.cpp:			if ( m_flIntermissionEndTime < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:		if ( gpGlobals->curtime > m_flNextPeriodicThink )
game/shared/dod/dod_gamerules.cpp:			m_flNextPeriodicThink = gpGlobals->curtime + 1.0;
game/shared/dod/dod_gamerules.cpp:			m_flWarmupTimeEnds = gpGlobals->curtime + mp_warmup_time.GetFloat();
game/shared/dod/dod_gamerules.cpp:				m_flWarmupTimeEnds = gpGlobals->curtime + mp_warmup_time.GetFloat();
game/shared/dod/dod_gamerules.cpp:			if( gpGlobals->curtime > m_flWarmupTimeEnds && m_flRestartRoundTime < 0 && !m_bAwaitingReadyRestart )
game/shared/dod/dod_gamerules.cpp:				m_flRestartRoundTime = gpGlobals->curtime;	// reset asap
game/shared/dod/dod_gamerules.cpp:			m_flRestartRoundTime = gpGlobals->curtime + iRestartDelay;
game/shared/dod/dod_gamerules.cpp:		for ( i=1; i<=gpGlobals->maxClients; i++ )
game/shared/dod/dod_gamerules.cpp:		for ( i=1; i<=gpGlobals->maxClients; i++ )
game/shared/dod/dod_gamerules.cpp:			for ( int i=0; i < gpGlobals->maxClients; i++ )
game/shared/dod/dod_gamerules.cpp:		m_flMapResetTime = gpGlobals->curtime;
game/shared/dod/dod_gamerules.cpp:		float flMapChangeSeconds = flMapChangeTime - gpGlobals->curtime;
game/shared/dod/dod_gamerules.cpp:	return ( (int)(flMapChangeTime - gpGlobals->curtime) );
game/shared/dod/dod_gamerules.cpp:	return MAX( 0, (int)( flWaveTime - gpGlobals->curtime ) );
game/shared/dod/dod_gamerules.cpp:		m_flNextPeriodicThink = gpGlobals->curtime + 0.1;
game/shared/dod/dod_gamerules.cpp:		m_flStateTransitionTime = gpGlobals->curtime + 5 * dod_enableroundwaittime.GetFloat();
game/shared/dod/dod_gamerules.cpp:		if( gpGlobals->curtime > m_flStateTransitionTime )
game/shared/dod/dod_gamerules.cpp:			m_flStateTransitionTime = gpGlobals->curtime + 10 * dod_enableroundwaittime.GetFloat();
game/shared/dod/dod_gamerules.cpp:			m_flStateTransitionTime = gpGlobals->curtime + 5 * dod_enableroundwaittime.GetFloat();
game/shared/dod/dod_gamerules.cpp:		if( gpGlobals->curtime > m_flStateTransitionTime )
game/shared/dod/dod_gamerules.cpp:		if( m_flRestartRoundTime > 0 && m_flRestartRoundTime < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:			m_flRestartRoundTime = gpGlobals->curtime + 5;
game/shared/dod/dod_gamerules.cpp:		if ( m_flNextFailSafeWaveCheckTime < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:			m_flNextFailSafeWaveCheckTime = gpGlobals->curtime + 3.0;
game/shared/dod/dod_gamerules.cpp:			if ( m_AlliesRespawnQueue[m_iAlliesRespawnHead] < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:			if ( m_AxisRespawnQueue[m_iAxisRespawnHead] < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:				if ( gpGlobals->curtime < ( pPlayer->GetDeathTime() + DEATH_CAM_TIME ) )
game/shared/dod/dod_gamerules.cpp:		m_flStateTransitionTime = gpGlobals->curtime + flTime * dod_enableroundwaittime.GetFloat();
game/shared/dod/dod_gamerules.cpp:		if( gpGlobals->curtime > m_flStateTransitionTime )
game/shared/dod/dod_gamerules.cpp:		m_flStateTransitionTime = gpGlobals->curtime + flTime * dod_enableroundwaittime.GetFloat();
game/shared/dod/dod_gamerules.cpp:		if( gpGlobals->curtime > m_flStateTransitionTime )
game/shared/dod/dod_gamerules.cpp:		for( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/dod/dod_gamerules.cpp:		for (i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/dod/dod_gamerules.cpp:		if ( FStrEq( STRING(gpGlobals->mapname), "dod_colmar" ) )
game/shared/dod/dod_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/dod/dod_gamerules.cpp:				if ( gpGlobals->curtime < ( pPlayer->GetDeathTime() + DEATH_CAM_TIME ) )
game/shared/dod/dod_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/dod/dod_gamerules.cpp:		float flWaveTime = GetWaveTime( team ) - gpGlobals->curtime;
game/shared/dod/dod_gamerules.cpp:			float flSpawnEligibleTime = gpGlobals->curtime + DEATH_CAM_TIME;
game/shared/dod/dod_gamerules.cpp:			if( iCurrent > gpGlobals->maxClients )
game/shared/dod/dod_gamerules.cpp:			m_AlliesRespawnQueue.Set( m_iAlliesRespawnTail, gpGlobals->curtime + flTime );
game/shared/dod/dod_gamerules.cpp:				gpGlobals->curtime + flTime );
game/shared/dod/dod_gamerules.cpp:			m_AxisRespawnQueue.Set( m_iAxisRespawnTail, gpGlobals->curtime + flTime );
game/shared/dod/dod_gamerules.cpp:				gpGlobals->curtime + flTime );
game/shared/dod/dod_gamerules.cpp:				gpGlobals->curtime );
game/shared/dod/dod_gamerules.cpp:				gpGlobals->curtime );
game/shared/dod/dod_gamerules.cpp:			//float flTimePlayed = gpGlobals->curtime - pPlayer->m_flConnectTime;
game/shared/dod/dod_gamerules.cpp:	m_flLastRoundStateChangeTime = gpGlobals->curtime;
game/shared/dod/dod_gamerules.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/shared/dod/dod_gamerules.cpp:	m_flNextHintTime = gpGlobals->curtime;
game/shared/dod/dod_gamerules.cpp:			if ( m_flNextHintTime < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:				m_flNextHintTime = gpGlobals->curtime + 1.0;
game/shared/dod/dod_gamerules.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/shared/dod/dod_gamerules.cpp:			m_flNextHintTime = gpGlobals->curtime;
game/shared/dod/dod_gamerules.cpp:				if ( m_flNextHintTime < gpGlobals->curtime )
game/shared/dod/dod_gamerules.cpp:					m_flNextHintTime = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_dodsniper.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 2.0;
game/shared/dod/weapon_dodsniper.cpp:	if ( IsZoomed() && ( gpGlobals->curtime - m_flZoomChangeTime ) > DOD_SNIPER_ZOOM_CHANGE_TIME )
game/shared/dod/weapon_dodsniper.cpp:	if ( m_flUnzoomTime > 0 && gpGlobals->curtime > m_flUnzoomTime )
game/shared/dod/weapon_dodsniper.cpp:		else if ( gpGlobals->curtime > m_flRezoomTime )
game/shared/dod/weapon_dodsniper.cpp:	if ( m_flZoomInTime > 0 && gpGlobals->curtime > m_flZoomInTime )
game/shared/dod/weapon_dodsniper.cpp:	m_flZoomInTime = gpGlobals->curtime + DOD_SNIPER_ZOOM_CHANGE_TIME;
game/shared/dod/weapon_dodsniper.cpp:	m_flNextPrimaryAttack = MAX( gpGlobals->curtime + 0.5, m_flNextPrimaryAttack );
game/shared/dod/weapon_dodsniper.cpp:	m_flNextSecondaryAttack = MAX( gpGlobals->curtime + 0.5, m_flNextSecondaryAttack );
game/shared/dod/weapon_dodsniper.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + m_pWeaponInfo->m_flTimeToIdleAfterFire;
game/shared/dod/weapon_dodsniper.cpp:	m_flZoomChangeTime = gpGlobals->curtime;
game/shared/dod/weapon_dodsniper.cpp:		m_flNextPrimaryAttack = MAX( gpGlobals->curtime + 0.5, m_flNextPrimaryAttack );
game/shared/dod/weapon_dodsniper.cpp:		m_flNextSecondaryAttack = MAX( gpGlobals->curtime + 0.5, m_flNextSecondaryAttack );
game/shared/dod/weapon_dodsniper.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + m_pWeaponInfo->m_flTimeToIdleAfterFire;
game/shared/dod/weapon_dodsniper.cpp:	m_flZoomChangeTime = gpGlobals->curtime;
game/shared/dod/weapon_dodsniper.cpp:	m_flRezoomTime = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_dodsniper.cpp:	m_flUnzoomTime = gpGlobals->curtime + flDelay;
game/shared/dod/weapon_dodsniper.cpp:		(( gpGlobals->curtime - m_flZoomChangeTime ) > DOD_SNIPER_ZOOM_CHANGE_TIME) );
game/shared/dod/weapon_dodsniper.cpp:	return ( m_flZoomInTime > gpGlobals->curtime );
game/shared/dod/weapon_dodsniper.cpp:			m_flViewAnimTimer = gpGlobals->curtime + DOD_SNIPER_ZOOM_CHANGE_TIME;
game/shared/dod/weapon_dodsniper.cpp:		float flZoomAnimPercent = clamp( ( (m_flViewAnimTimer - gpGlobals->curtime) / ( DOD_SNIPER_ZOOM_CHANGE_TIME ) ), 0.0, 1.0 );
game/shared/dod/weapon_dodsniper.cpp:		//Msg( "(%.1f) zoom %.2f %.2f\n", gpGlobals->curtime, m_flViewAnimTimer - gpGlobals->curtime, m_flZoomPercent );
game/shared/dod/dod_player_shared.h:		m_flEndTime = gpGlobals->curtime + flTime;
game/shared/dod/dod_player_shared.h:		float flFraction = ( m_flEndTime - gpGlobals->curtime ) / m_flLength;
game/shared/dod/dod_player_shared.h:		return ( gpGlobals->curtime > m_flEndTime || m_pPlayer == NULL );
game/shared/dod/weapon_dodbase.cpp:	if ( m_flSmackTime > 0 && gpGlobals->curtime > m_flSmackTime )
game/shared/dod/weapon_dodbase.cpp:	if ((m_bInReload) && (pPlayer->m_flNextAttack <= gpGlobals->curtime))
game/shared/dod/weapon_dodbase.cpp:	if ((pPlayer->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/shared/dod/weapon_dodbase.cpp:	else if ((pPlayer->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime ) && !m_bInAttack )
game/shared/dod/weapon_dodbase.cpp:	else if ( pPlayer->m_nButtons & IN_RELOAD && GetMaxClip1() != WEAPON_NOCLIP && !m_bInReload && m_flNextPrimaryAttack < gpGlobals->curtime) 
game/shared/dod/weapon_dodbase.cpp:		if ( !IsUseable() && m_flNextPrimaryAttack < gpGlobals->curtime ) 
game/shared/dod/weapon_dodbase.cpp:			if ( m_iClip1 == 0 && !(GetWeaponFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < gpGlobals->curtime )
game/shared/dod/weapon_dodbase.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/dod/weapon_dodbase.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbase.cpp:	pOwner->SetNextAttack( gpGlobals->curtime + SequenceDuration() );
game/shared/dod/weapon_dodbase.cpp:	m_flNextPrimaryAttack	= MAX( m_flNextPrimaryAttack, gpGlobals->curtime );
game/shared/dod/weapon_dodbase.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime;
game/shared/dod/weapon_dodbase.cpp:			if ( m_iClip1 == 0 && !(GetWeaponFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < gpGlobals->curtime )
game/shared/dod/weapon_dodbase.cpp:		SetNextThink( gpGlobals->curtime + 1 );
game/shared/dod/weapon_dodbase.cpp:		SetNextThink( gpGlobals->curtime + time );
game/shared/dod/weapon_dodbase.cpp:			pNewWeapon->SetNextThink( gpGlobals->curtime + g_pGameRules->FlWeaponRespawnTime( this ) );
game/shared/dod/weapon_dodbase.cpp:			SetContextThink( &CWeaponDODBase::Die, gpGlobals->curtime + 45.0f, "DieContext" );
game/shared/dod/weapon_dodbase.cpp:			SetContextThink( NULL, gpGlobals->curtime, "DieContext" );
game/shared/dod/weapon_dodbase.cpp:	float flSequenceEndTime = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbase.cpp:		m_flSmackTime = gpGlobals->curtime + flDmgDelay;
game/shared/dod/weapon_dodbase.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + flAttackDelay;
game/shared/dod/weapon_dodbase.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + flAttackDelay;
game/shared/dod/weapon_dodbase.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbase.cpp:		if ( ( !gpGlobals->frametime ) || ( player == NULL ) )
game/shared/dod/weapon_dodbase.cpp:		float flmaxSpeedDelta = MAX( 0, (gpGlobals->curtime - lastbobtime) * 320.0f );
game/shared/dod/weapon_dodbase.cpp:		bobtime += ( gpGlobals->curtime - lastbobtime ) * bob_offset;
game/shared/dod/weapon_dodbase.cpp:		lastbobtime = gpGlobals->curtime;
game/shared/dod/weapon_dodbasebomb.cpp:		else if ( gpGlobals->curtime > m_flPlantCompleteTime )
game/shared/dod/weapon_dodbasebomb.cpp:			m_flNextPlantCheck = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_dodbasebomb.cpp:	m_flNextPlantCheck = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_dodbasebomb.cpp:	m_flPlantCompleteTime = gpGlobals->curtime + DOD_BOMB_PLANT_TIME;
game/shared/dod/weapon_dodbasebomb.cpp:	else if ( !m_bUsePlant || m_flNextPlantCheck < gpGlobals->curtime )
game/shared/dod/weapon_dodbasebomb.cpp:		if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/dod/weapon_dodbasebomb.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasemelee.cpp:	if ( m_flTimeWeaponIdle > gpGlobals->curtime )
game/shared/dod/weapon_dodbasemelee.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasemelee.cpp:		m_flSmackTime = gpGlobals->curtime + flDmgDelay;
game/shared/dod/weapon_dodbasemelee.cpp:		m_flSmackTime = gpGlobals->curtime + 0.4f;
game/shared/dod/weapon_dodbasemelee.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + flAttackDelay;
game/shared/dod/weapon_dodbasemelee.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + flAttackDelay;
game/shared/dod/weapon_dodbasemelee.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasegrenade.cpp:		if ( ( m_bRedraw ) && ( m_flNextPrimaryAttack <= gpGlobals->curtime ) && ( m_flNextSecondaryAttack <= gpGlobals->curtime ) )
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_dodbasegrenade.cpp:				m_flDetonateTime = gpGlobals->curtime + GetDetonateTimerLength();
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flTimeWeaponIdle		= gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbasegrenade.cpp:		if( IsArmed() && gpGlobals->curtime > m_flDetonateTime )
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_dodbasegrenade.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_dodbasegrenade.cpp:			flTimeLeft = MAX( 0, m_flDetonateTime - gpGlobals->curtime );
game/shared/dod/dod_playeranimstate.cpp:			m_flFireIdleTime = gpGlobals->curtime + 0.1;	// don't hold this pose after firing
game/shared/dod/dod_playeranimstate.cpp:			m_flFireIdleTime = gpGlobals->curtime + 2;	
game/shared/dod/dod_playeranimstate.cpp:		m_flJumpStartTime = gpGlobals->curtime;
game/shared/dod/dod_playeranimstate.cpp:		if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
game/shared/dod/dod_playeranimstate.cpp:	if ( m_flFireIdleTime > gpGlobals->curtime )
game/shared/dod/dod_playeranimstate.cpp:	if( m_flFireIdleTime < gpGlobals->curtime &&
game/shared/dod/dod_playeranimstate.cpp:	flCurCycle += m_pOuter->GetSequenceCycleRate( pStudioHdr, iSequence ) * gpGlobals->frametime;
game/shared/dod/dod_playeranimstate.cpp:		m_flLastTurnTime = gpGlobals->curtime;
game/shared/dod/dod_playeranimstate.cpp:	float flDeltaTime = gpGlobals->frametime;
game/shared/dod/dod_playeranimstate.cpp:			m_flLastAimTurnTime = gpGlobals->curtime;
game/shared/dod/dod_playeranimstate.cpp:		ConvergeYawAngles( m_flGoalFeetYaw, DOD_BODYYAW_RATE, gpGlobals->frametime, m_flCurrentFeetYaw );
game/shared/dod/dod_playeranimstate.cpp:		m_flLastAimTurnTime = gpGlobals->curtime;
game/shared/dod/dod_playeranimstate.cpp://	Anim_StateLog( "-------------%s: frame %d -----------------\n", bIsServer ? "Server" : "Client", gpGlobals->framecount );
game/shared/dod/dod_playeranimstate.cpp:	Anim_StatePrintf( iLine++, "-------------%s: frame %d -----------------\n", bIsServer ? "Server" : "Client", gpGlobals->framecount );
game/shared/dod/dod_playeranimstate.cpp:	Anim_StatePrintf( iLine++, "Time: %.2f, Speed: %.2f, MaxSpeed: %.2f", gpGlobals->curtime, vecVelocity.Length2D(), GetCurrentMaxGroundSpeed() );
game/shared/dod/dod_viewmodel.cpp:	m_LagAnglesHistory.NoteChanged( gpGlobals->curtime, cl_wpn_sway_interp.GetFloat(), false );
game/shared/dod/dod_viewmodel.cpp:	m_LagAnglesHistory.Interpolate( gpGlobals->curtime, cl_wpn_sway_interp.GetFloat() );
game/shared/dod/weapon_dodfullauto_punch.cpp:		GetPlayerOwner()->m_flNextAttack = gpGlobals->curtime;
game/shared/dod/weapon_dodfullauto_punch.cpp:	else if ( GetPlayerOwner()->m_flNextAttack > gpGlobals->curtime )
game/shared/dod/weapon_dodfullauto_punch.cpp:	GetPlayerOwner()->m_flNextAttack = gpGlobals->curtime;
game/shared/dod/weapon_dodfullauto_punch.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime;
game/shared/dod/weapon_dodfullauto_punch.cpp:	if ( pPlayer && (pPlayer->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/shared/dod/weapon_riflegrenade.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_riflegrenade.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_riflegrenade.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + GetFireDelay();
game/shared/dod/weapon_riflegrenade.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + m_pWeaponInfo->m_flTimeToIdleAfterFire;
game/shared/dod/weapon_30cal.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_dodfireselect.cpp:			m_flPosChangeTimer = gpGlobals->curtime;
game/shared/dod/weapon_dodfireselect.cpp:			m_flPosChangeTimer = gpGlobals->curtime;
game/shared/dod/weapon_dodfireselect.cpp:		m_flPosChangeTimer = gpGlobals->curtime;
game/shared/dod/weapon_dodfireselect.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodfireselect.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodfireselect.cpp:		float timer = gpGlobals->curtime - m_flPosChangeTimer;
game/shared/dod/dod_gamemovement.cpp:		else if ( m_pDODPlayer->m_Shared.GetSlowedTime() > gpGlobals->curtime )
game/shared/dod/dod_gamemovement.cpp:			float pronetime = m_pDODPlayer->m_Shared.m_flGoProneTime - gpGlobals->curtime;
game/shared/dod/dod_gamemovement.cpp:			float pronetime = m_pDODPlayer->m_Shared.m_flUnProneTime - gpGlobals->curtime;
game/shared/dod/dod_gamemovement.cpp:		//flStamina -= 30 * gpGlobals->frametime;	//reduction for sprinting
game/shared/dod/dod_gamemovement.cpp:		//flStamina += 10 * gpGlobals->frametime;	//addition for recovering
game/shared/dod/dod_gamemovement.cpp:		flStamina -= 20 * gpGlobals->frametime;
game/shared/dod/dod_gamemovement.cpp:			flStamina += 60 * gpGlobals->frametime;
game/shared/dod/dod_gamemovement.cpp:			flStamina += 50 * gpGlobals->frametime;
game/shared/dod/dod_gamemovement.cpp:			flStamina += 10 * gpGlobals->frametime;
game/shared/dod/dod_gamemovement.cpp:		flWaterJumpTime -= gpGlobals->frametime;
game/shared/dod/dod_gamemovement.cpp:	float flTimeSinceDeployChange = gpGlobals->curtime - m_pDODPlayer->m_Shared.m_flDeployChangeTime;
game/shared/dod/dod_gamemovement.cpp:				m_pDODPlayer->m_Shared.SetLastViewAnimTime( gpGlobals->curtime );
game/shared/dod/dod_gamemovement.cpp:				m_pDODPlayer->m_Shared.SetLastViewAnimTime( gpGlobals->curtime );
game/shared/dod/dod_gamemovement.cpp:		float pronetime = m_pDODPlayer->m_Shared.m_flUnProneTime - gpGlobals->curtime;
game/shared/dod/dod_gamemovement.cpp:		float pronetime = m_pDODPlayer->m_Shared.m_flGoProneTime - gpGlobals->curtime;
game/shared/dod/dod_gamemovement.cpp:	if ( gpGlobals->curtime > m_pDODPlayer->m_Shared.m_flNextProneCheck )
game/shared/dod/dod_gamemovement.cpp:			m_pDODPlayer->m_Shared.m_flNextProneCheck = gpGlobals->curtime + 1.0f;
game/shared/dod/dod_player_shared.cpp:	m_flMinNextStepSoundTime = gpGlobals->curtime;
game/shared/dod/dod_player_shared.cpp:	m_flDeployChangeTime = gpGlobals->curtime;
game/shared/dod/dod_player_shared.cpp:	m_flLastViewAnimationTime = gpGlobals->curtime;
game/shared/dod/dod_player_shared.cpp:	if( gpGlobals->curtime - m_flDeployChangeTime < 0.2 )
game/shared/dod/dod_player_shared.cpp:	m_flDeployChangeTime = gpGlobals->curtime;
game/shared/dod/dod_player_shared.cpp:	m_flSlowedUntilTime = gpGlobals->curtime + t;
game/shared/dod/dod_player_shared.cpp:	m_flGoProneTime = gpGlobals->curtime + TIME_TO_PRONE;
game/shared/dod/dod_player_shared.cpp:	m_flUnProneTime = gpGlobals->curtime + TIME_TO_PRONE;
game/shared/dod/dod_player_shared.cpp:		m_flStepSoundTime -= 1000.0f * gpGlobals->frametime;
game/shared/dod/dod_player_shared.cpp:	if ( m_flMinNextStepSoundTime > gpGlobals->curtime )
game/shared/dod/dod_player_shared.cpp:	m_flMinNextStepSoundTime = gpGlobals->curtime + 0.1f;	
game/shared/dod/dod_player_shared.cpp:	if ( gpGlobals->maxClients > 1 && !sv_footsteps.GetFloat() )
game/shared/dod/dod_player_shared.cpp:	if ( gpGlobals->maxClients > 1 )
game/shared/dod/dod_round_timer.cpp:	m_flTimerEndTime = gpGlobals->curtime + m_flTimeRemaining;
game/shared/dod/dod_round_timer.cpp:		m_flTimeRemaining = m_flTimerEndTime - gpGlobals->curtime;
game/shared/dod/dod_round_timer.cpp:		m_flTimerEndTime = gpGlobals->curtime + m_flTimeRemaining;
game/shared/dod/dod_round_timer.cpp:		flSecondsRemaining = m_flTimerEndTime - gpGlobals->curtime;
game/shared/dod/weapon_dodbipodgun.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime;
game/shared/dod/weapon_dodbipodgun.cpp:	if ((pPlayer->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/shared/dod/weapon_dodbipodgun.cpp:	if ( m_flNextDeployCheckTime < gpGlobals->curtime )
game/shared/dod/weapon_dodbipodgun.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 0.1;
game/shared/dod/weapon_dodbipodgun.cpp:				m_flNextSecondaryAttack = gpGlobals->curtime + 0.1;
game/shared/dod/weapon_dodbipodgun.cpp:		m_flNextDeployCheckTime = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_dodbipodgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbipodgun.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbipodgun.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbipodgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbipodgun.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/dod/weapon_dodbipodgun.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/dod/achievements_dod.cpp:			if ( ( gpGlobals->curtime - m_flLastKillTime ) > 0.25 )
game/shared/dod/achievements_dod.cpp:			m_flLastKillTime = gpGlobals->curtime;
game/shared/dod/weapon_mg42.cpp:			msg->SetFloat( "time", gpGlobals->curtime );
game/shared/dod/weapon_mg42.cpp:		m_flParticleAccumulator += ( gpGlobals->frametime * flEmitRate );
game/shared/dod/weapon_mg42.cpp:		SetContextThink( &CWeaponMG42::CoolThink, gpGlobals->curtime + 0.1, COOL_CONTEXT );
game/shared/dod/weapon_mg42.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_mg42.cpp:	m_flNextCoolTime = gpGlobals->curtime + 0.16f;
game/shared/dod/weapon_mg42.cpp:	if( gpGlobals->curtime > m_flNextCoolTime )
game/shared/dod/weapon_mg42.cpp:		m_flNextCoolTime = gpGlobals->curtime + 0.16f;
game/shared/dod/weapon_mg42.cpp:	SetContextThink( &CWeaponMG42::CoolThink, gpGlobals->curtime + 0.1, COOL_CONTEXT );
game/shared/dod/weapon_mg42.cpp:	SetContextThink( &CWeaponMG42::CoolThink, gpGlobals->curtime + 0.1, COOL_CONTEXT );
game/shared/dod/weapon_mg42.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/shared/dod/weapon_mg42.cpp:		msg->SetFloat( "time", gpGlobals->curtime );
game/shared/dod/weapon_dodbasegun.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/dod/weapon_dodbasegun.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/dod/weapon_dodbasegun.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + GetFireDelay();
game/shared/dod/weapon_dodbasegun.cpp:	m_flTimeWeaponIdle = gpGlobals->curtime + m_pWeaponInfo->m_flTimeToIdleAfterFire;
game/shared/teamplayroundbased_gamerules.cpp:	return ( gpGlobals->curtime > flMinSpawnTime );
game/shared/teamplayroundbased_gamerules.cpp:		if ( m_flIntermissionEndTime && ( m_flIntermissionEndTime < gpGlobals->curtime ) )
game/shared/teamplayroundbased_gamerules.cpp:	if ( gpGlobals->curtime > m_flNextPeriodicThink )
game/shared/teamplayroundbased_gamerules.cpp:		m_flNextPeriodicThink = gpGlobals->curtime + 1.0;
game/shared/teamplayroundbased_gamerules.cpp:	if ( IsLoadingBugBaitReport() || gpGlobals->eLoadType == MapLoad_Background )
game/shared/teamplayroundbased_gamerules.cpp:		m_flWaitingForPlayersTimeEnds = gpGlobals->curtime + mp_waitingforplayers_time.GetFloat();
game/shared/teamplayroundbased_gamerules.cpp:	if ( IsLoadingBugBaitReport() || gpGlobals->eLoadType == MapLoad_Background || !AllowWaitingForPlayers() )
game/shared/teamplayroundbased_gamerules.cpp:			m_flWaitingForPlayersTimeEnds = gpGlobals->curtime + mp_waitingforplayers_time.GetFloat();
game/shared/teamplayroundbased_gamerules.cpp:				sVariant.SetInt( m_flWaitingForPlayersTimeEnds - gpGlobals->curtime );
game/shared/teamplayroundbased_gamerules.cpp:		if( gpGlobals->curtime > m_flWaitingForPlayersTimeEnds && m_flRestartRoundTime < 0 && !m_bAwaitingReadyRestart )
game/shared/teamplayroundbased_gamerules.cpp:			m_flRestartRoundTime = gpGlobals->curtime;	// reset asap
game/shared/teamplayroundbased_gamerules.cpp:				if ( gpGlobals->curtime > m_flWaitingForPlayersTimeEnds )
game/shared/teamplayroundbased_gamerules.cpp:				sVariant.SetInt( m_flWaitingForPlayersTimeEnds - gpGlobals->curtime );
game/shared/teamplayroundbased_gamerules.cpp:		m_flRestartRoundTime = gpGlobals->curtime + iRestartDelay;
game/shared/teamplayroundbased_gamerules.cpp:	int iTime = (int)(flMapChangeTime - gpGlobals->curtime);
game/shared/teamplayroundbased_gamerules.cpp:	m_flLastRoundStateChangeTime = gpGlobals->curtime;
game/shared/teamplayroundbased_gamerules.cpp:	m_flNextPeriodicThink = gpGlobals->curtime + 0.1;
game/shared/teamplayroundbased_gamerules.cpp:	if ( IsLoadingBugBaitReport() || gpGlobals->eLoadType == MapLoad_Background )
game/shared/teamplayroundbased_gamerules.cpp:	m_flStateTransitionTime = gpGlobals->curtime;
game/shared/teamplayroundbased_gamerules.cpp:	if( gpGlobals->curtime > m_flStateTransitionTime )
game/shared/teamplayroundbased_gamerules.cpp:	m_flStartBalancingTeamsAt = gpGlobals->curtime + 60.0;
game/shared/teamplayroundbased_gamerules.cpp:		m_flStateTransitionTime = gpGlobals->curtime + tf_arena_preround_time.GetInt();
game/shared/teamplayroundbased_gamerules.cpp:		m_flStateTransitionTime = gpGlobals->curtime + 5 * mp_enableroundwaittime.GetFloat();
game/shared/teamplayroundbased_gamerules.cpp:	if( gpGlobals->curtime > m_flStateTransitionTime )
game/shared/teamplayroundbased_gamerules.cpp:	m_flNextBalanceTeamsTime = gpGlobals->curtime + 1.0f;
game/shared/teamplayroundbased_gamerules.cpp:	if( m_flRestartRoundTime > 0 && m_flRestartRoundTime <= gpGlobals->curtime && !g_pServerBenchmark->IsBenchmarkRunning() )
game/shared/teamplayroundbased_gamerules.cpp:	if ( m_flNextBalanceTeamsTime < gpGlobals->curtime )
game/shared/teamplayroundbased_gamerules.cpp:		m_flNextBalanceTeamsTime = gpGlobals->curtime + 1.0f;
game/shared/teamplayroundbased_gamerules.cpp:	m_flStateTransitionTime = gpGlobals->curtime + flTime;
game/shared/teamplayroundbased_gamerules.cpp:	if( gpGlobals->curtime > m_flStateTransitionTime )
game/shared/teamplayroundbased_gamerules.cpp:						g_pPopulationManager->SetMapRestartTime( gpGlobals->curtime + 10.0f );
game/shared/teamplayroundbased_gamerules.cpp:	m_flStalemateStartTime = gpGlobals->curtime;
game/shared/teamplayroundbased_gamerules.cpp:		event->SetFloat( "round_time", gpGlobals->curtime - m_flRoundStartTime );
game/shared/teamplayroundbased_gamerules.cpp:		for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/teamplayroundbased_gamerules.cpp:	for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/teamplayroundbased_gamerules.cpp:	for (i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/teamplayroundbased_gamerules.cpp:	m_flRoundStartTime = gpGlobals->curtime;
game/shared/teamplayroundbased_gamerules.cpp:		if ( m_flNextRespawnWave[team] && m_flNextRespawnWave[team] > gpGlobals->curtime )
game/shared/teamplayroundbased_gamerules.cpp:			m_flNextRespawnWave.Set( team, gpGlobals->curtime + flNextRespawnLength );
game/shared/teamplayroundbased_gamerules.cpp:	if ( gpGlobals->curtime < m_flStartBalancingTeamsAt )
game/shared/teamplayroundbased_gamerules.cpp:		m_flFoundUnbalancedTeamsTime = gpGlobals->curtime;
game/shared/teamplayroundbased_gamerules.cpp:	if ( !m_bPrintedUnbalanceWarning && ( ( gpGlobals->curtime - m_flFoundUnbalancedTeamsTime ) > 1.0 ) )
game/shared/teamplayroundbased_gamerules.cpp:					m_flAutoBalanceQueueTimeEnd = gpGlobals->curtime + 3.0f;
game/shared/teamplayroundbased_gamerules.cpp:					if ( m_flAutoBalanceQueueTimeEnd > gpGlobals->curtime )
game/shared/teamplayroundbased_gamerules.cpp:		for( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/teamplayroundbased_gamerules.cpp:	m_flMapResetTime = gpGlobals->curtime;
game/shared/teamplayroundbased_gamerules.cpp:	if ( m_flNewThrottledAlertTime <= gpGlobals->curtime )
game/shared/teamplayroundbased_gamerules.cpp:		m_flNewThrottledAlertTime = gpGlobals->curtime + fDelayBeforeNext;
game/shared/teamplayroundbased_gamerules.cpp:	m_flLastRoundStateChangeTime = gpGlobals->curtime;
game/shared/Sprite.cpp:	Animate( m_flSpriteFramerate * (gpGlobals->curtime - m_flLastTime) );
game/shared/Sprite.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/Sprite.cpp:	m_flLastTime			= gpGlobals->curtime;
game/shared/Sprite.cpp:	if ( gpGlobals->curtime > m_flDieTime )
game/shared/Sprite.cpp:		SetNextThink( gpGlobals->curtime );
game/shared/Sprite.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/Sprite.cpp:	m_flLastTime	= gpGlobals->curtime;
game/shared/Sprite.cpp:	float frametime = gpGlobals->curtime - m_flLastTime;
game/shared/Sprite.cpp:		SetNextThink( gpGlobals->curtime );
game/shared/Sprite.cpp:		m_flLastTime		= gpGlobals->curtime;
game/shared/Sprite.cpp:		SetNextThink( gpGlobals->curtime );
game/shared/Sprite.cpp:		m_flLastTime = gpGlobals->curtime;
game/shared/Sprite.cpp:	if ( ( m_flScaleTime == 0 ) || ( (m_flScaleTimeStart+m_flScaleTime) < gpGlobals->curtime ) )
game/shared/Sprite.cpp:	float timeDelta = ( gpGlobals->curtime - m_flScaleTimeStart ) / m_flScaleTime;
game/shared/Sprite.cpp:	if ( ( m_flBrightnessTime == 0 ) || ( (m_flBrightnessTimeStart+m_flBrightnessTime) < gpGlobals->curtime ) )
game/shared/Sprite.cpp:	float timeDelta = ( gpGlobals->curtime - m_flBrightnessTimeStart ) / m_flBrightnessTime;
game/shared/Sprite.cpp:		m_flScaleTimeStart	= gpGlobals->curtime;
game/shared/Sprite.cpp:		m_flBrightnessTimeStart = gpGlobals->curtime;
game/shared/hl2/basehlcombatweapon_shared.cpp:	if ( ( gpGlobals->curtime - m_flHolsterTime ) > sk_auto_reload_time.GetFloat() )
game/shared/hl2/basehlcombatweapon_shared.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/hl2/basehlcombatweapon_shared.cpp:	m_flRaiseTime = gpGlobals->curtime + 0.5f;
game/shared/hl2/basehlcombatweapon_shared.cpp:					pPlayer->SetNextAttack( gpGlobals->curtime + 1.0 );
game/shared/hl2/basehlcombatweapon_shared.cpp:					m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl2/basehlcombatweapon_shared.cpp:					m_flNextSecondaryAttack	= gpGlobals->curtime + 1.0;
game/shared/hl2/basehlcombatweapon_shared.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/hl2/basehlcombatweapon_shared.cpp:		if ( m_flRaiseTime < gpGlobals->curtime && GetActivity() == ACT_VM_IDLE_LOWERED ) 
game/shared/hl2/basehlcombatweapon_shared.cpp:	if ( ( !gpGlobals->frametime ) || ( player == NULL ) )
game/shared/hl2/basehlcombatweapon_shared.cpp:	bobtime += ( gpGlobals->curtime - lastbobtime ) * bob_offset;
game/shared/hl2/basehlcombatweapon_shared.cpp:	lastbobtime = gpGlobals->curtime;
game/shared/hl2/survival_gamerules.cpp:	Q_snprintf( szFullName, sizeof( szFullName ), "maps/%s_survival.txt", STRING(gpGlobals->mapname) );
game/shared/hl2/hl_gamemovement.cpp:	lm->m_flStartTime		= gpGlobals->curtime;
game/shared/hl2/hl_gamemovement.cpp:	float frac = ( gpGlobals->curtime - lm->m_flStartTime ) / ( lm->m_flArrivalTime - lm->m_flStartTime );
game/shared/hl2/hl_gamemovement.cpp:	float ladderUnitsPerTick = ( MAX_CLIMB_SPEED * gpGlobals->interval_per_tick );
game/shared/hl2/hl2_gamerules.cpp:		if ( m_flLastHealthDropTime > gpGlobals->curtime )
game/shared/hl2/hl2_gamerules.cpp:		if ( m_flLastGrenadeDropTime > gpGlobals->curtime )
game/shared/hl2/hl2_gamerules.cpp:		m_flLastHealthDropTime = gpGlobals->curtime + sk_plr_health_drop_time.GetFloat();
game/shared/hl2/hl2_gamerules.cpp:		m_flLastGrenadeDropTime = gpGlobals->curtime + sk_plr_grenade_drop_time.GetFloat();
game/shared/hl2/hl2_gamerules.cpp:	if ( !Q_strnicmp( gpGlobals->mapname.ToCStr(), "ep1_", 4 ) )
game/shared/basecombatcharacter_shared.cpp:		if ( !entry.m_hEntity1.IsValid() || !entry.m_hEntity2.IsValid() || ( gpGlobals->curtime - entry.m_flTime > 10.0f ) )
game/shared/basecombatcharacter_shared.cpp:		m_VisCache[iCache].m_flTime = gpGlobals->curtime - 2.0f * VIS_CACHE_ENTRY_LIFE;
game/shared/basecombatcharacter_shared.cpp:	if ( gpGlobals->curtime - entry.m_flTime > VIS_CACHE_ENTRY_LIFE )
game/shared/basecombatcharacter_shared.cpp:	entry.m_flTime = gpGlobals->curtime;
game/shared/basecombatcharacter_shared.cpp:	if ( frame != gpGlobals->framecount )
game/shared/basecombatcharacter_shared.cpp:		frame = gpGlobals->framecount;
game/shared/beam_shared.cpp:			CTakeDamageInfo info( this, this, m_flDamage * (gpGlobals->curtime - m_flFireTime), nDamageType );
game/shared/beam_shared.cpp:	m_flFireTime = gpGlobals->curtime;
game/shared/particle_property.cpp:	bool bRemoveInstantly = (m_iDormancyChangedAtFrame == gpGlobals->framecount);
game/shared/particle_property.cpp:	bool bRemoveInstantly = (m_iDormancyChangedAtFrame == gpGlobals->framecount);
game/shared/particle_property.cpp:	bool bRemoveInstantly = (m_iDormancyChangedAtFrame == gpGlobals->framecount);
game/shared/particle_property.cpp:	bool bRemoveInstantly = (m_iDormancyChangedAtFrame == gpGlobals->framecount);
game/shared/particle_property.cpp:	m_iDormancyChangedAtFrame = gpGlobals->framecount;
game/shared/beam_shared.h:	SetNextThink( gpGlobals->curtime + time ); 
game/shared/beam_shared.h:	m_flFireTime = gpGlobals->curtime - 1;
game/shared/sdk/sdk_playeranimstate.cpp:		m_flJumpStartTime = gpGlobals->curtime;
game/shared/sdk/sdk_playeranimstate.cpp:		flCurCycle += m_pOuter->GetSequenceCycleRate( pStudioHdr, iSequence ) * gpGlobals->frametime;
game/shared/sdk/sdk_playeranimstate.cpp:		if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
game/shared/sdk/sdk_weapon_melee.cpp:	if ( (pPlayer->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime) && pPlayer->CanAttack() )
game/shared/sdk/sdk_weapon_melee.cpp:	else if ( (pPlayer->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime) && pPlayer->CanAttack() )
game/shared/sdk/sdk_weapon_melee.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + GetFireRate();
game/shared/sdk/sdk_weapon_melee.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/sdk/sdk_basegrenade_projectile.cpp:			if ( gpGlobals->curtime - m_flSpawnTime < 0.5 )
game/shared/sdk/sdk_basegrenade_projectile.cpp:		m_flSpawnTime = gpGlobals->curtime;
game/shared/sdk/sdk_basegrenade_projectile.cpp:		if( gpGlobals->curtime > m_flDetonateTime )
game/shared/sdk/sdk_basegrenade_projectile.cpp:		SetNextThink( gpGlobals->curtime + 0.2 );
game/shared/sdk/sdk_basegrenade_projectile.cpp:		m_flDetonateTime = gpGlobals->curtime + timer;
game/shared/sdk/sdk_basegrenade_projectile.cpp:				VectorScale( vecAbsVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, vecVelocity ); 
game/shared/sdk/sdk_basegrenade_projectile.cpp:				VectorMA( vecVelocity, ( 1.0f - trace.fraction ) * gpGlobals->frametime, GetBaseVelocity() * flScale, vecVelocity );
game/shared/sdk/weapon_shotgun.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.15;
game/shared/sdk/weapon_shotgun.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/sdk/weapon_shotgun.cpp:		m_flPumpTime = gpGlobals->curtime + 0.5;
game/shared/sdk/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.875;
game/shared/sdk/weapon_shotgun.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.875;
game/shared/sdk/weapon_shotgun.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 2.5 );
game/shared/sdk/weapon_shotgun.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.875 );
game/shared/sdk/weapon_shotgun.cpp:	if (m_flNextPrimaryAttack > gpGlobals->curtime)
game/shared/sdk/weapon_shotgun.cpp:		pPlayer->m_flNextAttack = gpGlobals->curtime + 0.5;
game/shared/sdk/weapon_shotgun.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/sdk/weapon_shotgun.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/sdk/weapon_shotgun.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/sdk/weapon_shotgun.cpp:		if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/sdk/weapon_shotgun.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.45 );
game/shared/sdk/weapon_shotgun.cpp:	if (m_flPumpTime && m_flPumpTime < gpGlobals->curtime)
game/shared/sdk/weapon_shotgun.cpp:	if (m_flTimeWeaponIdle < gpGlobals->curtime)
game/shared/sdk/weapon_shotgun.cpp:				SetWeaponIdleTime( gpGlobals->curtime + 1.5 );
game/shared/sdk/weapon_grenade.cpp:		pGrenade->SetNextThink( gpGlobals->curtime );
game/shared/sdk/weapon_basesdkgrenade.cpp:	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/sdk/weapon_basesdkgrenade.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/sdk/weapon_basesdkgrenade.cpp:	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/sdk/weapon_basesdkgrenade.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/sdk/weapon_basesdkgrenade.cpp:	if ( ( m_bRedraw ) && ( m_flNextPrimaryAttack <= gpGlobals->curtime ) && ( m_flNextSecondaryAttack <= gpGlobals->curtime ) )
game/shared/sdk/weapon_basesdkgrenade.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/sdk/weapon_basesdkgrenade.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/sdk/weapon_basesdkgrenade.cpp:		SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/sdk/weapon_basesdkgrenade.cpp:		SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/sdk/weapon_basesdkgrenade.cpp:	else if ((m_fThrowTime > 0) && (m_fThrowTime < gpGlobals->curtime))
game/shared/sdk/weapon_basesdkgrenade.cpp:		if( m_flTimeWeaponIdle < gpGlobals->curtime )
game/shared/sdk/weapon_basesdkgrenade.cpp:		m_fThrowTime = gpGlobals->curtime + 0.1f;
game/shared/sdk/weapon_basesdkgrenade.cpp:		m_fThrowTime = gpGlobals->curtime + 0.1f;
game/shared/sdk/weapon_mp5.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/sdk/weapon_mp5.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + flCycleTime;
game/shared/sdk/weapon_mp5.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 5.0 );
game/shared/sdk/weapon_mp5.cpp:	if (m_flTimeWeaponIdle > gpGlobals->curtime)
game/shared/sdk/weapon_mp5.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 5.0f );
game/shared/Sprite.h:		m_flDieTime = gpGlobals->curtime + duration; 
game/shared/Sprite.h:		SetNextThink( gpGlobals->curtime );  
game/shared/Sprite.h:		m_flDieTime = gpGlobals->curtime + (m_flMaxFrame / m_flSpriteFramerate); 
game/shared/Sprite.h:		SetNextThink( gpGlobals->curtime ); 
game/shared/Sprite.h:		m_flDieTime = gpGlobals->curtime + time;
game/shared/Sprite.h:		SetNextThink( gpGlobals->curtime ); 
game/shared/Sprite.h:		SetNextThink( gpGlobals->curtime + 0.01f ); 
game/shared/point_posecontroller.cpp:	SetNextThink( gpGlobals->curtime + 1.0 );
game/shared/point_posecontroller.cpp:		SetNextThink( gpGlobals->curtime + 1.0 );
game/shared/point_posecontroller.cpp:	SetNextThink( gpGlobals->curtime + 1.0 );
game/shared/point_posecontroller.cpp:		float fClientPoseValue = m_fCurrentPoseValue + m_PoseTransitionValue.Interp( gpGlobals->curtime );
game/shared/point_posecontroller.cpp:			float fCycleTime = m_fFModRate * ( gpGlobals->curtime + m_fFModTimeOffset );
game/shared/point_posecontroller.cpp:			float fCycleTime = fabsf( m_fFModRate * 2.0f * ( gpGlobals->curtime + m_fFModTimeOffset ) );
game/shared/point_posecontroller.cpp:			float fCycleTime = fabsf( m_fFModRate * 4.0f * ( gpGlobals->curtime + m_fFModTimeOffset ) );
game/shared/point_posecontroller.cpp:			float fCycleTime = fabsf( m_fFModRate * 2.0f * ( gpGlobals->curtime + m_fFModTimeOffset ) );
game/shared/point_posecontroller.cpp:				m_fCurrentFMod += m_fFModRate * gpGlobals->frametime;
game/shared/point_posecontroller.cpp:				m_fCurrentFMod -= m_fFModRate * gpGlobals->frametime;
game/shared/point_posecontroller.cpp:	m_fCurrentPoseValue += fCycleAmount * gpGlobals->frametime;
game/shared/point_posecontroller.cpp:	float fNewPoseValue = m_fCurrentPoseValue + m_PoseTransitionValue.Interp( gpGlobals->curtime );
game/shared/particle_parse.cpp:	pszMapName = STRING( gpGlobals->mapname );
game/shared/baseplayer_shared.cpp:    if ( gpGlobals->curtime < m_flNextAttack )
game/shared/baseplayer_shared.cpp:    if ( gpGlobals->curtime < m_flNextAttack )
game/shared/baseplayer_shared.cpp:	if ( m_nVehicleViewSavedFrame == gpGlobals->framecount )
game/shared/baseplayer_shared.cpp:		m_nVehicleViewSavedFrame = gpGlobals->framecount;
game/shared/baseplayer_shared.cpp:		m_flStepSoundTime -= 1000.0f * gpGlobals->frametime;
game/shared/baseplayer_shared.cpp:	if ( gpGlobals->maxClients > 1 && !sv_footsteps.GetFloat() )
game/shared/baseplayer_shared.cpp:	if ( gpGlobals->maxClients > 1 )
game/shared/baseplayer_shared.cpp:		float steptime = gpGlobals->frametime;
game/shared/baseplayer_shared.cpp:	m_flNextAttack	= gpGlobals->curtime;
game/shared/baseplayer_shared.cpp:	m_flFOVTime = gpGlobals->curtime;
game/shared/steamworks_gamestats.cpp:	if ( gpGlobals->realtime - m_LastServiceTick < 3 )
game/shared/steamworks_gamestats.cpp:	m_LastServiceTick = gpGlobals->realtime;
game/shared/shareddefs.h:#define TICK_INTERVAL			(gpGlobals->interval_per_tick)
game/shared/script_intro_shared.cpp:		float deltaTime = (float)( gpGlobals->curtime - flFOVBlendStartTime ) / ( flNextFOVBlendTime - flFOVBlendStartTime );
game/shared/script_intro_shared.cpp:		// Msg("FOV BLENDING: curtime %.2f    StartedAt %.2f    FinishAt: %.2f\n", gpGlobals->curtime, flFOVBlendStartTime, flNextFOVBlendTime );
game/shared/script_intro_shared.cpp:		float flResult = RemapValClamped( gpGlobals->curtime, flFOVBlendStartTime, flNextFOVBlendTime, (float) nFOV, (float) nNextFOV );
game/shared/script_intro_shared.cpp:		// Msg("FOV BLENDING: curtime %.2f    StartedAt %.2f    FinishAt: %.2f\n", gpGlobals->curtime, flFOVBlendStartTime, flNextFOVBlendTime );
game/shared/script_intro_shared.cpp:		// Msg("			   Perc:   %.2f    Start: %d	End: %d		FOV: %.2f\n", RemapValClamped( gpGlobals->curtime, flFOVBlendStartTime, flNextFOVBlendTime, 0.0, 1.0 ), nFOV, nNextFOV, flResult );
game/shared/SoundEmitterSystem.cpp:	m_flSoundTime = ( src.delay_msec == 0 ) ? 0.0f : gpGlobals->curtime + ( (float)src.delay_msec / 1000.0f );
game/shared/SoundEmitterSystem.cpp:		Q_snprintf(path, sizeof(path), "reslists\\%s.snd", gpGlobals->mapname.ToCStr() );
game/shared/SoundEmitterSystem.cpp:		Q_snprintf( mapname, sizeof( mapname ), "maps/%s", STRING( gpGlobals->mapname ) );
game/shared/SoundEmitterSystem.cpp:			st = gpGlobals->curtime + (float)params.delay_msec / 1000.f;
game/shared/SoundEmitterSystem.cpp:		if ( gpGlobals->maxClients > 1 || (gpGlobals->maxClients==1 && !g_pClosecaption->GetBool()))
game/shared/SoundEmitterSystem.cpp:		if ( gpGlobals->maxClients > 1 || (gpGlobals->maxClients==1 && !g_pClosecaption->GetBool()))
game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp:	if ( (pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime) )
game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp:	else if ( (pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime) )
game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + GetFireRate();
game/shared/hl2mp/weapon_hl2mpbasebasebludgeon.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_frag.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/shared/hl2mp/weapon_frag.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + RETHROW_DELAY;
game/shared/hl2mp/weapon_frag.cpp:	if ( ( m_bRedraw ) && ( m_flNextPrimaryAttack <= gpGlobals->curtime ) && ( m_flNextSecondaryAttack <= gpGlobals->curtime ) )
game/shared/hl2mp/weapon_frag.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_frag.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_frag.cpp:		m_flTimeWeaponIdle = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_357.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.75;
game/shared/hl2mp/weapon_357.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.75;
game/shared/hl2mp/weapon_smg1.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_smg1.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_smg1.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f;
game/shared/hl2mp/hl2mp_player_shared.cpp:	if ( gpGlobals->maxClients > 1 && !sv_footsteps.GetFloat() )
game/shared/hl2mp/hl2mp_player_shared.cpp:	if ( gpGlobals->maxClients > 1 )
game/shared/hl2mp/hl2mp_player_shared.cpp:	float dt = gpGlobals->frametime;
game/shared/hl2mp/hl2mp_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/hl2mp/hl2mp_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/hl2mp/hl2mp_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/hl2mp/hl2mp_player_shared.cpp:		turning = ConvergeAngles( m_flGoalFeetYaw, turnrate, gpGlobals->frametime, m_flCurrentFeetYaw );
game/shared/hl2mp/hl2mp_player_shared.cpp:			( gpGlobals->curtime > m_flLastTurnTime + mp_facefronttime.GetFloat() ) )
game/shared/hl2mp/hl2mp_player_shared.cpp:			m_flLastTurnTime	= gpGlobals->curtime;
game/shared/hl2mp/hl2mp_player_shared.cpp:			turning = ConvergeAngles( m_flGoalFeetYaw, turnrate, gpGlobals->frametime, m_flCurrentFeetYaw );
game/shared/hl2mp/weapon_stunstick.cpp:			m_flFadeTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_stunstick.cpp:		if ( gpGlobals->frametime != 0.0f && ( random->RandomInt( 0, 3 ) == 0 ) )
game/shared/hl2mp/weapon_stunstick.cpp:		if ( gpGlobals->frametime != 0.0f && ( random->RandomInt( 0, 5 ) == 0 ) )
game/shared/hl2mp/weapon_stunstick.cpp:	float fadeAmount = RemapValClamped( gpGlobals->curtime, m_flFadeTime, m_flFadeTime + FADE_DURATION, 1.0f, 0.1f );
game/shared/hl2mp/weapon_physcannon.cpp:	m_timeToArrive = gpGlobals->frametime;
game/shared/hl2mp/weapon_physcannon.cpp:			m_pBeam->die = gpGlobals->curtime - 1;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime;
game/shared/hl2mp/weapon_physcannon.cpp:		pOwner->SetNextAttack( gpGlobals->curtime );
game/shared/hl2mp/weapon_physcannon.cpp:	if ( m_hLastPuntedObject == pEntity && gpGlobals->curtime < m_flRepuntObjectTime )
game/shared/hl2mp/weapon_physcannon.cpp:	m_flRepuntObjectTime = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/shared/hl2mp/weapon_physcannon.cpp:	if ( m_hLastPuntedObject == pEntity && gpGlobals->curtime < m_flRepuntObjectTime )
game/shared/hl2mp/weapon_physcannon.cpp:	m_flRepuntObjectTime = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:	if( m_flNextPrimaryAttack > gpGlobals->curtime )
game/shared/hl2mp/weapon_physcannon.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:	if ( m_flNextSecondaryAttack > gpGlobals->curtime )
game/shared/hl2mp/weapon_physcannon.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl2mp/weapon_physcannon.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl2mp/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.1f;
game/shared/hl2mp/weapon_physcannon.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.01f;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.4f;
game/shared/hl2mp/weapon_physcannon.cpp:	if ( m_frameCount == gpGlobals->framecount )
game/shared/hl2mp/weapon_physcannon.cpp:	m_frameCount = gpGlobals->framecount;
game/shared/hl2mp/weapon_physcannon.cpp:	float flElementPosition = m_ElementParameter.Interp( gpGlobals->curtime );
game/shared/hl2mp/weapon_physcannon.cpp:	if ( m_flCheckSuppressTime > gpGlobals->curtime )
game/shared/hl2mp/weapon_physcannon.cpp:	if ( ( m_flElementDebounce < gpGlobals->curtime ) && ( m_nChangeState == ELEMENT_STATE_NONE ) )
game/shared/hl2mp/weapon_physcannon.cpp:		m_flElementDebounce = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:		if ( ( m_flElementDebounce < gpGlobals->curtime ) && ( m_nChangeState != ELEMENT_STATE_NONE ) )
game/shared/hl2mp/weapon_physcannon.cpp:	if ( !(m_hLastPuntedObject == pObject && gpGlobals->curtime < m_flRepuntObjectTime) )
game/shared/hl2mp/weapon_physcannon.cpp:			m_flRepuntObjectTime = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_physcannon.cpp:			m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flElementDebounce = gpGlobals->curtime + 0.1f;
game/shared/hl2mp/weapon_physcannon.cpp:	m_flCheckSuppressTime = gpGlobals->curtime + 0.25f;
game/shared/hl2mp/weapon_physcannon.cpp:	const float dt = gpGlobals->curtime;
game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp:	while ( m_flNextPrimaryAttack <= gpGlobals->curtime )
game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp:	if (m_flNextSoundTime < gpGlobals->curtime)
game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp:		m_flNextSoundTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp:	if (m_flNextSoundTime < gpGlobals->curtime + dt)
game/shared/hl2mp/weapon_hl2mpbase_machinegun.cpp:	if (m_flNextSoundTime < gpGlobals->curtime + dt)
game/shared/hl2mp/weapon_shotgun.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/shared/hl2mp/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/shared/hl2mp/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:	pOwner->m_flNextAttack = gpGlobals->curtime;
game/shared/hl2mp/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:	pOwner->m_flNextAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_shotgun.cpp:		else if (m_flNextPrimaryAttack <= gpGlobals->curtime)
game/shared/hl2mp/weapon_shotgun.cpp:	if ((m_bNeedPump) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/shared/hl2mp/weapon_shotgun.cpp:	if ((m_bDelayedFire2 || pOwner->m_nButtons & IN_ATTACK2)&&(m_flNextPrimaryAttack <= gpGlobals->curtime))
game/shared/hl2mp/weapon_shotgun.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/hl2mp/weapon_shotgun.cpp:				 m_flNextPrimaryAttack = gpGlobals->curtime;
game/shared/hl2mp/weapon_shotgun.cpp:	else if ( (m_bDelayedFire1 || pOwner->m_nButtons & IN_ATTACK) && m_flNextPrimaryAttack <= gpGlobals->curtime)
game/shared/hl2mp/weapon_shotgun.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/hl2mp/weapon_shotgun.cpp:				 m_flNextPrimaryAttack = gpGlobals->curtime;
game/shared/hl2mp/weapon_shotgun.cpp:		if ( !HasAnyAmmo() && m_flNextPrimaryAttack < gpGlobals->curtime ) 
game/shared/hl2mp/weapon_shotgun.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 0.3;
game/shared/hl2mp/weapon_shotgun.cpp:			if ( m_iClip1 <= 0 && !(GetWeaponFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < gpGlobals->curtime )
game/shared/hl2mp/weapon_shotgun.cpp:	if ( ( gpGlobals->curtime - m_flHolsterTime ) > sk_auto_reload_time.GetFloat() )
game/shared/hl2mp/weapon_shotgun.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.3f );
game/shared/hl2mp/weapon_rpg.cpp:	m_flGracePeriodEndsAt = gpGlobals->curtime + flGracePeriod;
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl2mp/weapon_rpg.cpp:	if ( m_flAugerTime < gpGlobals->curtime )
game/shared/hl2mp/weapon_rpg.cpp:	if ( m_flMarkDeadTime < gpGlobals->curtime )
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.05f );
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/hl2mp/weapon_rpg.cpp:	m_flAugerTime = gpGlobals->curtime + 1.5f;
game/shared/hl2mp/weapon_rpg.cpp:	m_flMarkDeadTime = gpGlobals->curtime + 0.75;
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/hl2mp/weapon_rpg.cpp:		if ( m_flGracePeriodEndsAt < gpGlobals->curtime )
game/shared/hl2mp/weapon_rpg.cpp:		SetNextThink( gpGlobals->curtime );
game/shared/hl2mp/weapon_rpg.cpp:	if ( gpGlobals->frametime > 0.0f )
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/hl2mp/weapon_rpg.cpp:	m_flIgnitionTime = gpGlobals->curtime + 0.3f;
game/shared/hl2mp/weapon_rpg.cpp:	m_flIgnitionTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + flDelay );
game/shared/hl2mp/weapon_rpg.cpp:	m_flAugerTime = gpGlobals->curtime + random->RandomFloat( 1.0f, 2.0f );
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/hl2mp/weapon_rpg.cpp:	m_flIgnitionTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + flDelay );
game/shared/hl2mp/weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/hl2mp/weapon_rpg.cpp:	float flBlendTime = gpGlobals->curtime - m_flIgnitionTime;
game/shared/hl2mp/weapon_rpg.cpp:			float flDeltaTime = clamp( gpGlobals->curtime - m_flReachedTargetTime, 0.0f, CORRECTION_TIME );
game/shared/hl2mp/weapon_rpg.cpp:				m_flReachedTargetTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_rpg.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_rpg.cpp:		m_pBeam->die = gpGlobals->curtime - 0.1;
game/shared/hl2mp/weapon_slam.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp://	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration() );
game/shared/hl2mp/weapon_slam.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:	SetWeaponIdleTime( gpGlobals->curtime );
game/shared/hl2mp/weapon_slam.cpp:	if ( m_flWallSwitchTime > gpGlobals->curtime )
game/shared/hl2mp/weapon_slam.cpp:				m_flWallSwitchTime = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:				m_flWallSwitchTime = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_slam.cpp:	if ((pOwner->m_nButtons & IN_ATTACK2) && (m_flNextSecondaryAttack <= gpGlobals->curtime))
game/shared/hl2mp/weapon_slam.cpp:	else if (!m_bNeedReload && (pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime))
game/shared/hl2mp/hl2mp_gamerules.cpp:	return m_flIntermissionEndTime > gpGlobals->curtime;
game/shared/hl2mp/hl2mp_gamerules.cpp:		if ( m_flIntermissionEndTime < gpGlobals->curtime )
game/shared/hl2mp/hl2mp_gamerules.cpp:			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/hl2mp/hl2mp_gamerules.cpp:	if ( gpGlobals->curtime > m_tmNextPeriodicThink )
game/shared/hl2mp/hl2mp_gamerules.cpp:		m_tmNextPeriodicThink = gpGlobals->curtime + 1.0;
game/shared/hl2mp/hl2mp_gamerules.cpp:	if ( m_flRestartGameTime > 0.0f && m_flRestartGameTime <= gpGlobals->curtime )
game/shared/hl2mp/hl2mp_gamerules.cpp:		m_flRestartGameTime = gpGlobals->curtime + 5;
game/shared/hl2mp/hl2mp_gamerules.cpp:	m_flIntermissionEndTime = gpGlobals->curtime + mp_chattime.GetInt();
game/shared/hl2mp/hl2mp_gamerules.cpp:		if ( m_flIntermissionEndTime < gpGlobals->curtime )
game/shared/hl2mp/hl2mp_gamerules.cpp:		if ( gEntList.NumberOfEntities() < (gpGlobals->maxEntities - ENTITY_INTOLERANCE) )
game/shared/hl2mp/hl2mp_gamerules.cpp:		if ( pItem->m_flNextResetCheckTime > gpGlobals->curtime )
game/shared/hl2mp/hl2mp_gamerules.cpp:		pItem->m_flNextResetCheckTime = gpGlobals->curtime + sv_hl2mp_item_respawn_time.GetFloat();
game/shared/hl2mp/hl2mp_gamerules.cpp:		if ( pWeapon->m_flNextResetCheckTime > gpGlobals->curtime )
game/shared/hl2mp/hl2mp_gamerules.cpp:		pWeapon->m_flNextResetCheckTime = gpGlobals->curtime + sv_hl2mp_weapon_respawn_time.GetFloat();
game/shared/hl2mp/hl2mp_gamerules.cpp:		if ( pHL2Player->GetNextModelChangeTime() >= gpGlobals->curtime )
game/shared/hl2mp/hl2mp_gamerules.cpp:			Q_snprintf( szReturnString, sizeof( szReturnString ), "Please wait %d more seconds before trying to switch.\n", (int)(pHL2Player->GetNextModelChangeTime() - gpGlobals->curtime) );
game/shared/hl2mp/hl2mp_gamerules.cpp:	float timeleft = (m_flGameStartTime + mp_timelimit.GetInt() * 60.0f ) - gpGlobals->curtime;
game/shared/hl2mp/hl2mp_gamerules.cpp:	m_flGameStartTime = gpGlobals->curtime;
game/shared/hl2mp/hl2mp_gamerules.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/hl2mp/hl2mp_gamerules.cpp:		m_flRestartGameTime = gpGlobals->curtime + iRestartDelay;
game/shared/hl2mp/hl2mp_gamerules.cpp:	for (int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:	if ( ( gpGlobals->curtime - m_flHolsterTime ) > sk_auto_reload_time.GetFloat() )
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:	m_flRaiseTime = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:					pPlayer->SetNextAttack( gpGlobals->curtime + 1.0 );
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:					m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:					m_flNextSecondaryAttack	= gpGlobals->curtime + 1.0;
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:		m_flHolsterTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:		if ( m_flRaiseTime < gpGlobals->curtime && GetActivity() == ACT_VM_IDLE_LOWERED ) 
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:	if ( ( !gpGlobals->frametime ) || ( player == NULL ) )
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:	bobtime += ( gpGlobals->curtime - lastbobtime ) * bob_offset;
game/shared/hl2mp/weapon_hl2mpbasehlmpcombatweapon.cpp:	lastbobtime = gpGlobals->curtime;
game/shared/hl2mp/weapon_crossbow.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl2mp/weapon_crossbow.cpp:				SetNextThink( gpGlobals->curtime + 2.0f );
game/shared/hl2mp/weapon_crossbow.cpp:				SetNextThink( gpGlobals->curtime + 2.0f );
game/shared/hl2mp/weapon_crossbow.cpp://		SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl2mp/weapon_crossbow.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl2mp/weapon_crossbow.cpp:	SetWeaponIdleTime( gpGlobals->curtime + SequenceDuration( ACT_VM_PRIMARYATTACK ) );
game/shared/hl2mp/weapon_crossbow.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack	= gpGlobals->curtime + 0.75;
game/shared/hl2mp/weapon_ar2.cpp:	if ( m_bShotDelayed && gpGlobals->curtime > m_flDelayedFire )
game/shared/hl2mp/weapon_ar2.cpp:	m_flNextSecondaryAttack = pOwner->m_flNextAttack = gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_ar2.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_ar2.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0f;
game/shared/hl2mp/weapon_ar2.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_ar2.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = m_flDelayedFire = gpGlobals->curtime + 0.5f;
game/shared/hl2mp/weapon_pistol.cpp:	m_flSoonestPrimaryAttack = gpGlobals->curtime;
game/shared/hl2mp/weapon_pistol.cpp:	m_flSoonestPrimaryAttack	= gpGlobals->curtime + PISTOL_FASTEST_DRY_REFIRE_TIME;
game/shared/hl2mp/weapon_pistol.cpp:	m_flNextPrimaryAttack		= gpGlobals->curtime + SequenceDuration();
game/shared/hl2mp/weapon_pistol.cpp:	if ( ( gpGlobals->curtime - m_flLastAttackTime ) > 0.5f )
game/shared/hl2mp/weapon_pistol.cpp:	m_flLastAttackTime = gpGlobals->curtime;
game/shared/hl2mp/weapon_pistol.cpp:	m_flSoonestPrimaryAttack = gpGlobals->curtime + PISTOL_FASTEST_REFIRE_TIME;
game/shared/hl2mp/weapon_pistol.cpp:	if ( ( ( pOwner->m_nButtons & IN_ATTACK ) == false ) && ( m_flSoonestPrimaryAttack < gpGlobals->curtime ) )
game/shared/hl2mp/weapon_pistol.cpp:		m_flAccuracyPenalty -= gpGlobals->frametime;
game/shared/hl2mp/weapon_pistol.cpp:		m_flLastAttackTime = gpGlobals->curtime + PISTOL_FASTEST_REFIRE_TIME;
game/shared/hl2mp/weapon_pistol.cpp:		m_flSoonestPrimaryAttack = gpGlobals->curtime + PISTOL_FASTEST_REFIRE_TIME;
game/shared/hl2mp/weapon_pistol.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + PISTOL_FASTEST_REFIRE_TIME;
game/shared/hl2mp/weapon_pistol.cpp:	if ( ( ( pOwner->m_nButtons & IN_ATTACK ) == false ) && ( m_flSoonestPrimaryAttack < gpGlobals->curtime ) )
game/shared/hl2mp/weapon_pistol.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime - 0.1f;
game/shared/hl2mp/weapon_pistol.cpp:	else if ( ( pOwner->m_nButtons & IN_ATTACK ) && ( m_flNextPrimaryAttack < gpGlobals->curtime ) && ( m_iClip1 <= 0 ) )
game/shared/hl2mp/weapon_hl2mpbase.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl1/hl1mp_weapon_egon.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_egon.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 0.25;
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flNextSecondaryAttack = gpGlobals->curtime + 0.25;
game/shared/hl1/hl1mp_weapon_egon.cpp:			m_flAmmoUseTime = gpGlobals->curtime;// start using ammo ASAP.
game/shared/hl1/hl1mp_weapon_egon.cpp:			m_flStartFireTime = gpGlobals->curtime;
game/shared/hl1/hl1mp_weapon_egon.cpp:			SetWeaponIdleTime( gpGlobals->curtime + 0.1 );
game/shared/hl1/hl1mp_weapon_egon.cpp:			m_flDmgTime = gpGlobals->curtime + EGON_PULSE_INTERVAL;
game/shared/hl1/hl1mp_weapon_egon.cpp:			if ( gpGlobals->curtime >= ( m_flStartFireTime + 2.0 ) )
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flNextSecondaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flNextSecondaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_egon.cpp:	if ( m_flDmgTime < gpGlobals->curtime )
game/shared/hl1/hl1mp_weapon_egon.cpp:			if ( gpGlobals->curtime >= m_flAmmoUseTime )
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flAmmoUseTime = gpGlobals->curtime + 0.2;
game/shared/hl1/hl1mp_weapon_egon.cpp:			if ( gpGlobals->curtime >= m_flAmmoUseTime )
game/shared/hl1/hl1mp_weapon_egon.cpp:				m_flAmmoUseTime = gpGlobals->curtime + 0.1;
game/shared/hl1/hl1mp_weapon_egon.cpp:		m_flDmgTime = gpGlobals->curtime + EGON_DISCHARGE_INTERVAL;
game/shared/hl1/hl1mp_weapon_egon.cpp:		if ( m_flShakeTime < gpGlobals->curtime )
game/shared/hl1/hl1mp_weapon_egon.cpp:			m_flShakeTime = gpGlobals->curtime + 1.5;
game/shared/hl1/hl1mp_weapon_egon.cpp:		m_hSprite->m_flFrame += 8 * gpGlobals->frametime;
game/shared/hl1/hl1mp_weapon_egon.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 2.0 );
game/shared/hl1/hl1mp_weapon_egon.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_egon.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_egon.cpp:		flIdleTime = gpGlobals->curtime + random->RandomFloat( 10, 15 );
game/shared/hl1/hl1mp_weapon_egon.cpp:		flIdleTime = gpGlobals->curtime + 3.0;
game/shared/hl1/hl1mp_weapon_glock.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/hl1/hl1mp_weapon_glock.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + flCycleTime;
game/shared/hl1/hl1mp_weapon_glock.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + flCycleTime;
game/shared/hl1/hl1mp_weapon_glock.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_glock.cpp:	SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		m_flPumpTime = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + 0.2;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + 1.5;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + 1.5;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 1.0 );
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		m_flPumpTime = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	if ( m_flNextPrimaryAttack > gpGlobals->curtime )
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		pOwner->m_flNextAttack	= gpGlobals->curtime + 0.6;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.6 );
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_shotgun.cpp:	if ( m_flPumpTime && m_flPumpTime < gpGlobals->curtime )
game/shared/hl1/hl1mp_weapon_shotgun.cpp:				SetWeaponIdleTime( gpGlobals->curtime + 1.5 );
game/shared/hl1/hl1_basecombatweapon_shared.cpp:	if ( ( !gpGlobals->frametime ) || ( player == NULL ) )
game/shared/hl1/hl1_basecombatweapon_shared.cpp:	bobtime += ( gpGlobals->curtime - lastbobtime ) * bob_offset;
game/shared/hl1/hl1_basecombatweapon_shared.cpp:	lastbobtime = gpGlobals->curtime;
game/shared/hl1/hl1_basecombatweapon_shared.cpp:	if ( gpGlobals->maxClients == 1 || !GetOwner() )
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:	m_flDetonateTime = gpGlobals->curtime + flTime;
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		SetNextThink( gpGlobals->curtime );
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:	if ( (pOther->m_takedamage != DAMAGE_NO) && (m_flNextAttack < gpGlobals->curtime && GetAbsVelocity().Length() > 100))
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		m_flNextAttack = gpGlobals->curtime + 1.0; // debounce
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		m_flStartThrow		= gpGlobals->curtime;
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		 m_flReleaseThrow = gpGlobals->curtime;
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:			float flTime = m_flStartThrow - gpGlobals->curtime + 3.0;
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		m_flNextPrimaryAttack	= gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		m_flNextSecondaryAttack	= gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:			SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );// how long till we do this again.
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:		SetNextThink( gpGlobals->curtime + 0.1 );
game/shared/hl1/hl1mp_weapon_handgrenade.cpp:	pPlayer->SetNextAttack( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_sachel.cpp:	if ( (pOwner->m_nButtons & IN_ATTACK) && (m_flNextPrimaryAttack <= gpGlobals->curtime) )
game/shared/hl1/hl1mp_weapon_sachel.cpp:			 m_flNextPrimaryAttack = gpGlobals->curtime;
game/shared/hl1/hl1mp_weapon_sachel.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_sachel.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_sachel.cpp:			SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_sachel.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_sachel.cpp:		m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_sachel.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_sachel.cpp:			m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_sachel.cpp:	SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );// how long till we do this again.
game/shared/hl1/hl1mp_weapon_sachel.cpp:	SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/shared/hl1/hl1mp_weapon_sachel.cpp:			pPlayer->SetNextAttack( gpGlobals->curtime + 1.0 );
game/shared/hl1/hl1mp_weapon_sachel.cpp:		pPlayer->SetNextAttack( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_sachel.cpp:			SetNextThink( gpGlobals->curtime + 0.1 );
game/shared/hl1/hl1mp_weapon_sachel.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl1/hl1mp_weapon_sachel.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/hl1/hl1mp_weapon_sachel.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl1/hl1mp_weapon_sachel.cpp:	if ( gpGlobals->curtime > m_flNextBounceSoundTime )
game/shared/hl1/hl1mp_weapon_sachel.cpp:		m_flNextBounceSoundTime = gpGlobals->curtime + 0.1;
game/shared/hl1/hl1mp_weapon_mp5.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + 0.1;
game/shared/hl1/hl1mp_weapon_mp5.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_mp5.cpp:	SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/shared/hl1/hl1mp_weapon_mp5.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_mp5.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_mp5.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_mp5.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 5.0 );
game/shared/hl1/hl1mp_weapon_mp5.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + 0.15;
game/shared/hl1/hl1mp_weapon_mp5.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + 0.15;
game/shared/hl1/hl1mp_weapon_mp5.cpp:		SetWeaponIdleTime( gpGlobals->curtime + random->RandomInt( 3, 5 ) );
game/shared/hl1/hl1mp_weapon_crossbow.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/shared/hl1/hl1mp_weapon_crossbow.cpp:		SetNextThink( gpGlobals->curtime );// this will get changed below if the bolt is allowed to stick in what it hit.
game/shared/hl1/hl1mp_weapon_crossbow.cpp:        SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl1/hl1mp_weapon_crossbow.cpp:    SetNextThink( gpGlobals->curtime );
game/shared/hl1/hl1mp_weapon_crossbow.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl1/hl1mp_weapon_crossbow.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 1.0;
game/shared/hl1/hl1mp_weapon_crossbow.cpp:	m_flNextPrimaryAttack	= gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_crossbow.cpp:	m_flNextSecondaryAttack	= gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_crossbow.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 5.0 );
game/shared/hl1/hl1mp_weapon_crossbow.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.75 );
game/shared/hl1/hl1_player_shared.cpp:		*flCycle = (gpGlobals->curtime - m_flFireStartTime) / dur;
game/shared/hl1/hl1_player_shared.cpp:		m_flJumpStartTime = gpGlobals->curtime;
game/shared/hl1/hl1_player_shared.cpp:		m_flFireStartTime = gpGlobals->curtime;
game/shared/hl1/hl1_player_shared.cpp:		if ( gpGlobals->curtime - m_flJumpStartTime > 0.2f )
game/shared/hl1/hl1mp_weapon_gauss.cpp:		pPlayer->SetNextAttack( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:	SetWeaponIdleTime( gpGlobals->curtime + 1.0 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:	pPlayer->SetNextAttack( gpGlobals->curtime + 0.2 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:		m_flNextSecondaryAttack = m_flNextPrimaryAttack = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_gauss.cpp:			pPlayer->SetNextAttack( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:		pPlayer->m_flNextAmmoBurn = gpGlobals->curtime;
game/shared/hl1/hl1mp_weapon_gauss.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:		pPlayer->m_flStartCharge = gpGlobals->curtime;
game/shared/hl1/hl1mp_weapon_gauss.cpp:		pPlayer->m_flAmmoStartCharge = gpGlobals->curtime + GetFullChargeTime();
game/shared/hl1/hl1mp_weapon_gauss.cpp:		if ( gpGlobals->curtime >= pPlayer->m_flNextAmmoBurn && pPlayer->m_flNextAmmoBurn != 1000 )
game/shared/hl1/hl1mp_weapon_gauss.cpp:				pPlayer->m_flNextAmmoBurn = gpGlobals->curtime + 0.1;
game/shared/hl1/hl1mp_weapon_gauss.cpp:				pPlayer->m_flNextAmmoBurn = gpGlobals->curtime + 0.3;
game/shared/hl1/hl1mp_weapon_gauss.cpp:			SetWeaponIdleTime( gpGlobals->curtime + 1.0 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:			pPlayer->SetNextAttack( gpGlobals->curtime + 1 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:		if ( gpGlobals->curtime >= pPlayer->m_flAmmoStartCharge )
game/shared/hl1/hl1mp_weapon_gauss.cpp:		int pitch = ( gpGlobals->curtime - pPlayer->m_flStartCharge ) * ( 150 / GetFullChargeTime() ) + 100;
game/shared/hl1/hl1mp_weapon_gauss.cpp:		// m_flTimeWeaponIdle = gpGlobals->curtime + 0.1;
game/shared/hl1/hl1mp_weapon_gauss.cpp:		if ( pPlayer->m_flStartCharge < gpGlobals->curtime - 10 )
game/shared/hl1/hl1mp_weapon_gauss.cpp:			SetWeaponIdleTime( gpGlobals->curtime + 1.0 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:			pPlayer->SetNextAttack( gpGlobals->curtime + 1.0 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:	if ( gpGlobals->curtime - pPlayer->m_flStartCharge > GetFullChargeTime() )
game/shared/hl1/hl1mp_weapon_gauss.cpp:		flDamage = 200 * (( gpGlobals->curtime - pPlayer->m_flStartCharge) / GetFullChargeTime() );
game/shared/hl1/hl1mp_weapon_gauss.cpp:	//ALERT ( at_console, "Time:%f Damage:%f\n", gpGlobals->curtime - m_pPlayer->m_flStartCharge, flDamage );
game/shared/hl1/hl1mp_weapon_gauss.cpp:	pPlayer->m_flPlayAftershock = gpGlobals->curtime + random->RandomFloat( 0.3, 0.8 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:	if ( pPlayer->m_flPlayAftershock && pPlayer->m_flPlayAftershock < gpGlobals->curtime )
game/shared/hl1/hl1mp_weapon_gauss.cpp:		SetWeaponIdleTime( gpGlobals->curtime + 2.0 );
game/shared/hl1/hl1mp_weapon_gauss.cpp:			SetWeaponIdleTime( gpGlobals->curtime + random->RandomFloat( 10, 15 ) );
game/shared/hl1/hl1mp_weapon_gauss.cpp:			SetWeaponIdleTime( gpGlobals->curtime + 3 );
game/shared/hl1/hl1mp_weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.4f );
game/shared/hl1/hl1mp_weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl1/hl1mp_weapon_rpg.cpp:	m_flIgniteTime = gpGlobals->curtime;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	if ( gpGlobals->curtime - m_flIgniteTime < 1.0 )
game/shared/hl1/hl1mp_weapon_rpg.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/hl1/hl1mp_weapon_rpg.cpp:			m_flNextPrimaryAttack = gpGlobals->curtime + 0.2;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	pOwner->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_rpg.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 1.5;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	m_flLaserDotReviveTime = gpGlobals->curtime + 2.1;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 2.1;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 2.1;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	m_flLaserDotReviveTime = gpGlobals->curtime + 2.1;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 2.1;
game/shared/hl1/hl1mp_weapon_rpg.cpp:	if ( IsGuiding() && m_bLaserDotSuspended && ( m_flLaserDotReviveTime <= gpGlobals->curtime ) )
game/shared/hl1/hl1mp_weapon_hornetgun.cpp:	m_flRechargeTime = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_hornetgun.cpp:	if (m_flNextPrimaryAttack < gpGlobals->curtime )
game/shared/hl1/hl1mp_weapon_hornetgun.cpp:		m_flNextPrimaryAttack = gpGlobals->curtime + 0.25;
game/shared/hl1/hl1mp_weapon_hornetgun.cpp:	m_flRechargeTime = gpGlobals->curtime + 0.5;
game/shared/hl1/hl1mp_weapon_hornetgun.cpp:	m_flNextPrimaryAttack = m_flNextSecondaryAttack = gpGlobals->curtime + 0.1;
game/shared/hl1/hl1mp_weapon_hornetgun.cpp:	if ( m_flRechargeTime >= gpGlobals->curtime )
game/shared/hl1/hl1mp_weapon_hornetgun.cpp:	while ( ( m_flRechargeTime < gpGlobals->curtime ) && g_pGameRules->CanHaveAmmo( pPlayer, m_iPrimaryAmmoType ) )
game/shared/hl1/hl1mp_gamerules.cpp:		if ( m_flIntermissionEndTime < gpGlobals->curtime )
game/shared/hl1/hl1mp_gamerules.cpp:	if ( flTimeLimit != 0 && gpGlobals->curtime >= flTimeLimit )
game/shared/hl1/hl1mp_gamerules.cpp:			for ( int i = 1; i <= gpGlobals->maxClients; i++ )
game/shared/hl1/hl1mp_gamerules.cpp:	m_flIntermissionEndTime = gpGlobals->curtime + mp_chattime.GetInt();
game/shared/hl1/hl1mp_gamerules.cpp:		if ( pHL1Player->GetNextModelChangeTime() >= gpGlobals->curtime )
game/shared/hl1/hl1mp_gamerules.cpp:			Q_snprintf( szReturnString, sizeof( szReturnString ), "Please wait %d more seconds before trying to switch.\n", (int)(pHL1Player->GetNextModelChangeTime() - gpGlobals->curtime) );
game/shared/hl1/hl1_gamemovement.cpp:		m_pHL1Player->m_flWaterJumpTime -= gpGlobals->frametime;
game/shared/hl1/hl1_gamemovement.cpp:	if ( gpGlobals->maxClients > 1 )
game/shared/hl1/hl1mp_weapon_357.cpp:	m_flNextPrimaryAttack = gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_357.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.75;
game/shared/hl1/hl1mp_weapon_357.cpp:	pPlayer->SetMuzzleFlashTime( gpGlobals->curtime + 0.5 );
game/shared/hl1/hl1mp_weapon_357.cpp:	m_flNextSecondaryAttack = gpGlobals->curtime + 0.5;
game/shared/basegrenade_shared.cpp:	SetNextThink( gpGlobals->curtime + 0.1 );
game/shared/basegrenade_shared.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/basegrenade_shared.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/basegrenade_shared.cpp:	SetNextThink( gpGlobals->curtime );
game/shared/basegrenade_shared.cpp:	SetNextThink( gpGlobals->curtime + 1.5 );
game/shared/basegrenade_shared.cpp:	SetNextThink( gpGlobals->curtime + 0.2 );
game/shared/basegrenade_shared.cpp:	if ( (pOther->m_takedamage != DAMAGE_NO) && (m_flNextAttack < gpGlobals->curtime && GetAbsVelocity().Length() > 100))
game/shared/basegrenade_shared.cpp:		m_flNextAttack = gpGlobals->curtime + 1.0; // debounce
game/shared/basegrenade_shared.cpp:	SetNextThink( gpGlobals->curtime + 0.1f );
game/shared/basegrenade_shared.cpp:	if (m_flDetonateTime - 1 < gpGlobals->curtime)
game/shared/basegrenade_shared.cpp:		CSoundEnt::InsertSound ( SOUND_DANGER, GetAbsOrigin() + GetAbsVelocity() * (m_flDetonateTime - gpGlobals->curtime), 400, 0.1, this );
game/shared/basegrenade_shared.cpp:	if (m_flDetonateTime <= gpGlobals->curtime)
game/shared/base_playeranimstate.cpp:	m_flLastAnimationStateClearTime = gpGlobals->curtime;
game/shared/base_playeranimstate.cpp:	return gpGlobals->curtime - m_flLastAnimationStateClearTime;
game/shared/base_playeranimstate.cpp:	pPlayer->m_flAnimTime = gpGlobals->curtime;
game/shared/base_playeranimstate.cpp:		gpGlobals->curtime
game/shared/base_playeranimstate.cpp:			pLayer->m_flCycle += m_pOuter->GetSequenceCycleRate( pStudioHdr, pLayer->m_nSequence ) * gpGlobals->frametime;
game/shared/base_playeranimstate.cpp:	else if ( (gpGlobals->curtime - m_flLastTurnTime) > mp_facefronttime.GetFloat() )
game/shared/base_playeranimstate.cpp:			 gpGlobals->frametime, m_flCurrentFeetYaw );
game/shared/base_playeranimstate.cpp:		m_flLastTurnTime = gpGlobals->curtime;
game/shared/base_playeranimstate.cpp:		vOuterVel.Length2D(), gpGlobals->curtime, GetInterpolatedGroundSpeed(), m_pOuter->GetSequenceGroundSpeed(m_pOuter->GetSequence()) );
game/shared/base_playeranimstate.cpp:	AnimStateLog( "----------------- frame %d -----------------\n", gpGlobals->framecount );
game/shared/gamemovement.cpp:// tickcount currently isn't set during prediction, although gpGlobals->curtime and
game/shared/gamemovement.cpp:// gpGlobals->frametime are. We should probably set tickcount (to player->m_nTickBase),
game/shared/gamemovement.cpp:			if ( gpGlobals->maxClients == 1 )
game/shared/gamemovement.cpp:	return ((pev->flags & FL_INRAIN) != 0) || (m_WetTime >= gpGlobals->time);
game/shared/gamemovement.cpp:			float wetness = (m_WetTime - gpGlobals->time) / DRY_TIME;
game/shared/gamemovement.cpp:			m_WetTime = gpGlobals->time + (1.0 - wetness) * WET_TIME; 
game/shared/gamemovement.cpp:			float wetness = 1.0f + (gpGlobals->time - m_WetTime) / WET_TIME;
game/shared/gamemovement.cpp:			m_WetTime = gpGlobals->time + wetness * DRY_TIME; 
game/shared/gamemovement.cpp:	float frame_msec = 1000.0f * gpGlobals->frametime;
game/shared/gamemovement.cpp:	float flStoreFrametime = gpGlobals->frametime;
game/shared/gamemovement.cpp:	gpGlobals->frametime *= pPlayer->GetLaggedMovementValue();
game/shared/gamemovement.cpp:	gpGlobals->frametime = flStoreFrametime;
game/shared/gamemovement.cpp:		player->m_Local.m_vecPunchAngle += player->m_Local.m_vecPunchAngleVel * gpGlobals->frametime;
game/shared/gamemovement.cpp:		float damping = 1 - (PUNCH_DAMPING * gpGlobals->frametime);
game/shared/gamemovement.cpp:		float springForceMagnitude = PUNCH_SPRING_CONSTANT * gpGlobals->frametime;
game/shared/gamemovement.cpp:	mv->m_vecVelocity[2] -= (ent_gravity * GetCurrentGravity() * 0.5 * gpGlobals->frametime );
game/shared/gamemovement.cpp:	mv->m_vecVelocity[2] += player->GetBaseVelocity()[2] * gpGlobals->frametime;
game/shared/gamemovement.cpp:	player->m_flWaterJumpTime -= 1000.0f * gpGlobals->frametime;
game/shared/gamemovement.cpp:		newspeed = speed - gpGlobals->frametime * speed * sv_friction.GetFloat() * player->m_surfaceFriction;
game/shared/gamemovement.cpp:			accelspeed = sv_accelerate.GetFloat() * wishspeed * gpGlobals->frametime * player->m_surfaceFriction;
game/shared/gamemovement.cpp:	VectorMA (mv->GetAbsOrigin(), gpGlobals->frametime, mv->m_vecVelocity, dest);
game/shared/gamemovement.cpp:		drop += control*friction*gpGlobals->frametime;
game/shared/gamemovement.cpp:  	mv->m_vecVelocity[2] -= (ent_gravity * GetCurrentGravity() * gpGlobals->frametime * 0.5);
game/shared/gamemovement.cpp:	accelspeed = accel * wishspeed * gpGlobals->frametime * player->m_surfaceFriction;
game/shared/gamemovement.cpp:	accelspeed = accel * gpGlobals->frametime * wishspeed * player->m_surfaceFriction;
game/shared/gamemovement.cpp:		float xoffset = sin(gpGlobals->curtime * cl_viewbob_timer.GetFloat()) * player->GetAbsVelocity().Length() * cl_viewbob_scale.GetFloat() / 100;
game/shared/gamemovement.cpp:		float yoffset = sin(2 * gpGlobals->curtime * cl_viewbob_timer.GetFloat()) * player->GetAbsVelocity().Length() * cl_viewbob_scale.GetFloat() / 400;
game/shared/gamemovement.cpp:	dest[0] = mv->GetAbsOrigin()[0] + mv->m_vecVelocity[0]*gpGlobals->frametime;
game/shared/gamemovement.cpp:	dest[1] = mv->GetAbsOrigin()[1] + mv->m_vecVelocity[1]*gpGlobals->frametime;	
game/shared/gamemovement.cpp:	float drop = spd * friction * gpGlobals->frametime;
game/shared/gamemovement.cpp:		float drop = control * friction * gpGlobals->frametime;
game/shared/gamemovement.cpp:	VectorMA( mv->GetAbsOrigin(), gpGlobals->frametime, mv->m_vecVelocity, out );
game/shared/gamemovement.cpp:		player->m_flWaterJumpTime -= gpGlobals->frametime;
game/shared/gamemovement.cpp:	if ( gpGlobals->maxClients == 1 )
game/shared/gamemovement.cpp:	if ( gpGlobals->maxClients == 1 )
game/shared/gamemovement.cpp:	time_left = gpGlobals->frametime;   // Total time for this movement operation.
game/shared/gamemovement.cpp:			//Vector velocity = (forward * gpGlobals->v_forward) + (right * gpGlobals->v_right);
game/shared/gamemovement.cpp:	mv->m_vecVelocity[2] -= (ent_gravity * GetCurrentGravity() * gpGlobals->frametime);
game/shared/gamemovement.cpp:	mv->m_vecVelocity[2] += player->GetBaseVelocity()[2] * gpGlobals->frametime;
game/shared/gamemovement.cpp:		m_flWaterEntryTime = gpGlobals->curtime;
game/shared/gamemovement.cpp:		if (mv->m_vecVelocity[2] < GetCurrentGravity() * gpGlobals->frametime)
game/shared/gamemovement.cpp:			VectorScale (mv->m_vecVelocity, (1.0 - pm.fraction) * gpGlobals->frametime * 0.9, move);
game/shared/gamemovement.cpp:	VectorScale (mv->m_vecVelocity, gpGlobals->frametime, move);
game/shared/gamemovement.cpp:	VectorMA (mv->GetAbsOrigin(), gpGlobals->frametime, wishvel, out );
game/shared/vehicle_viewblend_shared.cpp:		lockData.flUnlockTime = gpGlobals->curtime + lockData.flLockInterval;
game/shared/vehicle_viewblend_shared.cpp:		if ( ( lockData.bLocked ) && ( gpGlobals->curtime > lockData.flUnlockTime ) )
game/shared/vehicle_viewblend_shared.cpp:				lockData.flUnlockTime = gpGlobals->curtime;
game/shared/vehicle_viewblend_shared.cpp:				float flBlend = RemapValClamped( gpGlobals->curtime - lockData.flUnlockTime, 0, lockData.flUnlockBlendInterval, 0, 1 );
game/shared/vehicle_viewblend_shared.cpp:		pData->flEnterExitStartTime = gpGlobals->curtime;
game/shared/vehicle_viewblend_shared.cpp:		frac = ( gpGlobals->curtime - pData->flEnterExitStartTime ) / pData->flEnterExitDuration;
game/shared/vehicle_viewblend_shared.cpp:		flFracFOV = ( gpGlobals->curtime - pData->flEnterExitStartTime ) / ( pData->flEnterExitDuration * 0.85f );
game/shared/vehicle_viewblend_shared.cpp:		//if ( gpGlobals->frametime )
game/shared/teamplay_round_timer.cpp:			flSecondsRemaining = m_flTimerEndTime - gpGlobals->curtime;
game/shared/teamplay_round_timer.cpp:		SetContextThink( &CTeamRoundTimer::RoundTimerSetupThink, gpGlobals->curtime + 0.05, ROUND_TIMER_SETUP_THINK );
game/shared/teamplay_round_timer.cpp:		SetContextThink( &CTeamRoundTimer::RoundTimerThink, gpGlobals->curtime + 0.05, ROUND_TIMER_THINK );
game/shared/teamplay_round_timer.cpp:		SetContextThink( &CTeamRoundTimer::RoundTimerSetupThink, gpGlobals->curtime + 0.05, ROUND_TIMER_SETUP_THINK );
game/shared/teamplay_round_timer.cpp:	SetContextThink( &CTeamRoundTimer::RoundTimerSetupThink, gpGlobals->curtime + 0.05, ROUND_TIMER_SETUP_THINK );
game/shared/teamplay_round_timer.cpp:	if ( IsDisabled() || m_bTimerPaused || IsInCommentaryMode() || gpGlobals->eLoadType == MapLoad_Background )
game/shared/teamplay_round_timer.cpp:		SetContextThink( &CTeamRoundTimer::RoundTimerThink, gpGlobals->curtime + 0.05, ROUND_TIMER_THINK );
game/shared/teamplay_round_timer.cpp:		SetContextThink( &CTeamRoundTimer::RoundTimerThink, gpGlobals->curtime + 0.05, ROUND_TIMER_THINK );
game/shared/teamplay_round_timer.cpp:			m_flTimerEndTime = gpGlobals->curtime;
game/shared/teamplay_round_timer.cpp:					if ( tf_overtime_nag.GetBool() && ( gpGlobals->curtime > m_flNextOvertimeNag ) )
game/shared/teamplay_round_timer.cpp:						m_flNextOvertimeNag = gpGlobals->curtime + 1.0f;
game/shared/teamplay_round_timer.cpp:			SetContextThink( &CTeamRoundTimer::RoundTimerThink, gpGlobals->curtime + 0.05, ROUND_TIMER_THINK );
game/shared/teamplay_round_timer.cpp:	SetContextThink( &CTeamRoundTimer::RoundTimerThink, gpGlobals->curtime + 0.05, ROUND_TIMER_THINK );
game/shared/teamplay_round_timer.cpp:	m_flTimerEndTime = gpGlobals->curtime + m_flTimeRemaining;
game/shared/teamplay_round_timer.cpp:	m_flTotalTime = m_flTotalTime + (gpGlobals->curtime - m_flTimerEndTime);
game/shared/teamplay_round_timer.cpp:	m_flTimerEndTime = gpGlobals->curtime;
game/shared/teamplay_round_timer.cpp:		m_flTimeRemaining = m_flTimerEndTime - gpGlobals->curtime;
game/shared/teamplay_round_timer.cpp:			m_flTimerEndTime = gpGlobals->curtime;
game/shared/teamplay_round_timer.cpp:			m_flTimerEndTime = gpGlobals->curtime + m_flTimeRemaining;			
game/shared/teamplay_round_timer.cpp:		m_flTimerEndTime = gpGlobals->curtime;
